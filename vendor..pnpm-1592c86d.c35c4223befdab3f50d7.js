"use strict";(self.webpackChunkpixijs_game=self.webpackChunkpixijs_game||[]).push([[395],{7932:(e,n,t)=>{t.d(n,{GD:()=>r.G});t(700),t(8593),t(5369),t(573),t(8464),t(2407),t(9089),t(6993),t(2995),t(8761),t(4362),t(9577),t(858),t(406),t(3740),t(6900);var r=t(6635),i=(t(8909),t(942),t(5487),t(2637),t(8230),t(7218),t(386),t(3423)),o=t(4742),u=t(9096),l=Object.defineProperty,a=(e,n,t)=>(((e,n,t)=>{n in e?l(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t})(e,"symbol"!=typeof n?n+"":n,t),t);const s=class e extends i.dJT{constructor(...n){let t=n[0]??{};if(Array.isArray(t)||"x"in t&&"y"in t||t instanceof i.oA$){(0,i.t66)("6.0.0","MotionBlurFilter constructor params are now options object. See params: { velocity, kernelSize, offset }");t={velocity:{x:"x"in t?t.x:t[0],y:"y"in t?t.y:t[1]}},void 0!==n[1]&&(t.kernelSize=n[1]),void 0!==n[2]&&(t.offset=n[2])}t={...e.DEFAULT_OPTIONS,...t};super({gpuProgram:i.BrD.from({vertex:{source:u.A,entryPoint:"mainVertex"},fragment:{source:"struct MotionBlurUniforms {\n  uVelocity: vec2<f32>,\n  uKernelSize: f32,\n  uOffset: f32,\n};\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> motionBlurUniforms : MotionBlurUniforms;\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  let uVelocity = motionBlurUniforms.uVelocity;\n  let uKernelSize = motionBlurUniforms.uKernelSize;\n  let uOffset = motionBlurUniforms.uOffset;\n\n  let velocity: vec2<f32> = uVelocity / gfu.uInputSize.xy;\n  let offset: f32 = -uOffset / length(uVelocity) - 0.5;\n  let k: i32 = i32(min(uKernelSize - 1, MAX_KERNEL_SIZE - 1));\n\n  var color: vec4<f32> = textureSample(uTexture, uSampler, uv);\n\n  for(var i: i32 = 0; i < k; i += 1) {\n    let bias: vec2<f32> = velocity * (f32(i) / f32(k) + offset);\n    color += textureSample(uTexture, uSampler, uv + bias);\n  }\n  \n  return select(color / f32(uKernelSize), textureSample(uTexture, uSampler, uv), uKernelSize == 0);\n}\n\nconst MAX_KERNEL_SIZE: f32 = 2048;",entryPoint:"mainFragment"}}),glProgram:i.M2g.from({vertex:o.A,fragment:"precision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform vec2 uVelocity;\nuniform int uKernelSize;\nuniform float uOffset;\n\nuniform vec4 uInputSize;\n\nconst int MAX_KERNEL_SIZE = 2048;\n\n// Notice:\n// the perfect way:\n//    int kernelSize = min(uKernelSize, MAX_KERNELSIZE);\n// BUT in real use-case , uKernelSize < MAX_KERNELSIZE almost always.\n// So use uKernelSize directly.\n\nvoid main(void)\n{\n    vec4 color = texture(uTexture, vTextureCoord);\n\n    if (uKernelSize == 0)\n    {\n        finalColor = color;\n        return;\n    }\n\n    vec2 velocity = uVelocity / uInputSize.xy;\n    float offset = -uOffset / length(uVelocity) - 0.5;\n    int k = uKernelSize - 1;\n\n    for(int i = 0; i < MAX_KERNEL_SIZE - 1; i++) {\n        if (i == k) {\n            break;\n        }\n        vec2 bias = velocity * (float(i) / float(k) + offset);\n        color += texture(uTexture, vTextureCoord + bias);\n    }\n    finalColor = color / float(uKernelSize);\n}\n",name:"motion-blur-filter"}),resources:{motionBlurUniforms:{uVelocity:{value:t.velocity,type:"vec2<f32>"},uKernelSize:{value:Math.trunc(t.kernelSize??5),type:"i32"},uOffset:{value:t.offset,type:"f32"}}}}),a(this,"uniforms"),a(this,"_kernelSize"),this.uniforms=this.resources.motionBlurUniforms.uniforms,Object.assign(this,t)}get velocity(){return this.uniforms.uVelocity}set velocity(e){Array.isArray(e)&&(e={x:e[0],y:e[1]}),this.uniforms.uVelocity=e,this._updateDirty()}get velocityX(){return this.velocity.x}set velocityX(e){this.velocity.x=e,this._updateDirty()}get velocityY(){return this.velocity.y}set velocityY(e){this.velocity.y=e,this._updateDirty()}get kernelSize(){return this._kernelSize}set kernelSize(e){this._kernelSize=e,this._updateDirty()}get offset(){return this.uniforms.uOffset}set offset(e){this.uniforms.uOffset=e}_updateDirty(){this.padding=1+(Math.max(Math.abs(this.velocityX),Math.abs(this.velocityY))|0),this.uniforms.uKernelSize=0!==this.velocityX||0!==this.velocityY?this._kernelSize:0}};a(s,"DEFAULT_OPTIONS",{velocity:{x:0,y:0},kernelSize:5,offset:0});var f=Object.defineProperty,c=(e,n,t)=>(((e,n,t)=>{n in e?f(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t})(e,"symbol"!=typeof n?n+"":n,t),t);const m=class e extends i.dJT{constructor(...n){let t=n[0]??{};Array.isArray(t)&&((0,i.t66)("6.0.0","MultiColorReplaceFilter constructor params are now options object. See params: { replacements, tolerance, maxColors }"),t={replacements:t},n[1]&&(t.tolerance=n[1]),n[2]&&(t.maxColors=n[2])),t={...e.DEFAULT_OPTIONS,...t};const r=t.maxColors??t.replacements.length;super({gpuProgram:i.BrD.from({vertex:{source:u.A,entryPoint:"mainVertex"},fragment:{source:"struct MultiColorReplaceUniforms {\n  uOriginalColors: array<vec3<f32>, MAX_COLORS>,\n  uTargetColors: array<vec3<f32>, MAX_COLORS>,\n  uTolerance:f32,\n};\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> multiColorReplaceUniforms : MultiColorReplaceUniforms;\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  let uOriginalColors = multiColorReplaceUniforms.uOriginalColors;\n  let uTargetColors = multiColorReplaceUniforms.uTargetColors;\n  let uTolerance = multiColorReplaceUniforms.uTolerance;\n\n  var color: vec4<f32> = textureSample(uTexture, uSampler, uv);\n\n  let alpha: f32 = color.a;\n\n  if (alpha > 0.0001)\n  {\n    var modColor: vec3<f32> = vec3<f32>(color.rgb) / alpha;\n\n    for(var i: i32 = 0; i < MAX_COLORS; i += 1)\n    {\n      let origColor: vec3<f32> = uOriginalColors[i];\n      if (origColor.r < 0.0)\n      {\n        break;\n      }\n      let colorDiff: vec3<f32> = origColor - modColor;\n      \n      if (length(colorDiff) < uTolerance)\n      {\n        let targetColor: vec3<f32> = uTargetColors[i];\n        color = vec4((targetColor + colorDiff) * alpha, alpha);\n        return color;\n      }\n    }\n  }\n\n  return color;\n}\n\nconst MAX_COLORS: i32 = ${MAX_COLORS};".replace(/\$\{MAX_COLORS\}/g,r.toFixed(0)),entryPoint:"mainFragment"}}),glProgram:i.M2g.from({vertex:o.A,fragment:"in vec2 vTextureCoord;\nout vec4 finalColor;\n\nconst int MAX_COLORS = ${MAX_COLORS};\n\nuniform sampler2D uTexture;\nuniform vec3 uOriginalColors[MAX_COLORS];\nuniform vec3 uTargetColors[MAX_COLORS];\nuniform float uTolerance;\n\nvoid main(void)\n{\n    finalColor = texture(uTexture, vTextureCoord);\n\n    float alpha = finalColor.a;\n    if (alpha < 0.0001)\n    {\n      return;\n    }\n\n    vec3 color = finalColor.rgb / alpha;\n\n    for(int i = 0; i < MAX_COLORS; i++)\n    {\n      vec3 origColor = uOriginalColors[i];\n      if (origColor.r < 0.0)\n      {\n        break;\n      }\n      vec3 colorDiff = origColor - color;\n      if (length(colorDiff) < uTolerance)\n      {\n        vec3 targetColor = uTargetColors[i];\n        finalColor = vec4((targetColor + colorDiff) * alpha, alpha);\n        return;\n      }\n    }\n}\n".replace(/\$\{MAX_COLORS\}/g,r.toFixed(0)),name:"multi-color-replace-filter"}),resources:{multiColorReplaceUniforms:{uOriginalColors:{value:new Float32Array(3*r),type:"vec3<f32>",size:r},uTargetColors:{value:new Float32Array(3*r),type:"vec3<f32>",size:r},uTolerance:{value:t.tolerance,type:"f32"}}}}),c(this,"uniforms"),c(this,"_replacements",[]),c(this,"_maxColors"),this._maxColors=r,this.uniforms=this.resources.multiColorReplaceUniforms.uniforms,this.replacements=t.replacements}set replacements(e){const n=this.uniforms.uOriginalColors,t=this.uniforms.uTargetColors,r=e.length,o=new i.Q1f;if(r>this._maxColors)throw new Error(`Length of replacements (${r}) exceeds the maximum colors length (${this._maxColors})`);let u,l,a;n[3*r]=-1;for(let i=0;i<r;i++){const r=e[i];o.setValue(r[0]),[u,l,a]=o.toArray(),n[3*i]=u,n[3*i+1]=l,n[3*i+2]=a,o.setValue(r[1]),[u,l,a]=o.toArray(),t[3*i]=u,t[3*i+1]=l,t[3*i+2]=a}this._replacements=e}get replacements(){return this._replacements}refresh(){this.replacements=this._replacements}get maxColors(){return this._maxColors}get tolerance(){return this.uniforms.uTolerance}set tolerance(e){this.uniforms.uTolerance=e}set epsilon(e){(0,i.t66)("6.0.0","MultiColorReplaceFilter.epsilon is deprecated, please use MultiColorReplaceFilter.tolerance instead"),this.tolerance=e}get epsilon(){return(0,i.t66)("6.0.0","MultiColorReplaceFilter.epsilon is deprecated, please use MultiColorReplaceFilter.tolerance instead"),this.tolerance}};c(m,"DEFAULT_OPTIONS",{replacements:[[16711680,255]],tolerance:.05,maxColors:void 0});var p=Object.defineProperty,d=(e,n,t)=>(((e,n,t)=>{n in e?p(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t})(e,"symbol"!=typeof n?n+"":n,t),t);const v=class e extends i.dJT{constructor(n){n={...e.DEFAULT_OPTIONS,...n};super({gpuProgram:i.BrD.from({vertex:{source:u.A,entryPoint:"mainVertex"},fragment:{source:"struct OldFilmUniforms {\n    uSepia: f32,\n    uNoise: vec2<f32>,\n    uScratch: vec3<f32>,\n    uVignetting: vec3<f32>,\n    uSeed: f32,\n    uDimensions: vec2<f32>,\n};\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> oldFilmUniforms : OldFilmUniforms;\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  var color: vec4<f32> = textureSample(uTexture, uSampler, uv);\n\n  if (oldFilmUniforms.uSepia > 0.)\n  {\n    color = vec4<f32>(sepia(color.rgb), color.a);\n  }\n\n  let coord: vec2<f32> = uv * gfu.uInputSize.xy / oldFilmUniforms.uDimensions;\n\n  if (oldFilmUniforms.uVignetting[0] > 0.)\n  {\n    color *= vec4<f32>(vec3<f32>(vignette(color.rgb, coord)), color.a);\n  }\n\n  let uScratch = oldFilmUniforms.uScratch; \n\n  if (uScratch[1] > oldFilmUniforms.uSeed && uScratch[0] != 0.)\n  {\n    color = vec4<f32>(scratch(color.rgb, coord), color.a);\n  }\n\n  let uNoise = oldFilmUniforms.uNoise;\n\n  if (uNoise[0] > 0.0 && uNoise[1] > 0.0)\n  {\n    color += vec4<f32>(vec3<f32>(noise(uv)), color.a);\n  }\n\n  return color;\n}\n\nconst SQRT_2: f32 = 1.414213;\nconst SEPIA_RGB: vec3<f32> = vec3<f32>(112.0 / 255.0, 66.0 / 255.0, 20.0 / 255.0);\n\nfn modulo(x: f32, y: f32) -> f32\n{\n  return x - y * floor(x/y);\n}\n\nfn rand(co: vec2<f32>) -> f32\n{\n  return fract(sin(dot(co, vec2<f32>(12.9898, 78.233))) * 43758.5453);\n}\n\nfn overlay(src: vec3<f32>, dst: vec3<f32>) -> vec3<f32>\n{\n    // if (dst <= 0.5) then: 2 * src * dst\n    // if (dst > 0.5) then: 1 - 2 * (1 - dst) * (1 - src)\n\n    return vec3<f32>(\n      select((1.0 - 2.0 * (1.0 - dst.x) * (1.0 - src.x)), (2.0 * src.x * dst.x), (dst.x <= 0.5)), \n      select((1.0 - 2.0 * (1.0 - dst.y) * (1.0 - src.y)), (2.0 * src.y * dst.y), (dst.y <= 0.5)),\n      select((1.0 - 2.0 * (1.0 - dst.z) * (1.0 - src.z)), (2.0 * src.z * dst.z), (dst.z <= 0.5))\n    );\n}\n\nfn sepia(co: vec3<f32>) -> vec3<f32>\n{\n  let gray: f32 = (co.x + co.y + co.z) / 3.0;\n  let grayscale: vec3<f32> = vec3<f32>(gray);\n  let color = overlay(SEPIA_RGB, grayscale);\n  return grayscale + oldFilmUniforms.uSepia * (color - grayscale);\n}\n\nfn vignette(co: vec3<f32>, coord: vec2<f32>) -> f32\n{\n  let uVignetting = oldFilmUniforms.uVignetting;\n  let uDimensions = oldFilmUniforms.uDimensions;\n  \n  let outter: f32 = SQRT_2 - uVignetting[0] * SQRT_2;\n  var dir: vec2<f32> = vec2<f32>(vec2<f32>(0.5) - coord);\n  dir.y *= uDimensions.y / uDimensions.x;\n  let darker: f32 = clamp((outter - length(dir) * SQRT_2) / ( 0.00001 + uVignetting[2] * SQRT_2), 0.0, 1.0);\n  return darker + (1.0 - darker) * (1.0 - uVignetting[1]);\n}\n\nfn scratch(co: vec3<f32>, coord: vec2<f32>) -> vec3<f32>\n{\n  var color = co;\n  let uScratch = oldFilmUniforms.uScratch;\n  let uSeed = oldFilmUniforms.uSeed;\n  let uDimensions = oldFilmUniforms.uDimensions;\n\n  let phase: f32 = uSeed * 256.0;\n  let s: f32 = modulo(floor(phase), 2.0);\n  let dist: f32 = 1.0 / uScratch[1];\n  let d: f32 = distance(coord, vec2<f32>(uSeed * dist, abs(s - uSeed * dist)));\n\n  if (d < uSeed * 0.6 + 0.4)\n  {\n    let period: f32 = uScratch[1] * 10.0;\n\n    let xx: f32 = coord.x * period + phase;\n    let aa: f32 = abs(modulo(xx, 0.5) * 4.0);\n    let bb: f32 = modulo(floor(xx / 0.5), 2.0);\n    let yy: f32 = (1.0 - bb) * aa + bb * (2.0 - aa);\n\n    let kk: f32 = 2.0 * period;\n    let dw: f32 = uScratch[2] / uDimensions.x * (0.75 + uSeed);\n    let dh: f32 = dw * kk;\n\n    var tine: f32 = (yy - (2.0 - dh));\n\n    if (tine > 0.0) {\n        let _sign: f32 = sign(uScratch[0]);\n\n        tine = s * tine / period + uScratch[0] + 0.1;\n        tine = clamp(tine + 1.0, 0.5 + _sign * 0.5, 1.5 + _sign * 0.5);\n\n        color *= tine;\n    }\n  }\n\n  return color;\n}\n\nfn noise(coord: vec2<f32>) -> f32\n{\n  let uNoise = oldFilmUniforms.uNoise;\n  let uSeed = oldFilmUniforms.uSeed;\n\n  var pixelCoord: vec2<f32> = coord * gfu.uInputSize.xy;\n  pixelCoord.x = floor(pixelCoord.x / uNoise[1]);\n  pixelCoord.y = floor(pixelCoord.y / uNoise[1]);\n  return (rand(pixelCoord * uNoise[1] * uSeed) - 0.5) * uNoise[0];\n}",entryPoint:"mainFragment"}}),glProgram:i.M2g.from({vertex:o.A,fragment:"precision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform float uSepia;\nuniform vec2 uNoise;\nuniform vec3 uScratch;\nuniform vec3 uVignetting;\nuniform float uSeed;\nuniform vec2 uDimensions;\n\nuniform vec4 uInputSize;\n\nconst float SQRT_2 = 1.414213;\nconst vec3 SEPIA_RGB = vec3(112.0 / 255.0, 66.0 / 255.0, 20.0 / 255.0);\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec3 Overlay(vec3 src, vec3 dst)\n{\n    // if (dst <= 0.5) then: 2 * src * dst\n    // if (dst > 0.5) then: 1 - 2 * (1 - dst) * (1 - src)\n    return vec3((dst.x <= 0.5) ? (2.0 * src.x * dst.x) : (1.0 - 2.0 * (1.0 - dst.x) * (1.0 - src.x)),\n                (dst.y <= 0.5) ? (2.0 * src.y * dst.y) : (1.0 - 2.0 * (1.0 - dst.y) * (1.0 - src.y)),\n                (dst.z <= 0.5) ? (2.0 * src.z * dst.z) : (1.0 - 2.0 * (1.0 - dst.z) * (1.0 - src.z)));\n}\n\n\nvoid main()\n{\n    finalColor = texture(uTexture, vTextureCoord);\n    vec3 color = finalColor.rgb;\n\n    if (uSepia > 0.0)\n    {\n        float gray = (color.x + color.y + color.z) / 3.0;\n        vec3 grayscale = vec3(gray);\n\n        color = Overlay(SEPIA_RGB, grayscale);\n\n        color = grayscale + uSepia * (color - grayscale);\n    }\n\n    vec2 coord = vTextureCoord * uInputSize.xy / uDimensions.xy;\n\n    float vignette = uVignetting[0];\n    float vignetteAlpha = uVignetting[1];\n    float vignetteBlur = uVignetting[2];\n\n    if (vignette > 0.0)\n    {\n        float outter = SQRT_2 - vignette * SQRT_2;\n        vec2 dir = vec2(vec2(0.5, 0.5) - coord);\n        dir.y *= uDimensions.y / uDimensions.x;\n        float darker = clamp((outter - length(dir) * SQRT_2) / ( 0.00001 + vignetteBlur * SQRT_2), 0.0, 1.0);\n        color.rgb *= darker + (1.0 - darker) * (1.0 - vignetteAlpha);\n    }\n\n    float scratch = uScratch[0];\n    float scratchDensity = uScratch[1];\n    float scratchWidth = uScratch[2];\n\n    if (scratchDensity > uSeed && scratch != 0.0)\n    {\n        float phase = uSeed * 256.0;\n        float s = mod(floor(phase), 2.0);\n        float dist = 1.0 / scratchDensity;\n        float d = distance(coord, vec2(uSeed * dist, abs(s - uSeed * dist)));\n        if (d < uSeed * 0.6 + 0.4)\n        {\n            highp float period = scratchDensity * 10.0;\n\n            float xx = coord.x * period + phase;\n            float aa = abs(mod(xx, 0.5) * 4.0);\n            float bb = mod(floor(xx / 0.5), 2.0);\n            float yy = (1.0 - bb) * aa + bb * (2.0 - aa);\n\n            float kk = 2.0 * period;\n            float dw = scratchWidth / uDimensions.x * (0.75 + uSeed);\n            float dh = dw * kk;\n\n            float tine = (yy - (2.0 - dh));\n\n            if (tine > 0.0) {\n                float _sign = sign(scratch);\n\n                tine = s * tine / period + scratch + 0.1;\n                tine = clamp(tine + 1.0, 0.5 + _sign * 0.5, 1.5 + _sign * 0.5);\n\n                color.rgb *= tine;\n            }\n        }\n    }\n\n    float noise = uNoise[0];\n    float noiseSize = uNoise[1];\n\n    if (noise > 0.0 && noiseSize > 0.0)\n    {\n        vec2 pixelCoord = vTextureCoord.xy * uInputSize.xy;\n        pixelCoord.x = floor(pixelCoord.x / noiseSize);\n        pixelCoord.y = floor(pixelCoord.y / noiseSize);\n        // vec2 d = pixelCoord * noiseSize * vec2(1024.0 + uSeed * 512.0, 1024.0 - uSeed * 512.0);\n        // float _noise = snoise(d) * 0.5;\n        float _noise = rand(pixelCoord * noiseSize * uSeed) - 0.5;\n        color += _noise * noise;\n    }\n\n    finalColor.rgb = color;\n}",name:"old-film-filter"}),resources:{oldFilmUniforms:{uSepia:{value:n.sepia,type:"f32"},uNoise:{value:new Float32Array(2),type:"vec2<f32>"},uScratch:{value:new Float32Array(3),type:"vec3<f32>"},uVignetting:{value:new Float32Array(3),type:"vec3<f32>"},uSeed:{value:n.seed,type:"f32"},uDimensions:{value:new Float32Array(2),type:"vec2<f32>"}}}}),d(this,"uniforms"),d(this,"seed"),this.uniforms=this.resources.oldFilmUniforms.uniforms,Object.assign(this,n)}apply(e,n,t,r){this.uniforms.uDimensions[0]=n.frame.width,this.uniforms.uDimensions[1]=n.frame.height,this.uniforms.uSeed=this.seed,e.applyFilter(this,n,t,r)}get sepia(){return this.uniforms.uSepia}set sepia(e){this.uniforms.uSepia=e}get noise(){return this.uniforms.uNoise[0]}set noise(e){this.uniforms.uNoise[0]=e}get noiseSize(){return this.uniforms.uNoise[1]}set noiseSize(e){this.uniforms.uNoise[1]=e}get scratch(){return this.uniforms.uScratch[0]}set scratch(e){this.uniforms.uScratch[0]=e}get scratchDensity(){return this.uniforms.uScratch[1]}set scratchDensity(e){this.uniforms.uScratch[1]=e}get scratchWidth(){return this.uniforms.uScratch[2]}set scratchWidth(e){this.uniforms.uScratch[2]=e}get vignetting(){return this.uniforms.uVignetting[0]}set vignetting(e){this.uniforms.uVignetting[0]=e}get vignettingAlpha(){return this.uniforms.uVignetting[1]}set vignettingAlpha(e){this.uniforms.uVignetting[1]=e}get vignettingBlur(){return this.uniforms.uVignetting[2]}set vignettingBlur(e){this.uniforms.uVignetting[2]=e}};d(v,"DEFAULT_OPTIONS",{sepia:.3,noise:.3,noiseSize:1,scratch:.5,scratchDensity:.3,scratchWidth:1,vignetting:.3,vignettingAlpha:1,vignettingBlur:.3,seed:0});var g=Object.defineProperty,h=(e,n,t)=>(((e,n,t)=>{n in e?g(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t})(e,"symbol"!=typeof n?n+"":n,t),t);const x=class e extends i.dJT{constructor(...n){let t=n[0]??{};"number"==typeof t&&((0,i.t66)("6.0.0","OutlineFilter constructor params are now options object. See params: { thickness, color, quality, alpha, knockout }"),t={thickness:t},void 0!==n[1]&&(t.color=n[1]),void 0!==n[2]&&(t.quality=n[2]),void 0!==n[3]&&(t.alpha=n[3]),void 0!==n[4]&&(t.knockout=n[4])),t={...e.DEFAULT_OPTIONS,...t};const r=t.quality??.1;super({gpuProgram:i.BrD.from({vertex:{source:u.A,entryPoint:"mainVertex"},fragment:{source:"struct OutlineUniforms {\n  uThickness:vec2<f32>,\n  uColor:vec3<f32>,\n  uAlpha:f32,\n  uAngleStep:f32,\n  uKnockout:f32,\n};\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> outlineUniforms : OutlineUniforms;\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  let sourceColor: vec4<f32> = textureSample(uTexture, uSampler, uv);\n  let contentColor: vec4<f32> = sourceColor * (1. - outlineUniforms.uKnockout);\n  \n  let outlineAlpha: f32 = outlineUniforms.uAlpha * outlineMaxAlphaAtPos(uv) * (1. - sourceColor.a);\n  let outlineColor: vec4<f32> = vec4<f32>(vec3<f32>(outlineUniforms.uColor) * outlineAlpha, outlineAlpha);\n  \n  return contentColor + outlineColor;\n}\n\nfn outlineMaxAlphaAtPos(uv: vec2<f32>) -> f32 {\n  let thickness = outlineUniforms.uThickness;\n\n  if (thickness.x == 0. || thickness.y == 0.) {\n    return 0.;\n  }\n  \n  let angleStep = outlineUniforms.uAngleStep;\n\n  var displacedColor: vec4<f32>;\n  var displacedPos: vec2<f32>;\n\n  var maxAlpha: f32 = 0.;\n  var displaced: vec2<f32>;\n  var curColor: vec4<f32>;\n\n  for (var angle = 0.; angle <= DOUBLE_PI; angle += angleStep)\n  {\n    displaced.x = uv.x + thickness.x * cos(angle);\n    displaced.y = uv.y + thickness.y * sin(angle);\n    curColor = textureSample(uTexture, uSampler, clamp(displaced, gfu.uInputClamp.xy, gfu.uInputClamp.zw));\n    maxAlpha = max(maxAlpha, curColor.a);\n  }\n\n  return maxAlpha;\n}\n\nconst DOUBLE_PI: f32 = 3.14159265358979323846264 * 2.;",entryPoint:"mainFragment"}}),glProgram:i.M2g.from({vertex:o.A,fragment:"precision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform vec2 uThickness;\nuniform vec3 uColor;\nuniform float uAlpha;\nuniform float uKnockout;\n\nuniform vec4 uInputClamp;\n\nconst float DOUBLE_PI = 2. * 3.14159265358979323846264;\nconst float ANGLE_STEP = ${ANGLE_STEP};\n\nfloat outlineMaxAlphaAtPos(vec2 pos) {\n    if (uThickness.x == 0. || uThickness.y == 0.) {\n        return 0.;\n    }\n\n    vec4 displacedColor;\n    vec2 displacedPos;\n    float maxAlpha = 0.;\n\n    for (float angle = 0.; angle <= DOUBLE_PI; angle += ANGLE_STEP) {\n        displacedPos.x = vTextureCoord.x + uThickness.x * cos(angle);\n        displacedPos.y = vTextureCoord.y + uThickness.y * sin(angle);\n        displacedColor = texture(uTexture, clamp(displacedPos, uInputClamp.xy, uInputClamp.zw));\n        maxAlpha = max(maxAlpha, displacedColor.a);\n    }\n\n    return maxAlpha;\n}\n\nvoid main(void) {\n    vec4 sourceColor = texture(uTexture, vTextureCoord);\n    vec4 contentColor = sourceColor * float(uKnockout < 0.5);\n    float outlineAlpha = uAlpha * outlineMaxAlphaAtPos(vTextureCoord.xy) * (1.-sourceColor.a);\n    vec4 outlineColor = vec4(vec3(uColor) * outlineAlpha, outlineAlpha);\n    finalColor = contentColor + outlineColor;\n}\n".replace(/\$\{ANGLE_STEP\}/,e.getAngleStep(r).toFixed(7)),name:"outline-filter"}),resources:{outlineUniforms:{uThickness:{value:new Float32Array(2),type:"vec2<f32>"},uColor:{value:new Float32Array(3),type:"vec3<f32>"},uAlpha:{value:t.alpha,type:"f32"},uAngleStep:{value:0,type:"f32"},uKnockout:{value:t.knockout?1:0,type:"f32"}}}}),h(this,"uniforms"),h(this,"_thickness"),h(this,"_quality"),h(this,"_color"),this.uniforms=this.resources.outlineUniforms.uniforms,this.uniforms.uAngleStep=e.getAngleStep(r),this._color=new i.Q1f,this.color=t.color??0,Object.assign(this,t)}apply(e,n,t,r){this.uniforms.uThickness[0]=this.thickness/n.source.width,this.uniforms.uThickness[1]=this.thickness/n.source.height,e.applyFilter(this,n,t,r)}static getAngleStep(n){return parseFloat((2*Math.PI/Math.max(n*e.MAX_SAMPLES,e.MIN_SAMPLES)).toFixed(7))}get thickness(){return this._thickness}set thickness(e){this._thickness=this.padding=e}get color(){return this._color.value}set color(e){this._color.setValue(e);const[n,t,r]=this._color.toArray();this.uniforms.uColor[0]=n,this.uniforms.uColor[1]=t,this.uniforms.uColor[2]=r}get alpha(){return this.uniforms.uAlpha}set alpha(e){this.uniforms.uAlpha=e}get quality(){return this._quality}set quality(n){this._quality=n,this.uniforms.uAngleStep=e.getAngleStep(n)}get knockout(){return 1===this.uniforms.uKnockout}set knockout(e){this.uniforms.uKnockout=e?1:0}};h(x,"DEFAULT_OPTIONS",{thickness:1,color:0,alpha:1,quality:.1,knockout:!1}),h(x,"MIN_SAMPLES",1),h(x,"MAX_SAMPLES",100);i.dJT;var y=Object.defineProperty,S=(e,n,t)=>(((e,n,t)=>{n in e?y(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t})(e,"symbol"!=typeof n?n+"":n,t),t);const C=class e extends i.dJT{constructor(...n){let t=n[0]??{};if("number"==typeof t){if((0,i.t66)("6.0.0","RadialBlurFilter constructor params are now options object. See params: { angle, center, kernelSize, radius }"),t={angle:t},n[1]){const e="x"in n[1]?n[1].x:n[1][0],r="y"in n[1]?n[1].y:n[1][1];t.center={x:e,y:r}}n[2]&&(t.kernelSize=n[2]),n[3]&&(t.radius=n[3])}t={...e.DEFAULT_OPTIONS,...t};super({gpuProgram:i.BrD.from({vertex:{source:u.A,entryPoint:"mainVertex"},fragment:{source:"struct RadialBlurUniforms {\n  uRadian: f32,\n  uCenter: vec2<f32>,\n  uKernelSize: f32,\n  uRadius: f32,\n};\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> radialBlurUniforms : RadialBlurUniforms;\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  let uRadian = radialBlurUniforms.uRadian;\n  let uCenter = radialBlurUniforms.uCenter;\n  let uKernelSize = radialBlurUniforms.uKernelSize;\n  let uRadius = radialBlurUniforms.uRadius;\n  \n  var returnColorOnly = false;\n\n  if (uKernelSize == 0)\n  {\n    returnColorOnly = true;\n  }\n\n  let aspect: f32 = gfu.uInputSize.y / gfu.uInputSize.x;\n  let center: vec2<f32> = uCenter.xy / gfu.uInputSize.xy;\n  let gradient: f32 = uRadius / gfu.uInputSize.x * 0.3;\n  let radius: f32 = uRadius / gfu.uInputSize.x - gradient * 0.5;\n  let k: i32 = i32(uKernelSize - 1);\n\n  var coord: vec2<f32> = uv;\n  let dir: vec2<f32> = vec2<f32>(center - coord);\n  let dist: f32 = length(vec2<f32>(dir.x, dir.y * aspect));\n\n  var radianStep: f32 = uRadian;\n  \n  if (radius >= 0.0 && dist > radius)\n  {\n    let delta: f32 = dist - radius;\n    let gap: f32 = gradient;\n    let scale: f32 = 1.0 - abs(delta / gap);\n    if (scale <= 0.0) {\n      returnColorOnly = true;\n    }\n    radianStep *= scale;\n  }\n\n  radianStep /= f32(k);\n\n  let s: f32 = sin(radianStep);\n  let c: f32 = cos(radianStep);\n  let rotationMatrix: mat2x2<f32> = mat2x2<f32>(vec2<f32>(c, -s), vec2<f32>(s, c));\n  \n  var color: vec4<f32> = textureSample(uTexture, uSampler, uv);\n  let baseColor = vec4<f32>(color);\n\n  let minK: i32 = min(i32(uKernelSize) - 1, MAX_KERNEL_SIZE - 1);\n\n  for(var i: i32 = 0; i < minK; i += 1) \n  {\n    coord -= center;\n    coord.y *= aspect;\n    coord = rotationMatrix * coord;\n    coord.y /= aspect;\n    coord += center;\n    let sample: vec4<f32> = textureSample(uTexture, uSampler, coord);\n    // switch to pre-multiplied alpha to correctly blur transparent images\n    // sample.rgb *= sample.a;\n    color += sample;\n  }\n\n  return select(color / f32(uKernelSize), baseColor, returnColorOnly);\n}\n\nconst MAX_KERNEL_SIZE: i32 = 2048;",entryPoint:"mainFragment"}}),glProgram:i.M2g.from({vertex:o.A,fragment:"precision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform float uRadian;\nuniform vec2 uCenter;\nuniform float uRadius;\nuniform int uKernelSize;\n\nuniform vec4 uInputSize;\n\nconst int MAX_KERNEL_SIZE = 2048;\n\nvoid main(void)\n{\n    vec4 color = texture(uTexture, vTextureCoord);\n\n    if (uKernelSize == 0)\n    {\n        finalColor = color;\n        return;\n    }\n\n    float aspect = uInputSize.y / uInputSize.x;\n    vec2 center = uCenter.xy / uInputSize.xy;\n    float gradient = uRadius / uInputSize.x * 0.3;\n    float radius = uRadius / uInputSize.x - gradient * 0.5;\n    int k = uKernelSize - 1;\n\n    vec2 coord = vTextureCoord;\n    vec2 dir = vec2(center - coord);\n    float dist = length(vec2(dir.x, dir.y * aspect));\n\n    float radianStep = uRadian;\n    if (radius >= 0.0 && dist > radius) {\n        float delta = dist - radius;\n        float gap = gradient;\n        float scale = 1.0 - abs(delta / gap);\n        if (scale <= 0.0) {\n            finalColor = color;\n            return;\n        }\n        radianStep *= scale;\n    }\n    radianStep /= float(k);\n\n    float s = sin(radianStep);\n    float c = cos(radianStep);\n    mat2 rotationMatrix = mat2(vec2(c, -s), vec2(s, c));\n\n    for(int i = 0; i < MAX_KERNEL_SIZE - 1; i++) {\n        if (i == k) {\n            break;\n        }\n\n        coord -= center;\n        coord.y *= aspect;\n        coord = rotationMatrix * coord;\n        coord.y /= aspect;\n        coord += center;\n\n        vec4 sample = texture(uTexture, coord);\n\n        // switch to pre-multiplied alpha to correctly blur transparent images\n        // sample.rgb *= sample.a;\n\n        color += sample;\n    }\n\n    finalColor = color / float(uKernelSize);\n}\n",name:"radial-blur-filter"}),resources:{radialBlurUniforms:{uRadian:{value:0,type:"f32"},uCenter:{value:t.center,type:"vec2<f32>"},uKernelSize:{value:t.kernelSize,type:"i32"},uRadius:{value:t.radius,type:"f32"}}}}),S(this,"uniforms"),S(this,"_angle"),S(this,"_kernelSize"),this.uniforms=this.resources.radialBlurUniforms.uniforms,Object.assign(this,t)}_updateKernelSize(){this.uniforms.uKernelSize=0!==this._angle?this.kernelSize:0}get angle(){return this._angle}set angle(e){this._angle=e,this.uniforms.uRadian=e*Math.PI/180,this._updateKernelSize()}get center(){return this.uniforms.uCenter}set center(e){Array.isArray(e)&&(e={x:e[0],y:e[1]}),this.uniforms.uCenter=e}get centerX(){return this.center.x}set centerX(e){this.center.x=e}get centerY(){return this.center.y}set centerY(e){this.center.y=e}get kernelSize(){return this._kernelSize}set kernelSize(e){this._kernelSize=e,this._updateKernelSize()}get radius(){return this.uniforms.uRadius}set radius(e){this.uniforms.uRadius=e<0||e===1/0?-1:e}};S(C,"DEFAULT_OPTIONS",{angle:0,center:{x:0,y:0},kernelSize:5,radius:-1});var b=Object.defineProperty,T=(e,n,t)=>(((e,n,t)=>{n in e?b(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t})(e,"symbol"!=typeof n?n+"":n,t),t);const A=class e extends i.dJT{constructor(n){n={...e.DEFAULT_OPTIONS,...n};super({gpuProgram:i.BrD.from({vertex:{source:u.A,entryPoint:"mainVertex"},fragment:{source:"struct ReflectionUniforms {\n  uMirror: f32,\n  uBoundary: f32,\n  uAmplitude: vec2<f32>,\n  uWavelength: vec2<f32>,\n  uAlpha: vec2<f32>,\n  uTime: f32,\n  uDimensions: vec2<f32>,\n};\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> reflectionUniforms : ReflectionUniforms;\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  let uDimensions: vec2<f32> = reflectionUniforms.uDimensions;\n  let uBoundary: f32 = reflectionUniforms.uBoundary;\n  let uMirror: bool = reflectionUniforms.uMirror > 0.5;\n  let uAmplitude: vec2<f32> = reflectionUniforms.uAmplitude;\n  let uWavelength: vec2<f32> = reflectionUniforms.uWavelength;\n  let uAlpha: vec2<f32> = reflectionUniforms.uAlpha;\n  let uTime: f32 = reflectionUniforms.uTime;\n\n  let pixelCoord: vec2<f32> = uv * gfu.uInputSize.xy;\n  let coord: vec2<f32> = pixelCoord /uDimensions;\n  var returnColorOnly: bool = false;\n\n  if (coord.y < uBoundary) {\n    returnColorOnly = true;\n  }\n\n  let k: f32 = (coord.y - uBoundary) / (1. - uBoundary + 0.0001);\n  let areaY: f32 = uBoundary * uDimensions.y / gfu.uInputSize.y;\n  let v: f32 = areaY + areaY - uv.y;\n  let y: f32 = select(uv.y, v, uMirror);\n\n  let amplitude: f32 = ((uAmplitude.y - uAmplitude.x) * k + uAmplitude.x ) / gfu.uInputSize.x;\n  let waveLength: f32 = ((uWavelength.y - uWavelength.x) * k + uWavelength.x) / gfu.uInputSize.y;\n  let alpha: f32 = select((uAlpha.y - uAlpha.x) * k + uAlpha.x, 1., returnColorOnly);\n\n  var x: f32 = uv.x + cos(v * 6.28 / waveLength - uTime) * amplitude;\n  x = clamp(x, gfu.uInputClamp.x, gfu.uInputClamp.z);\n  \n  return textureSample(uTexture, uSampler, select(vec2<f32>(x, y), uv, returnColorOnly)) * alpha;\n}\n\nfn rand(co: vec2<f32>) -> f32 \n{\n  return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}",entryPoint:"mainFragment"}}),glProgram:i.M2g.from({vertex:o.A,fragment:"precision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform float uMirror;\nuniform float uBoundary;\nuniform vec2 uAmplitude;\nuniform vec2 uWavelength;\nuniform vec2 uAlpha;\nuniform float uTime;\nuniform vec2 uDimensions;\n\nuniform vec4 uInputSize;\nuniform vec4 uInputClamp;\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main(void)\n{\n    vec2 pixelCoord = vTextureCoord.xy * uInputSize.xy;\n    vec2 coord = pixelCoord / uDimensions;\n\n    if (coord.y < uBoundary) {\n        finalColor = texture(uTexture, vTextureCoord);\n        return;\n    }\n\n    float k = (coord.y - uBoundary) / (1. - uBoundary + 0.0001);\n    float areaY = uBoundary * uDimensions.y / uInputSize.y;\n    float v = areaY + areaY - vTextureCoord.y;\n    float y = uMirror > 0.5 ? v : vTextureCoord.y;\n\n    float _amplitude = ((uAmplitude.y - uAmplitude.x) * k + uAmplitude.x ) / uInputSize.x;\n    float _waveLength = ((uWavelength.y - uWavelength.x) * k + uWavelength.x) / uInputSize.y;\n    float _alpha = (uAlpha.y - uAlpha.x) * k + uAlpha.x;\n\n    float x = vTextureCoord.x + cos(v * 6.28 / _waveLength - uTime) * _amplitude;\n    x = clamp(x, uInputClamp.x, uInputClamp.z);\n\n    vec4 color = texture(uTexture, vec2(x, y));\n\n    finalColor = color * _alpha;\n}\n",name:"reflection-filter"}),resources:{reflectionUniforms:{uMirror:{value:n.mirror?1:0,type:"f32"},uBoundary:{value:n.boundary,type:"f32"},uAmplitude:{value:n.amplitude,type:"vec2<f32>"},uWavelength:{value:n.waveLength,type:"vec2<f32>"},uAlpha:{value:n.alpha,type:"vec2<f32>"},uTime:{value:n.time,type:"f32"},uDimensions:{value:new Float32Array(2),type:"vec2<f32>"}}}}),T(this,"uniforms"),T(this,"time",0),this.uniforms=this.resources.reflectionUniforms.uniforms,Object.assign(this,n)}apply(e,n,t,r){this.uniforms.uDimensions[0]=n.frame.width,this.uniforms.uDimensions[1]=n.frame.height,this.uniforms.uTime=this.time,e.applyFilter(this,n,t,r)}get mirror(){return this.uniforms.uMirror>.5}set mirror(e){this.uniforms.uMirror=e?1:0}get boundary(){return this.uniforms.uBoundary}set boundary(e){this.uniforms.uBoundary=e}get amplitude(){return Array.from(this.uniforms.uAmplitude)}set amplitude(e){this.uniforms.uAmplitude[0]=e[0],this.uniforms.uAmplitude[1]=e[1]}get amplitudeStart(){return this.uniforms.uAmplitude[0]}set amplitudeStart(e){this.uniforms.uAmplitude[0]=e}get amplitudeEnd(){return this.uniforms.uAmplitude[1]}set amplitudeEnd(e){this.uniforms.uAmplitude[1]=e}get waveLength(){return Array.from(this.uniforms.uWavelength)}set waveLength(e){this.uniforms.uWavelength[0]=e[0],this.uniforms.uWavelength[1]=e[1]}get wavelengthStart(){return this.uniforms.uWavelength[0]}set wavelengthStart(e){this.uniforms.uWavelength[0]=e}get wavelengthEnd(){return this.uniforms.uWavelength[1]}set wavelengthEnd(e){this.uniforms.uWavelength[1]=e}get alpha(){return Array.from(this.uniforms.uAlpha)}set alpha(e){this.uniforms.uAlpha[0]=e[0],this.uniforms.uAlpha[1]=e[1]}get alphaStart(){return this.uniforms.uAlpha[0]}set alphaStart(e){this.uniforms.uAlpha[0]=e}get alphaEnd(){return this.uniforms.uAlpha[1]}set alphaEnd(e){this.uniforms.uAlpha[1]=e}};T(A,"DEFAULT_OPTIONS",{mirror:!0,boundary:.5,amplitude:[0,20],waveLength:[30,100],alpha:[1,1],time:0});var O=Object.defineProperty,_=(e,n,t)=>(((e,n,t)=>{n in e?O(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t})(e,"symbol"!=typeof n?n+"":n,t),t);const z=class e extends i.dJT{constructor(...n){let t=n[0]??{};(Array.isArray(t)||"x"in t&&"y"in t)&&((0,i.t66)("6.0.0","RGBSplitFilter constructor params are now options object. See params: { red, green, blue }"),t={red:t},void 0!==n[1]&&(t.green=n[1]),void 0!==n[2]&&(t.blue=n[2])),t={...e.DEFAULT_OPTIONS,...t};super({gpuProgram:i.BrD.from({vertex:{source:u.A,entryPoint:"mainVertex"},fragment:{source:"struct RgbSplitUniforms {\n    uRed: vec2<f32>,\n    uGreen: vec2<f32>,\n    uBlue: vec3<f32>,\n};\n\nstruct GlobalFilterUniforms {\n    uInputSize:vec4<f32>,\n    uInputPixel:vec4<f32>,\n    uInputClamp:vec4<f32>,\n    uOutputFrame:vec4<f32>,\n    uGlobalFrame:vec4<f32>,\n    uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> rgbSplitUniforms : RgbSplitUniforms;\n\n@fragment\nfn mainFragment(\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n    let r = textureSample(uTexture, uSampler, uv + vec2<f32>(rgbSplitUniforms.uRed.x / gfu.uInputSize.x, rgbSplitUniforms.uRed.y / gfu.uInputSize.y)).r;\n    let g = textureSample(uTexture, uSampler, uv + vec2<f32>(rgbSplitUniforms.uGreen.x / gfu.uInputSize.x, rgbSplitUniforms.uGreen.y / gfu.uInputSize.y)).g;\n    let b = textureSample(uTexture, uSampler, uv + vec2<f32>(rgbSplitUniforms.uBlue.x / gfu.uInputSize.x, rgbSplitUniforms.uBlue.y / gfu.uInputSize.y)).b;\n    let a = textureSample(uTexture, uSampler, uv).a;\n    return vec4<f32>(r, g, b, a);\n}\n",entryPoint:"mainFragment"}}),glProgram:i.M2g.from({vertex:o.A,fragment:"precision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform vec4 uInputSize;\nuniform vec2 uRed;\nuniform vec2 uGreen;\nuniform vec2 uBlue;\n\nvoid main(void)\n{\n   float r = texture(uTexture, vTextureCoord + uRed/uInputSize.xy).r;\n   float g = texture(uTexture, vTextureCoord + uGreen/uInputSize.xy).g;\n   float b = texture(uTexture, vTextureCoord + uBlue/uInputSize.xy).b;\n   float a = texture(uTexture, vTextureCoord).a;\n   finalColor = vec4(r, g, b, a);\n}\n",name:"rgb-split-filter"}),resources:{rgbSplitUniforms:{uRed:{value:t.red,type:"vec2<f32>"},uGreen:{value:t.green,type:"vec2<f32>"},uBlue:{value:t.blue,type:"vec2<f32>"}}}}),_(this,"uniforms"),this.uniforms=this.resources.rgbSplitUniforms.uniforms,Object.assign(this,t)}get red(){return this.uniforms.uRed}set red(e){Array.isArray(e)&&(e={x:e[0],y:e[1]}),this.uniforms.uRed=e}get redX(){return this.red.x}set redX(e){this.red.x=e}get redY(){return this.red.y}set redY(e){this.red.y=e}get green(){return this.uniforms.uGreen}set green(e){Array.isArray(e)&&(e={x:e[0],y:e[1]}),this.uniforms.uGreen=e}get greenX(){return this.green.x}set greenX(e){this.green.x=e}get greenY(){return this.green.y}set greenY(e){this.green.y=e}get blue(){return this.uniforms.uBlue}set blue(e){Array.isArray(e)&&(e={x:e[0],y:e[1]}),this.uniforms.uBlue=e}get blueX(){return this.blue.x}set blueX(e){this.blue.x=e}get blueY(){return this.blue.y}set blueY(e){this.blue.y=e}};_(z,"DEFAULT_OPTIONS",{red:{x:-10,y:0},green:{x:0,y:10},blue:{x:0,y:0}});var I=Object.defineProperty,U=(e,n,t)=>(((e,n,t)=>{n in e?I(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t})(e,"symbol"!=typeof n?n+"":n,t),t);const w=class e extends i.dJT{constructor(...n){let t=n[0]??{};(Array.isArray(t)||"x"in t&&"y"in t)&&((0,i.t66)("6.0.0","ShockwaveFilter constructor params are now options object. See params: { center, speed, amplitude, wavelength, brightness, radius, time }"),t={center:t,...n[1]},void 0!==n[2]&&(t.time=n[2])),t={...e.DEFAULT_OPTIONS,...t};super({gpuProgram:i.BrD.from({vertex:{source:u.A,entryPoint:"mainVertex"},fragment:{source:"\nstruct ShockWaveUniforms {\n    uTime: f32,\n    uOffset: vec2<f32>,\n    uSpeed: f32,\n    uWave: vec4<f32>,\n};\n\nstruct GlobalFilterUniforms {\n    uInputSize:vec4<f32>,\n    uInputPixel:vec4<f32>,\n    uInputClamp:vec4<f32>,\n    uOutputFrame:vec4<f32>,\n    uGlobalFrame:vec4<f32>,\n    uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> shockwaveUniforms : ShockWaveUniforms;\n\n@fragment\nfn mainFragment(\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n\n    let uTime = shockwaveUniforms.uTime;\n    let uOffset = shockwaveUniforms.uOffset;\n    let uSpeed = shockwaveUniforms.uSpeed;\n    let uAmplitude = shockwaveUniforms.uWave[0];\n    let uWavelength = shockwaveUniforms.uWave[1];\n    let uBrightness = shockwaveUniforms.uWave[2];\n    let uRadius = shockwaveUniforms.uWave[3];\n    let halfWavelength: f32 = uWavelength * 0.5 / gfu.uInputSize.x;\n    let maxRadius: f32 = uRadius / gfu.uInputSize.x;\n    let currentRadius: f32 = uTime * uSpeed / gfu.uInputSize.x;\n    var fade: f32 = 1.0;\n    var returnColorOnly: bool = false;\n    \n    if (maxRadius > 0.0) {\n        if (currentRadius > maxRadius) {\n            returnColorOnly = true;\n        }\n        fade = 1.0 - pow(currentRadius / maxRadius, 2.0);\n    }\n    var dir: vec2<f32> = vec2<f32>(uv - uOffset / gfu.uInputSize.xy);\n    dir.y *= gfu.uInputSize.y / gfu.uInputSize.x;\n\n    let dist:f32 = length(dir);\n\n    if (dist <= 0.0 || dist < currentRadius - halfWavelength || dist > currentRadius + halfWavelength) {\n        returnColorOnly = true;\n    }\n\n    let diffUV: vec2<f32> = normalize(dir);\n    let diff: f32 = (dist - currentRadius) / halfWavelength;\n    let p: f32 = 1.0 - pow(abs(diff), 2.0);\n    let powDiff: f32 = 1.25 * sin(diff * PI) * p * ( uAmplitude * fade );\n    let offset: vec2<f32> = diffUV * powDiff / gfu.uInputSize.xy;\n    // Do clamp :\n    let coord: vec2<f32> = uv + offset;\n    let clampedCoord: vec2<f32> = clamp(coord, gfu.uInputClamp.xy, gfu.uInputClamp.zw);\n\n    var clampedColor: vec4<f32> = textureSample(uTexture, uSampler, clampedCoord);\n    \n    if (boolVec2(coord, clampedCoord)) \n    {\n        clampedColor *= max(0.0, 1.0 - length(coord - clampedCoord));\n    }\n    // No clamp :\n    var finalColor = clampedColor;\n\n    return select(finalColor, textureSample(uTexture, uSampler, uv), returnColorOnly);\n}\n\nfn boolVec2(x: vec2<f32>, y: vec2<f32>) -> bool\n{\n    if (x.x == y.x && x.y == y.y)\n    {\n        return true;\n    }\n    \n    return false;\n}\n\nconst PI: f32 = 3.14159265358979323846264;\n",entryPoint:"mainFragment"}}),glProgram:i.M2g.from({vertex:o.A,fragment:"\nprecision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform vec2 uCenter;\nuniform float uTime;\nuniform float uSpeed;\nuniform vec4 uWave;\n\nuniform vec4 uInputSize;\nuniform vec4 uInputClamp;\n\nconst float PI = 3.14159;\n\nvoid main()\n{\n    float uAmplitude = uWave[0];\n    float uWavelength = uWave[1];\n    float uBrightness = uWave[2];\n    float uRadius = uWave[3];\n\n    float halfWavelength = uWavelength * 0.5 / uInputSize.x;\n    float maxRadius = uRadius / uInputSize.x;\n    float currentRadius = uTime * uSpeed / uInputSize.x;\n\n    float fade = 1.0;\n\n    if (maxRadius > 0.0) {\n        if (currentRadius > maxRadius) {\n            finalColor = texture(uTexture, vTextureCoord);\n            return;\n        }\n        fade = 1.0 - pow(currentRadius / maxRadius, 2.0);\n    }\n\n    vec2 dir = vec2(vTextureCoord - uCenter / uInputSize.xy);\n    dir.y *= uInputSize.y / uInputSize.x;\n    float dist = length(dir);\n\n    if (dist <= 0.0 || dist < currentRadius - halfWavelength || dist > currentRadius + halfWavelength) {\n        finalColor = texture(uTexture, vTextureCoord);\n        return;\n    }\n\n    vec2 diffUV = normalize(dir);\n\n    float diff = (dist - currentRadius) / halfWavelength;\n\n    float p = 1.0 - pow(abs(diff), 2.0);\n\n    // float powDiff = diff * pow(p, 2.0) * ( amplitude * fade );\n    float powDiff = 1.25 * sin(diff * PI) * p * ( uAmplitude * fade );\n\n    vec2 offset = diffUV * powDiff / uInputSize.xy;\n\n    // Do clamp :\n    vec2 coord = vTextureCoord + offset;\n    vec2 clampedCoord = clamp(coord, uInputClamp.xy, uInputClamp.zw);\n    vec4 color = texture(uTexture, clampedCoord);\n    if (coord != clampedCoord) {\n        color *= max(0.0, 1.0 - length(coord - clampedCoord));\n    }\n\n    // No clamp :\n    // finalColor = texture(uTexture, vTextureCoord + offset);\n\n    color.rgb *= 1.0 + (uBrightness - 1.0) * p * fade;\n\n    finalColor = color;\n}\n",name:"shockwave-filter"}),resources:{shockwaveUniforms:{uTime:{value:t.time,type:"f32"},uCenter:{value:t.center,type:"vec2<f32>"},uSpeed:{value:t.speed,type:"f32"},uWave:{value:new Float32Array(4),type:"vec4<f32>"}}}}),U(this,"uniforms"),U(this,"time"),this.time=0,this.uniforms=this.resources.shockwaveUniforms.uniforms,Object.assign(this,t)}apply(e,n,t,r){this.uniforms.uTime=this.time,e.applyFilter(this,n,t,r)}get center(){return this.uniforms.uCenter}set center(e){Array.isArray(e)&&(e={x:e[0],y:e[1]}),this.uniforms.uCenter=e}get centerX(){return this.uniforms.uCenter.x}set centerX(e){this.uniforms.uCenter.x=e}get centerY(){return this.uniforms.uCenter.y}set centerY(e){this.uniforms.uCenter.y=e}get speed(){return this.uniforms.uSpeed}set speed(e){this.uniforms.uSpeed=e}get amplitude(){return this.uniforms.uWave[0]}set amplitude(e){this.uniforms.uWave[0]=e}get wavelength(){return this.uniforms.uWave[1]}set wavelength(e){this.uniforms.uWave[1]=e}get brightness(){return this.uniforms.uWave[2]}set brightness(e){this.uniforms.uWave[2]=e}get radius(){return this.uniforms.uWave[3]}set radius(e){this.uniforms.uWave[3]=e}};U(w,"DEFAULT_OPTIONS",{center:{x:0,y:0},speed:500,amplitude:30,wavelength:160,brightness:1,radius:-1});var F=Object.defineProperty,R=(e,n,t)=>(((e,n,t)=>{n in e?F(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t})(e,"symbol"!=typeof n?n+"":n,t),t);const D=class e extends i.dJT{constructor(...n){let t=n[0]??{};if(t instanceof i.gPd&&((0,i.t66)("6.0.0","SimpleLightmapFilter constructor params are now options object. See params: { lightMap, color, alpha }"),t={lightMap:t},void 0!==n[1]&&(t.color=n[1]),void 0!==n[2]&&(t.alpha=n[2])),t={...e.DEFAULT_OPTIONS,...t},!t.lightMap)throw Error("No light map texture source was provided to SimpleLightmapFilter");super({gpuProgram:i.BrD.from({vertex:{source:u.A,entryPoint:"mainVertex"},fragment:{source:"struct SimpleLightmapUniforms {\n  uColor: vec3<f32>,\n  uAlpha: f32,\n  uDimensions: vec2<f32>,\n};\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> simpleLightmapUniforms : SimpleLightmapUniforms;\n@group(1) @binding(1) var uMapTexture: texture_2d<f32>;\n@group(1) @binding(2) var uMapSampler: sampler;\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>,\n) -> @location(0) vec4<f32> {\n  let uColor = simpleLightmapUniforms.uColor;\n  let uAlpha = simpleLightmapUniforms.uAlpha;\n  let uDimensions = simpleLightmapUniforms.uDimensions;\n\n  let diffuseColor: vec4<f32> = textureSample(uTexture, uSampler, uv);\n  let lightCoord: vec2<f32> = (uv * gfu.uInputSize.xy) / simpleLightmapUniforms.uDimensions;\n  let light: vec4<f32> = textureSample(uMapTexture, uMapSampler, lightCoord);\n  let ambient: vec3<f32> = uColor * uAlpha;\n  let intensity: vec3<f32> = ambient + light.rgb;\n  let finalColor: vec3<f32> = diffuseColor.rgb * intensity;\n  return vec4<f32>(finalColor, diffuseColor.a);\n}",entryPoint:"mainFragment"}}),glProgram:i.M2g.from({vertex:o.A,fragment:"precision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform sampler2D uMapTexture;\nuniform vec3 uColor;\nuniform float uAlpha;\nuniform vec2 uDimensions;\n\nuniform vec4 uInputSize;\n\nvoid main() {\n    vec4 diffuseColor = texture(uTexture, vTextureCoord);\n    vec2 lightCoord = (vTextureCoord * uInputSize.xy) / uDimensions;\n    vec4 light = texture(uMapTexture, lightCoord);\n    vec3 ambient = uColor.rgb * uAlpha;\n    vec3 intensity = ambient + light.rgb;\n    vec3 color = diffuseColor.rgb * intensity;\n    finalColor = vec4(color, diffuseColor.a);\n}\n",name:"simple-lightmap-filter"}),resources:{simpleLightmapUniforms:{uColor:{value:new Float32Array(3),type:"vec3<f32>"},uAlpha:{value:t.alpha,type:"f32"},uDimensions:{value:new Float32Array(2),type:"vec2<f32>"}},uMapTexture:t.lightMap.source,uMapSampler:t.lightMap.source.style}}),R(this,"uniforms"),R(this,"_color"),R(this,"_lightMap"),this.uniforms=this.resources.simpleLightmapUniforms.uniforms,this._color=new i.Q1f,this.color=t.color??0,Object.assign(this,t)}apply(e,n,t,r){this.uniforms.uDimensions[0]=n.frame.width,this.uniforms.uDimensions[1]=n.frame.height,e.applyFilter(this,n,t,r)}get lightMap(){return this._lightMap}set lightMap(e){this._lightMap=e,this.resources.uMapTexture=e.source,this.resources.uMapSampler=e.source.style}get color(){return this._color.value}set color(e){this._color.setValue(e);const[n,t,r]=this._color.toArray();this.uniforms.uColor[0]=n,this.uniforms.uColor[1]=t,this.uniforms.uColor[2]=r}get alpha(){return this.uniforms.uAlpha}set alpha(e){this.uniforms.uAlpha=e}};R(D,"DEFAULT_OPTIONS",{lightMap:i.gPd.WHITE,color:0,alpha:1});var k=Object.defineProperty,P=(e,n,t)=>(((e,n,t)=>{n in e?k(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t})(e,"symbol"!=typeof n?n+"":n,t),t);const E=class e extends i.dJT{constructor(n){const{width:t,height:r}=i.vrt.defaultOptions;n={...e.DEFAULT_OPTIONS,start:{x:0,y:r/2},end:{x:t,y:r/2},...n};super({gpuProgram:i.BrD.from({vertex:{source:u.A,entryPoint:"mainVertex"},fragment:{source:"struct TiltShiftUniforms {\n  uBlur: vec2<f32>,\n  uStart: vec2<f32>,\n  uEnd: vec2<f32>,\n  uDelta: vec2<f32>,\n  uDimensions: vec2<f32>,\n};\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> tiltShiftUniforms : TiltShiftUniforms;\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  let uBlur = tiltShiftUniforms.uBlur[0];\n  let uBlurGradient = tiltShiftUniforms.uBlur[1];\n  let uStart = tiltShiftUniforms.uStart;\n  let uEnd = tiltShiftUniforms.uEnd;\n  let uDelta = tiltShiftUniforms.uDelta;\n  let uDimensions = tiltShiftUniforms.uDimensions;\n\n  var color: vec4<f32> = vec4<f32>(0.0);\n  var total: f32 = 0.0;\n\n  let offset: f32 = random(position, vec3<f32>(12.9898, 78.233, 151.7182), 0.0);\n  let normal: vec2<f32> = normalize(vec2<f32>(uStart.y - uEnd.y, uEnd.x - uStart.x));\n  let radius: f32 = smoothstep(0.0, 1.0, abs(dot(uv * uDimensions - uStart, normal)) / uBlurGradient) * uBlur;\n\n  for (var t: f32 = -30.0; t <= 30.0; t += 1.0)\n  {\n    var percent: f32 = (t + offset - 0.5) / 30.0;\n    var weight: f32 = 1.0 - abs(percent);\n    var sample: vec4<f32> = textureSample(uTexture, uSampler, uv + uDelta / uDimensions * percent * radius);\n    sample = vec4<f32>(sample.xyz * sample.a, sample.a); // multiply sample.rgb with sample.a\n    color += sample * weight;\n    total += weight;\n  }\n\n  color /= total;\n  color = vec4<f32>(color.xyz / (color.a + 0.00001), color.a); // divide color.rgb by color.a + 0.00001\n\n  return color;\n}\n\n\nfn random(position: vec4<f32>, scale: vec3<f32>, seed: f32) -> f32\n{\n  return fract(sin(dot(position.xyz + seed, scale)) * 43758.5453 + seed);\n}",entryPoint:"mainFragment"}}),glProgram:i.M2g.from({vertex:o.A,fragment:"in vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform vec2 uBlur;\nuniform vec2 uStart;\nuniform vec2 uEnd;\nuniform vec2 uDelta;\nuniform vec2 uDimensions;\n\nfloat random(vec3 scale, float seed)\n{\n    return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\n}\n\nvoid main(void)\n{\n    vec4 color = vec4(0.0);\n    float total = 0.0;\n\n    float blur = uBlur[0];\n    float gradientBlur = uBlur[1];\n\n    float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n    vec2 normal = normalize(vec2(uStart.y - uEnd.y, uEnd.x - uStart.x));\n    float radius = smoothstep(0.0, 1.0, abs(dot(vTextureCoord * uDimensions - uStart, normal)) / gradientBlur) * blur;\n\n    for (float t = -30.0; t <= 30.0; t++)\n    {\n        float percent = (t + offset - 0.5) / 30.0;\n        float weight = 1.0 - abs(percent);\n        vec4 sample = texture(uTexture, vTextureCoord + uDelta / uDimensions * percent * radius);\n        sample.rgb *= sample.a;\n        color += sample * weight;\n        total += weight;\n    }\n\n    color /= total;\n    color.rgb /= color.a + 0.00001;\n\n    finalColor = color;\n}\n",name:"tilt-shift-axis-filter"}),resources:{tiltShiftUniforms:{uBlur:{value:new Float32Array([n.blur,n.gradientBlur]),type:"vec2<f32>"},uStart:{value:n.start,type:"vec2<f32>"},uEnd:{value:n.end,type:"vec2<f32>"},uDelta:{value:new Float32Array([0,0]),type:"vec2<f32>"},uDimensions:{value:new Float32Array([t,r]),type:"vec2<f32>"}}}}),P(this,"uniforms"),P(this,"_tiltAxis"),this.uniforms=this.resources.tiltShiftUniforms.uniforms,this._tiltAxis=n.axis}updateDimensions(e){const{uDimensions:n}=this.uniforms;n[0]=e.frame.width,n[1]=e.frame.height}updateDelta(){if(this.uniforms.uDelta[0]=0,this.uniforms.uDelta[1]=0,void 0===this._tiltAxis)return;const e=this.uniforms.uEnd,n=this.uniforms.uStart,t=e.x-n.x,r=e.y-n.y,i=Math.sqrt(t*t+r*r),o="vertical"===this._tiltAxis;this.uniforms.uDelta[0]=o?-r/i:t/i,this.uniforms.uDelta[1]=o?t/i:r/i}};P(E,"DEFAULT_OPTIONS",{blur:100,gradientBlur:600});Object.defineProperty;var M=Object.defineProperty,B=(e,n,t)=>(((e,n,t)=>{n in e?M(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t})(e,"symbol"!=typeof n?n+"":n,t),t);const L=class e extends i.dJT{constructor(n){n={...e.DEFAULT_OPTIONS,...n};super({gpuProgram:i.BrD.from({vertex:{source:u.A,entryPoint:"mainVertex"},fragment:{source:"struct TwistUniforms {\n  uTwist:vec2<f32>,\n  uOffset:vec2<f32>,\n};\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> twistUniforms : TwistUniforms;\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @builtin(position) position: vec4<f32>\n) -> @location(0) vec4<f32> {\n  return textureSample(uTexture, uSampler, unmapCoord(twist(mapCoord(uv))));\n}\n\nfn mapCoord(coord: vec2<f32> ) -> vec2<f32>\n{\n  var mappedCoord: vec2<f32> = coord;\n  mappedCoord *= gfu.uInputSize.xy;\n  mappedCoord += gfu.uOutputFrame.xy;\n  return mappedCoord;\n}\n\nfn unmapCoord(coord: vec2<f32> ) -> vec2<f32>\n{\n  var mappedCoord: vec2<f32> = coord;\n  mappedCoord -= gfu.uOutputFrame.xy;\n  mappedCoord /= gfu.uInputSize.xy;\n  return mappedCoord;\n}\n\nfn twist(coord: vec2<f32>) -> vec2<f32>\n{\n  var twistedCoord: vec2<f32> = coord;\n  let uRadius = twistUniforms.uTwist[0];\n  let uAngle = twistUniforms.uTwist[1];\n  let uOffset = twistUniforms.uOffset;\n\n  twistedCoord -= uOffset;\n  \n  let dist = length(twistedCoord);\n\n  if (dist < uRadius)\n  {\n    let ratioDist: f32 = (uRadius - dist) / uRadius;\n    let angleMod: f32 = ratioDist * ratioDist * uAngle;\n    let s: f32 = sin(angleMod);\n    let c: f32 = cos(angleMod);\n    twistedCoord = vec2<f32>(twistedCoord.x * c - twistedCoord.y * s, twistedCoord.x * s + twistedCoord.y * c);\n  }\n\n  twistedCoord += uOffset;\n  return twistedCoord;\n}\n",entryPoint:"mainFragment"}}),glProgram:i.M2g.from({vertex:o.A,fragment:"precision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform vec2 uTwist;\nuniform vec2 uOffset;\nuniform vec4 uInputSize;\n\nvec2 mapCoord( vec2 coord )\n{\n    coord *= uInputSize.xy;\n    coord += uInputSize.zw;\n\n    return coord;\n}\n\nvec2 unmapCoord( vec2 coord )\n{\n    coord -= uInputSize.zw;\n    coord /= uInputSize.xy;\n\n    return coord;\n}\n\nvec2 twist(vec2 coord)\n{\n    coord -= uOffset;\n\n    float dist = length(coord);\n    float uRadius = uTwist[0];\n    float uAngle = uTwist[1];\n\n    if (dist < uRadius)\n    {\n        float ratioDist = (uRadius - dist) / uRadius;\n        float angleMod = ratioDist * ratioDist * uAngle;\n        float s = sin(angleMod);\n        float c = cos(angleMod);\n        coord = vec2(coord.x * c - coord.y * s, coord.x * s + coord.y * c);\n    }\n\n    coord += uOffset;\n\n    return coord;\n}\n\nvoid main(void)\n{\n    vec2 coord = mapCoord(vTextureCoord);\n    coord = twist(coord);\n    coord = unmapCoord(coord);\n    finalColor = texture(uTexture, coord);\n}\n",name:"twist-filter"}),resources:{twistUniforms:{uTwist:{value:[n.radius??0,n.angle??0],type:"vec2<f32>"},uOffset:{value:n.offset,type:"vec2<f32>"}}},...n}),B(this,"uniforms"),this.uniforms=this.resources.twistUniforms.uniforms}get radius(){return this.uniforms.uTwist[0]}set radius(e){this.uniforms.uTwist[0]=e}get angle(){return this.uniforms.uTwist[1]}set angle(e){this.uniforms.uTwist[1]=e}get offset(){return this.uniforms.uOffset}set offset(e){this.uniforms.uOffset=e}get offsetX(){return this.offset.x}set offsetX(e){this.offset.x=e}get offsetY(){return this.offset.y}set offsetY(e){this.offset.y=e}};B(L,"DEFAULT_OPTIONS",{padding:20,radius:200,angle:4,offset:{x:0,y:0}});var N=Object.defineProperty,K=(e,n,t)=>(((e,n,t)=>{n in e?N(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t})(e,"symbol"!=typeof n?n+"":n,t),t);const G=class e extends i.dJT{constructor(n){const t=(n={...e.DEFAULT_OPTIONS,...n}).maxKernelSize??32;super({gpuProgram:i.BrD.from({vertex:{source:u.A,entryPoint:"mainVertex"},fragment:{source:"struct ZoomBlurUniforms {\n    uStrength:f32,\n    uCenter:vec2<f32>,\n    uRadii:vec2<f32>,\n};\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> zoomBlurUniforms : ZoomBlurUniforms;\n\n@fragment\nfn mainFragment(\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  let uStrength = zoomBlurUniforms.uStrength;\n  let uCenter = zoomBlurUniforms.uCenter;\n  let uRadii = zoomBlurUniforms.uRadii;\n\n  let minGradient: f32 = uRadii[0] * 0.3;\n  let innerRadius: f32 = (uRadii[0] + minGradient * 0.5) / gfu.uInputSize.x;\n\n  let gradient: f32 = uRadii[1] * 0.3;\n  let radius: f32 = (uRadii[1] - gradient * 0.5) / gfu.uInputSize.x;\n\n  let MAX_KERNEL_SIZE: f32 = ${MAX_KERNEL_SIZE};\n\n  var countLimit: f32 = MAX_KERNEL_SIZE;\n\n  var dir: vec2<f32> = vec2<f32>(uCenter / gfu.uInputSize.xy - uv);\n  let dist: f32 = length(vec2<f32>(dir.x, dir.y * gfu.uInputSize.y / gfu.uInputSize.x));\n\n  var strength: f32 = uStrength;\n\n  var delta: f32 = 0.0;\n  var gap: f32;\n\n  if (dist < innerRadius) {\n      delta = innerRadius - dist;\n      gap = minGradient;\n  } else if (radius >= 0.0 && dist > radius) { // radius < 0 means it's infinity\n      delta = dist - radius;\n      gap = gradient;\n  }\n\n  var returnColorOnly: bool = false;\n\n  if (delta > 0.0) {\n    let normalCount: f32 = gap / gfu.uInputSize.x;\n    delta = (normalCount - delta) / normalCount;\n    countLimit *= delta;\n    strength *= delta;\n    \n    if (countLimit < 1.0)\n    {\n      returnColorOnly = true;;\n    }\n  }\n\n  // randomize the lookup values to hide the fixed number of samples\n  let offset: f32 = rand(uv, 0.0);\n\n  var total: f32 = 0.0;\n  var color: vec4<f32> = vec4<f32>(0.);\n\n  dir *= strength;\n\n  for (var t = 0.0; t < MAX_KERNEL_SIZE; t += 1.0) {\n    let percent: f32 = (t + offset) / MAX_KERNEL_SIZE;\n    let weight: f32 = 4.0 * (percent - percent * percent);\n    let p: vec2<f32> = uv + dir * percent;\n    let sample: vec4<f32> = textureSample(uTexture, uSampler, p);\n    \n    if (t < countLimit)\n    {\n      color += sample * weight;\n      total += weight;\n    }\n  }\n\n  color /= total;\n\n  return select(color, textureSample(uTexture, uSampler, uv), returnColorOnly);\n}\n\nfn modulo(x: f32, y: f32) -> f32\n{\n  return x - y * floor(x/y);\n}\n\n// author: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\nfn rand(co: vec2<f32>, seed: f32) -> f32\n{\n  let a: f32 = 12.9898;\n  let b: f32 = 78.233;\n  let c: f32 = 43758.5453;\n  let dt: f32 = dot(co + seed, vec2<f32>(a, b));\n  let sn: f32 = modulo(dt, 3.14159);\n  return fract(sin(sn) * c + seed);\n}".replace("${MAX_KERNEL_SIZE}",t.toFixed(1)),entryPoint:"mainFragment"}}),glProgram:i.M2g.from({vertex:o.A,fragment:"precision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform float uStrength;\nuniform vec2 uCenter;\nuniform vec2 uRadii;\n\nuniform vec4 uInputSize;\n\nconst float MAX_KERNEL_SIZE = ${MAX_KERNEL_SIZE};\n\n// author: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\nhighp float rand(vec2 co, float seed) {\n    const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n    highp float dt = dot(co + seed, vec2(a, b)), sn = mod(dt, 3.14159);\n    return fract(sin(sn) * c + seed);\n}\n\nvoid main() {\n    float minGradient = uRadii[0] * 0.3;\n    float innerRadius = (uRadii[0] + minGradient * 0.5) / uInputSize.x;\n\n    float gradient = uRadii[1] * 0.3;\n    float radius = (uRadii[1] - gradient * 0.5) / uInputSize.x;\n\n    float countLimit = MAX_KERNEL_SIZE;\n\n    vec2 dir = vec2(uCenter.xy / uInputSize.xy - vTextureCoord);\n    float dist = length(vec2(dir.x, dir.y * uInputSize.y / uInputSize.x));\n\n    float strength = uStrength;\n\n    float delta = 0.0;\n    float gap;\n    if (dist < innerRadius) {\n        delta = innerRadius - dist;\n        gap = minGradient;\n    } else if (radius >= 0.0 && dist > radius) { // radius < 0 means it's infinity\n        delta = dist - radius;\n        gap = gradient;\n    }\n\n    if (delta > 0.0) {\n        float normalCount = gap / uInputSize.x;\n        delta = (normalCount - delta) / normalCount;\n        countLimit *= delta;\n        strength *= delta;\n        if (countLimit < 1.0)\n        {\n            gl_FragColor = texture(uTexture, vTextureCoord);\n            return;\n        }\n    }\n\n    // randomize the lookup values to hide the fixed number of samples\n    float offset = rand(vTextureCoord, 0.0);\n\n    float total = 0.0;\n    vec4 color = vec4(0.0);\n\n    dir *= strength;\n\n    for (float t = 0.0; t < MAX_KERNEL_SIZE; t++) {\n        float percent = (t + offset) / MAX_KERNEL_SIZE;\n        float weight = 4.0 * (percent - percent * percent);\n        vec2 p = vTextureCoord + dir * percent;\n        vec4 sample = texture(uTexture, p);\n\n        // switch to pre-multiplied alpha to correctly blur transparent images\n        // sample.rgb *= sample.a;\n\n        color += sample * weight;\n        total += weight;\n\n        if (t > countLimit){\n            break;\n        }\n    }\n\n    color /= total;\n    // switch back from pre-multiplied alpha\n    // color.rgb /= color.a + 0.00001;\n\n    gl_FragColor = color;\n}\n".replace("${MAX_KERNEL_SIZE}",t.toFixed(1)),name:"zoom-blur-filter"}),resources:{zoomBlurUniforms:{uStrength:{value:n.strength,type:"f32"},uCenter:{value:n.center,type:"vec2<f32>"},uRadii:{value:new Float32Array(2),type:"vec2<f32>"}}}}),K(this,"uniforms"),this.uniforms=this.resources.zoomBlurUniforms.uniforms,Object.assign(this,n)}get strength(){return this.uniforms.uStrength}set strength(e){this.uniforms.uStrength=e}get center(){return this.uniforms.uCenter}set center(e){Array.isArray(e)&&(e={x:e[0],y:e[1]}),this.uniforms.uCenter=e}get centerX(){return this.uniforms.uCenter.x}set centerX(e){this.uniforms.uCenter.x=e}get centerY(){return this.uniforms.uCenter.y}set centerY(e){this.uniforms.uCenter.y=e}get innerRadius(){return this.uniforms.uRadii[0]}set innerRadius(e){this.uniforms.uRadii[0]=e}get radius(){return this.uniforms.uRadii[1]}set radius(e){this.uniforms.uRadii[1]=e<0||e===1/0?-1:e}};K(G,"DEFAULT_OPTIONS",{strength:.1,center:{x:0,y:0},innerRadius:0,radius:-1,maxKernelSize:32})},386:(e,n,t)=>{t.d(n,{Q:()=>s});var r=t(3423),i=t(4742),o=t(9096),u=Object.defineProperty,l=(e,n,t)=>(((e,n,t)=>{n in e?u(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t})(e,"symbol"!=typeof n?n+"":n,t),t);const a=class e extends r.dJT{constructor(...n){let t=n[0]??{};("number"==typeof t||Array.isArray(t))&&((0,r.t66)("6.0.0","KawaseBlurFilter constructor params are now options object. See params: { strength, quality, clamp, pixelSize }"),t={strength:t},void 0!==n[1]&&(t.quality=n[1]),void 0!==n[2]&&(t.clamp=n[2])),t={...e.DEFAULT_OPTIONS,...t};super({gpuProgram:r.BrD.from({vertex:{source:o.A,entryPoint:"mainVertex"},fragment:{source:t?.clamp?"struct KawaseBlurUniforms {\n  uOffset:vec2<f32>,\n};\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> kawaseBlurUniforms : KawaseBlurUniforms;\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  let uOffset = kawaseBlurUniforms.uOffset;\n  var color: vec4<f32> = vec4(0.0);\n\n  // Sample top left pixel\n  color += textureSample(uTexture, uSampler, clamp(vec2<f32>(uv.x - uOffset.x, uv.y + uOffset.y), gfu.uInputClamp.xy, gfu.uInputClamp.zw));\n  // Sample top right pixel\n  color += textureSample(uTexture, uSampler, clamp(vec2<f32>(uv.x + uOffset.x, uv.y + uOffset.y), gfu.uInputClamp.xy, gfu.uInputClamp.zw));\n  // Sample bottom right pixel\n  color += textureSample(uTexture, uSampler, clamp(vec2<f32>(uv.x + uOffset.x, uv.y - uOffset.y), gfu.uInputClamp.xy, gfu.uInputClamp.zw));\n  // Sample bottom left pixel\n  color += textureSample(uTexture, uSampler, clamp(vec2<f32>(uv.x - uOffset.x, uv.y - uOffset.y), gfu.uInputClamp.xy, gfu.uInputClamp.zw));\n  // Average\n  color *= 0.25;\n    \n  return color;\n}":"struct KawaseBlurUniforms {\n  uOffset:vec2<f32>,\n};\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> kawaseBlurUniforms : KawaseBlurUniforms;\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  let uOffset = kawaseBlurUniforms.uOffset;\n  var color: vec4<f32> = vec4<f32>(0.0);\n\n  // Sample top left pixel\n  color += textureSample(uTexture, uSampler, vec2<f32>(uv.x - uOffset.x, uv.y + uOffset.y));\n  // Sample top right pixel\n  color += textureSample(uTexture, uSampler, vec2<f32>(uv.x + uOffset.x, uv.y + uOffset.y));\n  // Sample bottom right pixel\n  color += textureSample(uTexture, uSampler, vec2<f32>(uv.x + uOffset.x, uv.y - uOffset.y));\n  // Sample bottom left pixel\n  color += textureSample(uTexture, uSampler, vec2<f32>(uv.x - uOffset.x, uv.y - uOffset.y));\n  // Average\n  color *= 0.25;\n\n  return color;\n}",entryPoint:"mainFragment"}}),glProgram:r.M2g.from({vertex:i.A,fragment:t?.clamp?"\nprecision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform vec2 uOffset;\n\nuniform vec4 uInputClamp;\n\nvoid main(void)\n{\n    vec4 color = vec4(0.0);\n\n    // Sample top left pixel\n    color += texture(uTexture, clamp(vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y + uOffset.y), uInputClamp.xy, uInputClamp.zw));\n\n    // Sample top right pixel\n    color += texture(uTexture, clamp(vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y + uOffset.y), uInputClamp.xy, uInputClamp.zw));\n\n    // Sample bottom right pixel\n    color += texture(uTexture, clamp(vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y - uOffset.y), uInputClamp.xy, uInputClamp.zw));\n\n    // Sample bottom left pixel\n    color += texture(uTexture, clamp(vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y - uOffset.y), uInputClamp.xy, uInputClamp.zw));\n\n    // Average\n    color *= 0.25;\n\n    finalColor = color;\n}\n":"\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform vec2 uOffset;\n\nvoid main(void)\n{\n    vec4 color = vec4(0.0);\n\n    // Sample top left pixel\n    color += texture(uTexture, vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y + uOffset.y));\n\n    // Sample top right pixel\n    color += texture(uTexture, vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y + uOffset.y));\n\n    // Sample bottom right pixel\n    color += texture(uTexture, vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y - uOffset.y));\n\n    // Sample bottom left pixel\n    color += texture(uTexture, vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y - uOffset.y));\n\n    // Average\n    color *= 0.25;\n\n    finalColor = color;\n}",name:"kawase-blur-filter"}),resources:{kawaseBlurUniforms:{uOffset:{value:new Float32Array(2),type:"vec2<f32>"}}}}),l(this,"uniforms"),l(this,"_pixelSize",{x:0,y:0}),l(this,"_clamp"),l(this,"_kernels",[]),l(this,"_blur"),l(this,"_quality"),this.uniforms=this.resources.kawaseBlurUniforms.uniforms,this.pixelSize=t.pixelSize??{x:1,y:1},Array.isArray(t.strength)?this.kernels=t.strength:"number"==typeof t.strength&&(this._blur=t.strength,this.quality=t.quality??3),this._clamp=!!t.clamp}apply(e,n,t,i){const o=this.pixelSizeX/n.source.width,u=this.pixelSizeY/n.source.height;let l;if(1===this._quality||0===this._blur)l=this._kernels[0]+.5,this.uniforms.uOffset[0]=l*o,this.uniforms.uOffset[1]=l*u,e.applyFilter(this,n,t,i);else{const a=r.Wny.getSameSizeTexture(n);let s,f=n,c=a;const m=this._quality-1;for(let n=0;n<m;n++)l=this._kernels[n]+.5,this.uniforms.uOffset[0]=l*o,this.uniforms.uOffset[1]=l*u,e.applyFilter(this,f,c,!0),s=f,f=c,c=s;l=this._kernels[m]+.5,this.uniforms.uOffset[0]=l*o,this.uniforms.uOffset[1]=l*u,e.applyFilter(this,f,t,i),r.Wny.returnTexture(a)}}get strength(){return this._blur}set strength(e){this._blur=e,this._generateKernels()}get quality(){return this._quality}set quality(e){this._quality=Math.max(1,Math.round(e)),this._generateKernels()}get kernels(){return this._kernels}set kernels(e){Array.isArray(e)&&e.length>0?(this._kernels=e,this._quality=e.length,this._blur=Math.max(...e)):(this._kernels=[0],this._quality=1)}get pixelSize(){return this._pixelSize}set pixelSize(e){if("number"!=typeof e)return Array.isArray(e)?(this.pixelSizeX=e[0],void(this.pixelSizeY=e[1])):void(this._pixelSize=e);this.pixelSizeX=this.pixelSizeY=e}get pixelSizeX(){return this.pixelSize.x}set pixelSizeX(e){this.pixelSize.x=e}get pixelSizeY(){return this.pixelSize.y}set pixelSizeY(e){this.pixelSize.y=e}get clamp(){return this._clamp}_updatePadding(){this.padding=Math.ceil(this._kernels.reduce(((e,n)=>e+n+.5),0))}_generateKernels(){const e=this._blur,n=this._quality,t=[e];if(e>0){let r=e;const i=e/n;for(let e=1;e<n;e++)r-=i,t.push(r)}this._kernels=t,this._updatePadding()}};l(a,"DEFAULT_OPTIONS",{strength:4,quality:3,clamp:!1,pixelSize:{x:1,y:1}});let s=a}}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9yLi5wbnBtLTE1OTJjODZkLjI5MzJkMGQ5MjY0Y2U0NmRhMzFiLmpzIiwibWFwcGluZ3MiOiI2VkFNSUEsRUFBWUMsT0FBT0MsZUFFbkJDLEVBQWdCLENBQUNDLEVBQUtDLEVBQUtDLEtBRFQsRUFBQ0YsRUFBS0MsRUFBS0MsS0FBVUQsS0FBT0QsRUFBTUosRUFBVUksRUFBS0MsRUFBSyxDQUFFRSxZQUFZLEVBQU1DLGNBQWMsRUFBTUMsVUFBVSxFQUFNSCxVQUFXRixFQUFJQyxHQUFPQyxDQUFLLEVBRTdKSSxDQUFnQk4sRUFBb0IsaUJBQVJDLEVBQW1CQSxFQUFNLEdBQUtBLEVBQUtDLEdBQ3hEQSxHQUVULE1BQU1LLEVBQW9CLE1BQU1BLFVBQTBCLE1BRXhELFdBQUFDLElBQWVDLEdBQ2IsSUFBSUMsRUFBVUQsRUFBSyxJQUFNLENBQUMsRUFDMUIsR0FBSUUsTUFBTUMsUUFBUUYsSUFBWSxNQUFPQSxHQUFXLE1BQU9BLEdBQVdBLGFBQW1CLE1BQWlCLEVBQ3BHLFNBQVksUUFBUyw0R0FHckJBLEVBQVUsQ0FBRUcsU0FBVSxDQUFFQyxFQUZkLE1BQU9KLEVBQVVBLEVBQVFJLEVBQUlKLEVBQVEsR0FFcEJLLEVBRGpCLE1BQU9MLEVBQVVBLEVBQVFLLEVBQUlMLEVBQVEsVUFFL0IsSUFBWkQsRUFBSyxLQUNQQyxFQUFRTSxXQUFhUCxFQUFLLFNBQ1osSUFBWkEsRUFBSyxLQUNQQyxFQUFRTyxPQUFTUixFQUFLLEdBQzFCLENBQ0FDLEVBQVUsSUFBS0gsRUFBa0JXLG1CQUFvQlIsR0FnQnJEUyxNQUFNLENBQ0pDLFdBaEJpQixNQUFXQyxLQUFLLENBQ2pDQyxPQUFRLENBQ05DLE9BQVEsSUFDUkMsV0FBWSxjQUVkQyxTQUFVLENBQ1JGLE9DakNLLCsyQ0RrQ0xDLFdBQVksa0JBVWRFLFVBUGdCLE1BQVVMLEtBQUssQ0FDL0JDLE9BQU0sSUFDTkcsU0V2Q1MsbWdDRndDVEUsS0FBTSx1QkFLTkMsVUFBVyxDQUNUQyxtQkFBb0IsQ0FDbEJDLFVBQVcsQ0FB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TyxDQUFDQyxFQUFLQyxJQUFNRCxFQUFNQyxFQUFJLElBQUssR0FDM0UsQ0FFQSxnQkFBQVAsR0FDRSxNQUFNN0MsRUFBT3ZKLEtBQUtzTCxNQUNabEgsRUFBVXBFLEtBQUtvRixTQUNmaUcsRUFBVSxDQUFDOUIsR0FDakIsR0FBSUEsRUFBTyxFQUFHLENBQ1osSUFBSXFELEVBQUlyRCxFQUNSLE1BQU1zRCxFQUFPdEQsRUFBT25GLEVBQ3BCLElBQUssSUFBSXBDLEVBQUksRUFBR0EsRUFBSW9DLEVBQVNwQyxJQUMzQjRLLEdBQUtDLEVBQ0x4QixFQUFReUIsS0FBS0YsRUFFakIsQ0FDQTVNLEtBQUs0TCxTQUFXUCxFQUNoQnJMLEtBQUt1TSxnQkFDUCxHQUdGNU8sRUFBY3NOLEVBQW1CLGtCQUFtQixDQUNsREgsU0FBVSxFQUNWMUcsUUFBUyxFQUNUOEcsT0FBTyxFQUNQRSxVQUFXLENBQUUxTSxFQUFHLEVBQUdDLEVBQUcsS0FFeEIsSUFBSW9PLEVBQW1COUIsQyIsInNvdXJjZXMiOlsid2VicGFjazovL3BpeGlqcy1nYW1lLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3BpeGktZmlsdGVyc0A2LjAuNV9waXhpLmpzQDguNi40L25vZGVfbW9kdWxlcy9waXhpLWZpbHRlcnMvbGliL21vdGlvbi1ibHVyL01vdGlvbkJsdXJGaWx0ZXIubWpzIiwid2VicGFjazovL3BpeGlqcy1nYW1lLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3BpeGktZmlsdGVyc0A2LjAuNV9waXhpLmpzQDguNi40L25vZGVfbW9kdWxlcy9waXhpLWZpbHRlcnMvbGliL21vdGlvbi1ibHVyL21vdGlvbi1ibHVyLm1qcyIsIndlYnBhY2s6Ly9waXhpanMtZ2FtZS8uL25vZGVfbW9kdWxlcy8ucG5wbS9waXhpLWZpbHRlcnNANi4wLjVfcGl4aS5qc0A4LjYuNC9ub2RlX21vZHVsZXMvcGl4aS1maWx0ZXJzL2xpYi9tb3Rpb24tYmx1ci9tb3Rpb24tYmx1cjIubWpzIiwid2VicGFjazovL3BpeGlqcy1nYW1lLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3BpeGktZmlsdGVyc0A2LjAuNV9waXhpLmpzQDguNi40L25vZGVfbW9kdWxlcy9waXhpLWZpbHRlcnMvbGliL211bHRpLWNvbG9yLXJlcGxhY2UvbXVsdGktY29sb3ItcmVwbGFjZTIubWpzIiwid2VicGFjazovL3BpeGlqcy1nYW1lLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3BpeGktZmlsdGVyc0A2LjAuNV9waXhpLmpzQDguNi40L25vZGVfbW9kdWxlcy9waXhpLWZpbHRlcnMvbGliL211bHRpLWNvbG9yLXJlcGxhY2UvTXVsdGlDb2xvclJlcGxhY2VGaWx0ZXIubWpzIiwid2VicGFjazovL3BpeGlqcy1nYW1lLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3BpeGktZmlsdGVyc0A2LjAuNV9waXhpLmpzQDguNi40L25vZGVfbW9kdWxlcy9waXhpLWZpbHRlcnMvbGliL211bHRpLWNvbG9yLXJlcGxhY2UvbXVsdGktY29sb3ItcmVwbGFjZS5tanMiLCJ3ZWJwYWNrOi8vcGl4aWpzLWdhbWUvLi9ub2RlX21vZHVsZXMvLnBucG0vcGl4aS1maWx0ZXJzQDYuMC41X3BpeGkuanNAOC42LjQvbm9kZV9tb2R1bGVzL3BpeGktZmlsdGVycy9saWIvb2xkLWZpbG0vb2xkLWZpbG0yLm1qcyIsIndlYnBhY2s6Ly9waXhpanMtZ2FtZS8uL25vZGVfbW9kdWxlcy8ucG5wbS9waXhpLWZpbHRlcnNANi4wLjVfcGl4aS5qc0A4LjYuNC9ub2RlX21vZHVsZXMvcGl4aS1maWx0ZXJzL2xpYi9vbGQtZmlsbS9PbGRGaWxtRmlsdGVyLm1qcyIsIndlYnBhY2s6Ly9waXhpanMtZ2FtZS8uL25vZGVfbW9kdWxlcy8ucG5wbS9waXhpLWZpbHRlcnNANi4wLjVfcGl4aS5qc0A4LjYuNC9ub2RlX21vZHVsZXMvcGl4aS1maWx0ZXJzL2xpYi9vbGQtZmlsbS9vbGQtZmlsbS5tanMiLCJ3ZWJwYWNrOi8vcGl4aWpzLWdhbWUvLi9ub2RlX21vZHVsZXMvLnBucG0vcGl4aS1maWx0ZXJzQDYuMC41X3BpeGkuanNAOC42LjQvbm9kZV9tb2R1bGVzL3BpeGktZmlsdGVycy9saWIvb3V0bGluZS9vdXRsaW5lLm1qcyIsIndlYnBhY2s6Ly9waXhpanMtZ2FtZS8uL25vZGVfbW9kdWxlcy8ucG5wbS9waXhpLWZpbHRlcnNANi4wLjVfcGl4aS5qc0A4LjYuNC9ub2RlX21vZHVsZXMvcGl4aS1maWx0ZXJzL2xpYi9vdXRsaW5lL091dGxpbmVGaWx0ZXIubWpzIiwid2VicGFjazovL3BpeGlqcy1nYW1lLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3BpeGktZmlsdGVyc0A2LjAuNV9waXhpLmpzQDguNi40L25vZGVfbW9kdWxlcy9waXhpLWZpbHRlcnMvbGliL291dGxpbmUvb3V0bGluZTIubWpzIiwid2VicGFjazovL3BpeGlqcy1nYW1lLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3BpeGktZmlsdGVyc0A2LjAuNV9waXhpLmpzQDguNi40L25vZGVfbW9kdWxlcy9waXhpLWZpbHRlcnMvbGliL3BpeGVsYXRlL1BpeGVsYXRlRmlsdGVyLm1qcyIsIndlYnBhY2s6Ly9waXhpanMtZ2FtZS8uL25vZGVfbW9kdWxlcy8ucG5wbS9waXhpLWZpbHRlcnNANi4wLjVfcGl4aS5qc0A4LjYuNC9ub2RlX21vZHVsZXMvcGl4aS1maWx0ZXJzL2xpYi9yYWRpYWwtYmx1ci9yYWRpYWwtYmx1ci5tanMiLCJ3ZWJwYWNrOi8vcGl4aWpzLWdhbWUvLi9ub2RlX21vZHVsZXMvLnBucG0vcGl4aS1maWx0ZXJzQDYuMC41X3BpeGkuanNAOC42LjQvbm9kZV9tb2R1bGVzL3BpeGktZmlsdGVycy9saWIvcmFkaWFsLWJsdXIvUmFkaWFsQmx1ckZpbHRlci5tanMiLCJ3ZWJwYWNrOi8vcGl4aWpzLWdhbWUvLi9ub2RlX21vZHVsZXMvLnBucG0vcGl4aS1maWx0ZXJzQDYuMC41X3BpeGkuanNAOC42LjQvbm9kZV9tb2R1bGVzL3BpeGktZmlsdGVycy9saWIvcmFkaWFsLWJsdXIvcmFkaWFsLWJsdXIyLm1qcyIsIndlYnBhY2s6Ly9waXhpanMtZ2FtZS8uL25vZGVfbW9kdWxlcy8ucG5wbS9waXhpLWZpbHRlcnNANi4wLjVfcGl4aS5qc0A4LjYuNC9ub2RlX21vZHVsZXMvcGl4aS1maWx0ZXJzL2xpYi9yZWZsZWN0aW9uL3JlZmxlY3Rpb24ubWpzIiwid2VicGFjazovL3BpeGlqcy1nYW1lLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3BpeGktZmlsdGVyc0A2LjAuNV9waXhpLmpzQDguNi40L25vZGVfbW9kdWxlcy9waXhpLWZpbHRlcnMvbGliL3JlZmxlY3Rpb24vUmVmbGVjdGlvbkZpbHRlci5tanMiLCJ3ZWJwYWNrOi8vcGl4aWpzLWdhbWUvLi9ub2RlX21vZHVsZXMvLnBucG0vcGl4aS1maWx0ZXJzQDYuMC41X3BpeGkuanNAOC42LjQvbm9kZV9tb2R1bGVzL3BpeGktZmlsdGVycy9saWIvcmVmbGVjdGlvbi9yZWZsZWN0aW9uMi5tanMiLCJ3ZWJwYWNrOi8vcGl4aWpzLWdhbWUvLi9ub2RlX21vZHVsZXMvLnBucG0vcGl4aS1maWx0ZXJzQDYuMC41X3BpeGkuanNAOC42LjQvbm9kZV9tb2R1bGVzL3BpeGktZmlsdGVycy9saWIvcmdiLXNwbGl0L3JnYi1zcGxpdC5tanMiLCJ3ZWJwYWNrOi8vcGl4aWpzLWdhbWUvLi9ub2RlX21vZHVsZXMvLnBucG0vcGl4aS1maWx0ZXJzQDYuMC41X3BpeGkuanNAOC42LjQvbm9kZV9tb2R1bGVzL3BpeGktZmlsdGVycy9saWIvcmdiLXNwbGl0L1JHQlNwbGl0RmlsdGVyLm1qcyIsIndlYnBhY2s6Ly9waXhpanMtZ2FtZS8uL25vZGVfbW9kdWxlcy8ucG5wbS9waXhpLWZpbHRlcnNANi4wLjVfcGl4aS5qc0A4LjYuNC9ub2RlX21vZHVsZXMvcGl4aS1maWx0ZXJzL2xpYi9yZ2Itc3BsaXQvcmdiLXNwbGl0Mi5tanMiLCJ3ZWJwYWNrOi8vcGl4aWpzLWdhbWUvLi9ub2RlX21vZHVsZXMvLnBucG0vcGl4aS1maWx0ZXJzQDYuMC41X3BpeGkuanNAOC42LjQvbm9kZV9tb2R1bGVzL3BpeGktZmlsdGVycy9saWIvc2hvY2t3YXZlL3Nob2Nrd2F2ZTIubWpzIiwid2VicGFjazovL3BpeGlqcy1nYW1lLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3BpeGktZmlsdGVyc0A2LjAuNV9waXhpLmpzQDguNi40L25vZGVfbW9kdWxlcy9waXhpLWZpbHRlcnMvbGliL3Nob2Nrd2F2ZS9TaG9ja3dhdmVGaWx0ZXIubWpzIiwid2VicGFjazovL3BpeGlqcy1nYW1lLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3BpeGktZmlsdGVyc0A2LjAuNV9waXhpLmpzQDguNi40L25vZGVfbW9kdWxlcy9waXhpLWZpbHRlcnMvbGliL3Nob2Nrd2F2ZS9zaG9ja3dhdmUubWpzIiwid2VicGFjazovL3BpeGlqcy1nYW1lLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3BpeGktZmlsdGVyc0A2LjAuNV9waXhpLmpzQDguNi40L25vZGVfbW9kdWxlcy9waXhpLWZpbHRlcnMvbGliL3NpbXBsZS1saWdodG1hcC9zaW1wbGUtbGlnaHRtYXAubWpzIiwid2VicGFjazovL3BpeGlqcy1nYW1lLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3BpeGktZmlsdGVyc0A2LjAuNV9waXhpLmpzQDguNi40L25vZGVfbW9kdWxlcy9waXhpLWZpbHRlcnMvbGliL3NpbXBsZS1saWdodG1hcC9TaW1wbGVMaWdodG1hcEZpbHRlci5tanMiLCJ3ZWJwYWNrOi8vcGl4aWpzLWdhbWUvLi9ub2RlX21vZHVsZXMvLnBucG0vcGl4aS1maWx0ZXJzQDYuMC41X3BpeGkuanNAOC42LjQvbm9kZV9tb2R1bGVzL3BpeGktZmlsdGVycy9saWIvc2ltcGxlLWxpZ2h0bWFwL3NpbXBsZS1saWdodG1hcDIubWpzIiwid2VicGFjazovL3BpeGlqcy1nYW1lLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3BpeGktZmlsdGVyc0A2LjAuNV9waXhpLmpzQDguNi40L25vZGVfbW9kdWxlcy9waXhpLWZpbHRlcnMvbGliL3RpbHQtc2hpZnQvdGlsdC1zaGlmdDIubWpzIiwid2VicGFjazovL3BpeGlqcy1nYW1lLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3BpeGktZmlsdGVyc0A2LjAuNV9waXhpLmpzQDguNi40L25vZGVfbW9kdWxlcy9waXhpLWZpbHRlcnMvbGliL3RpbHQtc2hpZnQvVGlsdFNoaWZ0QXhpc0ZpbHRlci5tanMiLCJ3ZWJwYWNrOi8vcGl4aWpzLWdhbWUvLi9ub2RlX21vZHVsZXMvLnBucG0vcGl4aS1maWx0ZXJzQDYuMC41X3BpeGkuanNAOC42LjQvbm9kZV9tb2R1bGVzL3BpeGktZmlsdGVycy9saWIvdGlsdC1zaGlmdC90aWx0LXNoaWZ0Lm1qcyIsIndlYnBhY2s6Ly9waXhpanMtZ2FtZS8uL25vZGVfbW9kdWxlcy8ucG5wbS9waXhpLWZpbHRlcnNANi4wLjVfcGl4aS5qc0A4LjYuNC9ub2RlX21vZHVsZXMvcGl4aS1maWx0ZXJzL2xpYi90aWx0LXNoaWZ0L1RpbHRTaGlmdEZpbHRlci5tanMiLCJ3ZWJwYWNrOi8vcGl4aWpzLWdhbWUvLi9ub2RlX21vZHVsZXMvLnBucG0vcGl4aS1maWx0ZXJzQDYuMC41X3BpeGkuanNAOC42LjQvbm9kZV9tb2R1bGVzL3BpeGktZmlsdGVycy9saWIvdHdpc3QvdHdpc3QubWpzIiwid2VicGFjazovL3BpeGlqcy1nYW1lLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3BpeGktZmlsdGVyc0A2LjAuNV9waXhpLmpzQDguNi40L25vZGVfbW9kdWxlcy9waXhpLWZpbHRlcnMvbGliL3R3aXN0L1R3aXN0RmlsdGVyLm1qcyIsIndlYnBhY2s6Ly9waXhpanMtZ2FtZS8uL25vZGVfbW9kdWxlcy8ucG5wbS9waXhpLWZpbHRlcnNANi4wLjVfcGl4aS5qc0A4LjYuNC9ub2RlX21vZHVsZXMvcGl4aS1maWx0ZXJzL2xpYi90d2lzdC90d2lzdDIubWpzIiwid2VicGFjazovL3BpeGlqcy1nYW1lLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3BpeGktZmlsdGVyc0A2LjAuNV9waXhpLmpzQDguNi40L25vZGVfbW9kdWxlcy9waXhpLWZpbHRlcnMvbGliL3pvb20tYmx1ci96b29tLWJsdXIubWpzIiwid2VicGFjazovL3BpeGlqcy1nYW1lLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3BpeGktZmlsdGVyc0A2LjAuNV9waXhpLmpzQDguNi40L25vZGVfbW9kdWxlcy9waXhpLWZpbHRlcnMvbGliL3pvb20tYmx1ci9ab29tQmx1ckZpbHRlci5tanMiLCJ3ZWJwYWNrOi8vcGl4aWpzLWdhbWUvLi9ub2RlX21vZHVsZXMvLnBucG0vcGl4aS1maWx0ZXJzQDYuMC41X3BpeGkuanNAOC42LjQvbm9kZV9tb2R1bGVzL3BpeGktZmlsdGVycy9saWIvem9vbS1ibHVyL3pvb20tYmx1cjIubWpzIiwid2VicGFjazovL3BpeGlqcy1nYW1lLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3BpeGktZmlsdGVyc0A2LjAuNV9waXhpLmpzQDguNi40L25vZGVfbW9kdWxlcy9waXhpLWZpbHRlcnMvbGliL2thd2FzZS1ibHVyL0thd2FzZUJsdXJGaWx0ZXIubWpzIiwid2VicGFjazovL3BpeGlqcy1nYW1lLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3BpeGktZmlsdGVyc0A2LjAuNV9waXhpLmpzQDguNi40L25vZGVfbW9kdWxlcy9waXhpLWZpbHRlcnMvbGliL2thd2FzZS1ibHVyL2thd2FzZS1ibHVyLWNsYW1wMi5tanMiLCJ3ZWJwYWNrOi8vcGl4aWpzLWdhbWUvLi9ub2RlX21vZHVsZXMvLnBucG0vcGl4aS1maWx0ZXJzQDYuMC41X3BpeGkuanNAOC42LjQvbm9kZV9tb2R1bGVzL3BpeGktZmlsdGVycy9saWIva2F3YXNlLWJsdXIva2F3YXNlLWJsdXIyLm1qcyIsIndlYnBhY2s6Ly9waXhpanMtZ2FtZS8uL25vZGVfbW9kdWxlcy8ucG5wbS9waXhpLWZpbHRlcnNANi4wLjVfcGl4aS5qc0A4LjYuNC9ub2RlX21vZHVsZXMvcGl4aS1maWx0ZXJzL2xpYi9rYXdhc2UtYmx1ci9rYXdhc2UtYmx1ci1jbGFtcC5tanMiLCJ3ZWJwYWNrOi8vcGl4aWpzLWdhbWUvLi9ub2RlX21vZHVsZXMvLnBucG0vcGl4aS1maWx0ZXJzQDYuMC41X3BpeGkuanNAOC42LjQvbm9kZV9tb2R1bGVzL3BpeGktZmlsdGVycy9saWIva2F3YXNlLWJsdXIva2F3YXNlLWJsdXIubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEZpbHRlciwgT2JzZXJ2YWJsZVBvaW50LCBkZXByZWNhdGlvbiwgR3B1UHJvZ3JhbSwgR2xQcm9ncmFtIH0gZnJvbSAncGl4aS5qcyc7XG5pbXBvcnQgdmVydGV4IGZyb20gJy4uL2RlZmF1bHRzL2RlZmF1bHQyLm1qcyc7XG5pbXBvcnQgd2dzbFZlcnRleCBmcm9tICcuLi9kZWZhdWx0cy9kZWZhdWx0Lm1qcyc7XG5pbXBvcnQgZnJhZ21lbnQgZnJvbSAnLi9tb3Rpb24tYmx1cjIubWpzJztcbmltcG9ydCBzb3VyY2UgZnJvbSAnLi9tb3Rpb24tYmx1ci5tanMnO1xuXG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiB7XG4gIF9fZGVmTm9ybWFsUHJvcChvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5jb25zdCBfTW90aW9uQmx1ckZpbHRlciA9IGNsYXNzIF9Nb3Rpb25CbHVyRmlsdGVyIGV4dGVuZHMgRmlsdGVyIHtcbiAgLyoqIEBpZ25vcmUgKi9cbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIGxldCBvcHRpb25zID0gYXJnc1swXSA/PyB7fTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zKSB8fCBcInhcIiBpbiBvcHRpb25zICYmIFwieVwiIGluIG9wdGlvbnMgfHwgb3B0aW9ucyBpbnN0YW5jZW9mIE9ic2VydmFibGVQb2ludCkge1xuICAgICAgZGVwcmVjYXRpb24oXCI2LjAuMFwiLCBcIk1vdGlvbkJsdXJGaWx0ZXIgY29uc3RydWN0b3IgcGFyYW1zIGFyZSBub3cgb3B0aW9ucyBvYmplY3QuIFNlZSBwYXJhbXM6IHsgdmVsb2NpdHksIGtlcm5lbFNpemUsIG9mZnNldCB9XCIpO1xuICAgICAgY29uc3QgeCA9IFwieFwiIGluIG9wdGlvbnMgPyBvcHRpb25zLnggOiBvcHRpb25zWzBdO1xuICAgICAgY29uc3QgeSA9IFwieVwiIGluIG9wdGlvbnMgPyBvcHRpb25zLnkgOiBvcHRpb25zWzFdO1xuICAgICAgb3B0aW9ucyA9IHsgdmVsb2NpdHk6IHsgeCwgeSB9IH07XG4gICAgICBpZiAoYXJnc1sxXSAhPT0gdm9pZCAwKVxuICAgICAgICBvcHRpb25zLmtlcm5lbFNpemUgPSBhcmdzWzFdO1xuICAgICAgaWYgKGFyZ3NbMl0gIT09IHZvaWQgMClcbiAgICAgICAgb3B0aW9ucy5vZmZzZXQgPSBhcmdzWzJdO1xuICAgIH1cbiAgICBvcHRpb25zID0geyAuLi5fTW90aW9uQmx1ckZpbHRlci5ERUZBVUxUX09QVElPTlMsIC4uLm9wdGlvbnMgfTtcbiAgICBjb25zdCBncHVQcm9ncmFtID0gR3B1UHJvZ3JhbS5mcm9tKHtcbiAgICAgIHZlcnRleDoge1xuICAgICAgICBzb3VyY2U6IHdnc2xWZXJ0ZXgsXG4gICAgICAgIGVudHJ5UG9pbnQ6IFwibWFpblZlcnRleFwiXG4gICAgICB9LFxuICAgICAgZnJhZ21lbnQ6IHtcbiAgICAgICAgc291cmNlLFxuICAgICAgICBlbnRyeVBvaW50OiBcIm1haW5GcmFnbWVudFwiXG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgZ2xQcm9ncmFtID0gR2xQcm9ncmFtLmZyb20oe1xuICAgICAgdmVydGV4LFxuICAgICAgZnJhZ21lbnQsXG4gICAgICBuYW1lOiBcIm1vdGlvbi1ibHVyLWZpbHRlclwiXG4gICAgfSk7XG4gICAgc3VwZXIoe1xuICAgICAgZ3B1UHJvZ3JhbSxcbiAgICAgIGdsUHJvZ3JhbSxcbiAgICAgIHJlc291cmNlczoge1xuICAgICAgICBtb3Rpb25CbHVyVW5pZm9ybXM6IHtcbiAgICAgICAgICB1VmVsb2NpdHk6IHsgdmFsdWU6IG9wdGlvbnMudmVsb2NpdHksIHR5cGU6IFwidmVjMjxmMzI+XCIgfSxcbiAgICAgICAgICB1S2VybmVsU2l6ZTogeyB2YWx1ZTogTWF0aC50cnVuYyhvcHRpb25zLmtlcm5lbFNpemUgPz8gNSksIHR5cGU6IFwiaTMyXCIgfSxcbiAgICAgICAgICB1T2Zmc2V0OiB7IHZhbHVlOiBvcHRpb25zLm9mZnNldCwgdHlwZTogXCJmMzJcIiB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidW5pZm9ybXNcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9rZXJuZWxTaXplXCIpO1xuICAgIHRoaXMudW5pZm9ybXMgPSB0aGlzLnJlc291cmNlcy5tb3Rpb25CbHVyVW5pZm9ybXMudW5pZm9ybXM7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgdmVsb2NpdHkgb2YgdGhlIG1vdGlvbiBmb3IgYmx1ciBlZmZlY3RcbiAgICogVGhpcyBzaG91bGQgYmUgYSBzaXplIDIgYXJyYXkgb3IgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYHhgIGFuZCBgeWAgdmFsdWVzLCB5b3UgY2Fubm90IGNoYW5nZSB0eXBlc1xuICAgKiBvbmNlIGRlZmluZWQgaW4gdGhlIGNvbnN0cnVjdG9yXG4gICAqIEBkZWZhdWx0IHt4OjAseTowfVxuICAgKi9cbiAgZ2V0IHZlbG9jaXR5KCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnVWZWxvY2l0eTtcbiAgfVxuICBzZXQgdmVsb2NpdHkodmFsdWUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHZhbHVlID0geyB4OiB2YWx1ZVswXSwgeTogdmFsdWVbMV0gfTtcbiAgICB9XG4gICAgdGhpcy51bmlmb3Jtcy51VmVsb2NpdHkgPSB2YWx1ZTtcbiAgICB0aGlzLl91cGRhdGVEaXJ0eSgpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSB2ZWxvY2l0eSBvZiB0aGUgbW90aW9uIGZvciBibHVyIGVmZmVjdCBvbiB0aGUgYHhgIGF4aXNcbiAgICogQGRlZmF1bHQgMFxuICAgKi9cbiAgZ2V0IHZlbG9jaXR5WCgpIHtcbiAgICByZXR1cm4gdGhpcy52ZWxvY2l0eS54O1xuICB9XG4gIHNldCB2ZWxvY2l0eVgodmFsdWUpIHtcbiAgICB0aGlzLnZlbG9jaXR5LnggPSB2YWx1ZTtcbiAgICB0aGlzLl91cGRhdGVEaXJ0eSgpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSB2ZWxvY2l0eSBvZiB0aGUgbW90aW9uIGZvciBibHVyIGVmZmVjdCBvbiB0aGUgYHhgIGF4aXNcbiAgICogQGRlZmF1bHQgMFxuICAgKi9cbiAgZ2V0IHZlbG9jaXR5WSgpIHtcbiAgICByZXR1cm4gdGhpcy52ZWxvY2l0eS55O1xuICB9XG4gIHNldCB2ZWxvY2l0eVkodmFsdWUpIHtcbiAgICB0aGlzLnZlbG9jaXR5LnkgPSB2YWx1ZTtcbiAgICB0aGlzLl91cGRhdGVEaXJ0eSgpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUga2VybmVsU2l6ZSBvZiB0aGUgYmx1ciBmaWx0ZXIuIE11c3QgYmUgb2RkIG51bWJlciA+PSA1XG4gICAqIEBkZWZhdWx0IDVcbiAgICovXG4gIGdldCBrZXJuZWxTaXplKCkge1xuICAgIHJldHVybiB0aGlzLl9rZXJuZWxTaXplO1xuICB9XG4gIHNldCBrZXJuZWxTaXplKHZhbHVlKSB7XG4gICAgdGhpcy5fa2VybmVsU2l6ZSA9IHZhbHVlO1xuICAgIHRoaXMuX3VwZGF0ZURpcnR5KCk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBvZmZzZXQgb2YgdGhlIGJsdXIgZmlsdGVyXG4gICAqIEBkZWZhdWx0IDBcbiAgICovXG4gIGdldCBvZmZzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMudU9mZnNldDtcbiAgfVxuICBzZXQgb2Zmc2V0KHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy51T2Zmc2V0ID0gdmFsdWU7XG4gIH1cbiAgX3VwZGF0ZURpcnR5KCkge1xuICAgIHRoaXMucGFkZGluZyA9IChNYXRoLm1heChNYXRoLmFicyh0aGlzLnZlbG9jaXR5WCksIE1hdGguYWJzKHRoaXMudmVsb2NpdHlZKSkgPj4gMCkgKyAxO1xuICAgIHRoaXMudW5pZm9ybXMudUtlcm5lbFNpemUgPSB0aGlzLnZlbG9jaXR5WCAhPT0gMCB8fCB0aGlzLnZlbG9jaXR5WSAhPT0gMCA/IHRoaXMuX2tlcm5lbFNpemUgOiAwO1xuICB9XG59O1xuLyoqIERlZmF1bHQgdmFsdWVzIGZvciBvcHRpb25zLiAqL1xuX19wdWJsaWNGaWVsZChfTW90aW9uQmx1ckZpbHRlciwgXCJERUZBVUxUX09QVElPTlNcIiwge1xuICB2ZWxvY2l0eTogeyB4OiAwLCB5OiAwIH0sXG4gIGtlcm5lbFNpemU6IDUsXG4gIG9mZnNldDogMFxufSk7XG5sZXQgTW90aW9uQmx1ckZpbHRlciA9IF9Nb3Rpb25CbHVyRmlsdGVyO1xuXG5leHBvcnQgeyBNb3Rpb25CbHVyRmlsdGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Nb3Rpb25CbHVyRmlsdGVyLm1qcy5tYXBcbiIsInZhciBzb3VyY2UgPSBcInN0cnVjdCBNb3Rpb25CbHVyVW5pZm9ybXMge1xcbiAgdVZlbG9jaXR5OiB2ZWMyPGYzMj4sXFxuICB1S2VybmVsU2l6ZTogZjMyLFxcbiAgdU9mZnNldDogZjMyLFxcbn07XFxuXFxuc3RydWN0IEdsb2JhbEZpbHRlclVuaWZvcm1zIHtcXG4gIHVJbnB1dFNpemU6dmVjNDxmMzI+LFxcbiAgdUlucHV0UGl4ZWw6dmVjNDxmMzI+LFxcbiAgdUlucHV0Q2xhbXA6dmVjNDxmMzI+LFxcbiAgdU91dHB1dEZyYW1lOnZlYzQ8ZjMyPixcXG4gIHVHbG9iYWxGcmFtZTp2ZWM0PGYzMj4sXFxuICB1T3V0cHV0VGV4dHVyZTp2ZWM0PGYzMj4sXFxufTtcXG5cXG5AZ3JvdXAoMCkgQGJpbmRpbmcoMCkgdmFyPHVuaWZvcm0+IGdmdTogR2xvYmFsRmlsdGVyVW5pZm9ybXM7XFxuXFxuQGdyb3VwKDApIEBiaW5kaW5nKDEpIHZhciB1VGV4dHVyZTogdGV4dHVyZV8yZDxmMzI+OyBcXG5AZ3JvdXAoMCkgQGJpbmRpbmcoMikgdmFyIHVTYW1wbGVyOiBzYW1wbGVyO1xcbkBncm91cCgxKSBAYmluZGluZygwKSB2YXI8dW5pZm9ybT4gbW90aW9uQmx1clVuaWZvcm1zIDogTW90aW9uQmx1clVuaWZvcm1zO1xcblxcbkBmcmFnbWVudFxcbmZuIG1haW5GcmFnbWVudChcXG4gIEBidWlsdGluKHBvc2l0aW9uKSBwb3NpdGlvbjogdmVjNDxmMzI+LFxcbiAgQGxvY2F0aW9uKDApIHV2IDogdmVjMjxmMzI+XFxuKSAtPiBAbG9jYXRpb24oMCkgdmVjNDxmMzI+IHtcXG4gIGxldCB1VmVsb2NpdHkgPSBtb3Rpb25CbHVyVW5pZm9ybXMudVZlbG9jaXR5O1xcbiAgbGV0IHVLZXJuZWxTaXplID0gbW90aW9uQmx1clVuaWZvcm1zLnVLZXJuZWxTaXplO1xcbiAgbGV0IHVPZmZzZXQgPSBtb3Rpb25CbHVyVW5pZm9ybXMudU9mZnNldDtcXG5cXG4gIGxldCB2ZWxvY2l0eTogdmVjMjxmMzI+ID0gdVZlbG9jaXR5IC8gZ2Z1LnVJbnB1dFNpemUueHk7XFxuICBsZXQgb2Zmc2V0OiBmMzIgPSAtdU9mZnNldCAvIGxlbmd0aCh1VmVsb2NpdHkpIC0gMC41O1xcbiAgbGV0IGs6IGkzMiA9IGkzMihtaW4odUtlcm5lbFNpemUgLSAxLCBNQVhfS0VSTkVMX1NJWkUgLSAxKSk7XFxuXFxuICB2YXIgY29sb3I6IHZlYzQ8ZjMyPiA9IHRleHR1cmVTYW1wbGUodVRleHR1cmUsIHVTYW1wbGVyLCB1dik7XFxuXFxuICBmb3IodmFyIGk6IGkzMiA9IDA7IGkgPCBrOyBpICs9IDEpIHtcXG4gICAgbGV0IGJpYXM6IHZlYzI8ZjMyPiA9IHZlbG9jaXR5ICogKGYzMihpKSAvIGYzMihrKSArIG9mZnNldCk7XFxuICAgIGNvbG9yICs9IHRleHR1cmVTYW1wbGUodVRleHR1cmUsIHVTYW1wbGVyLCB1diArIGJpYXMpO1xcbiAgfVxcbiAgXFxuICByZXR1cm4gc2VsZWN0KGNvbG9yIC8gZjMyKHVLZXJuZWxTaXplKSwgdGV4dHVyZVNhbXBsZSh1VGV4dHVyZSwgdVNhbXBsZXIsIHV2KSwgdUtlcm5lbFNpemUgPT0gMCk7XFxufVxcblxcbmNvbnN0IE1BWF9LRVJORUxfU0laRTogZjMyID0gMjA0ODtcIjtcblxuZXhwb3J0IHsgc291cmNlIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vdGlvbi1ibHVyLm1qcy5tYXBcbiIsInZhciBmcmFnbWVudCA9IFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbmluIHZlYzIgdlRleHR1cmVDb29yZDtcXG5vdXQgdmVjNCBmaW5hbENvbG9yO1xcblxcbnVuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbnVuaWZvcm0gdmVjMiB1VmVsb2NpdHk7XFxudW5pZm9ybSBpbnQgdUtlcm5lbFNpemU7XFxudW5pZm9ybSBmbG9hdCB1T2Zmc2V0O1xcblxcbnVuaWZvcm0gdmVjNCB1SW5wdXRTaXplO1xcblxcbmNvbnN0IGludCBNQVhfS0VSTkVMX1NJWkUgPSAyMDQ4O1xcblxcbi8vIE5vdGljZTpcXG4vLyB0aGUgcGVyZmVjdCB3YXk6XFxuLy8gICAgaW50IGtlcm5lbFNpemUgPSBtaW4odUtlcm5lbFNpemUsIE1BWF9LRVJORUxTSVpFKTtcXG4vLyBCVVQgaW4gcmVhbCB1c2UtY2FzZSAsIHVLZXJuZWxTaXplIDwgTUFYX0tFUk5FTFNJWkUgYWxtb3N0IGFsd2F5cy5cXG4vLyBTbyB1c2UgdUtlcm5lbFNpemUgZGlyZWN0bHkuXFxuXFxudm9pZCBtYWluKHZvaWQpXFxue1xcbiAgICB2ZWM0IGNvbG9yID0gdGV4dHVyZSh1VGV4dHVyZSwgdlRleHR1cmVDb29yZCk7XFxuXFxuICAgIGlmICh1S2VybmVsU2l6ZSA9PSAwKVxcbiAgICB7XFxuICAgICAgICBmaW5hbENvbG9yID0gY29sb3I7XFxuICAgICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgdmVjMiB2ZWxvY2l0eSA9IHVWZWxvY2l0eSAvIHVJbnB1dFNpemUueHk7XFxuICAgIGZsb2F0IG9mZnNldCA9IC11T2Zmc2V0IC8gbGVuZ3RoKHVWZWxvY2l0eSkgLSAwLjU7XFxuICAgIGludCBrID0gdUtlcm5lbFNpemUgLSAxO1xcblxcbiAgICBmb3IoaW50IGkgPSAwOyBpIDwgTUFYX0tFUk5FTF9TSVpFIC0gMTsgaSsrKSB7XFxuICAgICAgICBpZiAoaSA9PSBrKSB7XFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICB9XFxuICAgICAgICB2ZWMyIGJpYXMgPSB2ZWxvY2l0eSAqIChmbG9hdChpKSAvIGZsb2F0KGspICsgb2Zmc2V0KTtcXG4gICAgICAgIGNvbG9yICs9IHRleHR1cmUodVRleHR1cmUsIHZUZXh0dXJlQ29vcmQgKyBiaWFzKTtcXG4gICAgfVxcbiAgICBmaW5hbENvbG9yID0gY29sb3IgLyBmbG9hdCh1S2VybmVsU2l6ZSk7XFxufVxcblwiO1xuXG5leHBvcnQgeyBmcmFnbWVudCBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb3Rpb24tYmx1cjIubWpzLm1hcFxuIiwidmFyIGZyYWdtZW50ID0gXCJpbiB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxub3V0IHZlYzQgZmluYWxDb2xvcjtcXG5cXG5jb25zdCBpbnQgTUFYX0NPTE9SUyA9ICR7TUFYX0NPTE9SU307XFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxudW5pZm9ybSB2ZWMzIHVPcmlnaW5hbENvbG9yc1tNQVhfQ09MT1JTXTtcXG51bmlmb3JtIHZlYzMgdVRhcmdldENvbG9yc1tNQVhfQ09MT1JTXTtcXG51bmlmb3JtIGZsb2F0IHVUb2xlcmFuY2U7XFxuXFxudm9pZCBtYWluKHZvaWQpXFxue1xcbiAgICBmaW5hbENvbG9yID0gdGV4dHVyZSh1VGV4dHVyZSwgdlRleHR1cmVDb29yZCk7XFxuXFxuICAgIGZsb2F0IGFscGhhID0gZmluYWxDb2xvci5hO1xcbiAgICBpZiAoYWxwaGEgPCAwLjAwMDEpXFxuICAgIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgdmVjMyBjb2xvciA9IGZpbmFsQ29sb3IucmdiIC8gYWxwaGE7XFxuXFxuICAgIGZvcihpbnQgaSA9IDA7IGkgPCBNQVhfQ09MT1JTOyBpKyspXFxuICAgIHtcXG4gICAgICB2ZWMzIG9yaWdDb2xvciA9IHVPcmlnaW5hbENvbG9yc1tpXTtcXG4gICAgICBpZiAob3JpZ0NvbG9yLnIgPCAwLjApXFxuICAgICAge1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgfVxcbiAgICAgIHZlYzMgY29sb3JEaWZmID0gb3JpZ0NvbG9yIC0gY29sb3I7XFxuICAgICAgaWYgKGxlbmd0aChjb2xvckRpZmYpIDwgdVRvbGVyYW5jZSlcXG4gICAgICB7XFxuICAgICAgICB2ZWMzIHRhcmdldENvbG9yID0gdVRhcmdldENvbG9yc1tpXTtcXG4gICAgICAgIGZpbmFsQ29sb3IgPSB2ZWM0KCh0YXJnZXRDb2xvciArIGNvbG9yRGlmZikgKiBhbHBoYSwgYWxwaGEpO1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG4gICAgfVxcbn1cXG5cIjtcblxuZXhwb3J0IHsgZnJhZ21lbnQgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bXVsdGktY29sb3ItcmVwbGFjZTIubWpzLm1hcFxuIiwiaW1wb3J0IHsgRmlsdGVyLCBkZXByZWNhdGlvbiwgR3B1UHJvZ3JhbSwgR2xQcm9ncmFtLCBDb2xvciB9IGZyb20gJ3BpeGkuanMnO1xuaW1wb3J0IHZlcnRleCBmcm9tICcuLi9kZWZhdWx0cy9kZWZhdWx0Mi5tanMnO1xuaW1wb3J0IHdnc2xWZXJ0ZXggZnJvbSAnLi4vZGVmYXVsdHMvZGVmYXVsdC5tanMnO1xuaW1wb3J0IGZyYWdtZW50IGZyb20gJy4vbXVsdGktY29sb3ItcmVwbGFjZTIubWpzJztcbmltcG9ydCBzb3VyY2UgZnJvbSAnLi9tdWx0aS1jb2xvci1yZXBsYWNlLm1qcyc7XG5cbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbmNvbnN0IF9NdWx0aUNvbG9yUmVwbGFjZUZpbHRlciA9IGNsYXNzIF9NdWx0aUNvbG9yUmVwbGFjZUZpbHRlciBleHRlbmRzIEZpbHRlciB7XG4gIC8qKiBAaWdub3JlICovXG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3NbMF0gPz8ge307XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucykpIHtcbiAgICAgIGRlcHJlY2F0aW9uKFwiNi4wLjBcIiwgXCJNdWx0aUNvbG9yUmVwbGFjZUZpbHRlciBjb25zdHJ1Y3RvciBwYXJhbXMgYXJlIG5vdyBvcHRpb25zIG9iamVjdC4gU2VlIHBhcmFtczogeyByZXBsYWNlbWVudHMsIHRvbGVyYW5jZSwgbWF4Q29sb3JzIH1cIik7XG4gICAgICBvcHRpb25zID0geyByZXBsYWNlbWVudHM6IG9wdGlvbnMgfTtcbiAgICAgIGlmIChhcmdzWzFdKVxuICAgICAgICBvcHRpb25zLnRvbGVyYW5jZSA9IGFyZ3NbMV07XG4gICAgICBpZiAoYXJnc1syXSlcbiAgICAgICAgb3B0aW9ucy5tYXhDb2xvcnMgPSBhcmdzWzJdO1xuICAgIH1cbiAgICBvcHRpb25zID0geyAuLi5fTXVsdGlDb2xvclJlcGxhY2VGaWx0ZXIuREVGQVVMVF9PUFRJT05TLCAuLi5vcHRpb25zIH07XG4gICAgY29uc3QgbWF4Q29sb3JzID0gb3B0aW9ucy5tYXhDb2xvcnMgPz8gb3B0aW9ucy5yZXBsYWNlbWVudHMubGVuZ3RoO1xuICAgIGNvbnN0IGdwdVByb2dyYW0gPSBHcHVQcm9ncmFtLmZyb20oe1xuICAgICAgdmVydGV4OiB7XG4gICAgICAgIHNvdXJjZTogd2dzbFZlcnRleCxcbiAgICAgICAgZW50cnlQb2ludDogXCJtYWluVmVydGV4XCJcbiAgICAgIH0sXG4gICAgICBmcmFnbWVudDoge1xuICAgICAgICBzb3VyY2U6IHNvdXJjZS5yZXBsYWNlKC9cXCRcXHtNQVhfQ09MT1JTXFx9L2csIG1heENvbG9ycy50b0ZpeGVkKDApKSxcbiAgICAgICAgZW50cnlQb2ludDogXCJtYWluRnJhZ21lbnRcIlxuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGdsUHJvZ3JhbSA9IEdsUHJvZ3JhbS5mcm9tKHtcbiAgICAgIHZlcnRleCxcbiAgICAgIGZyYWdtZW50OiBmcmFnbWVudC5yZXBsYWNlKC9cXCRcXHtNQVhfQ09MT1JTXFx9L2csIG1heENvbG9ycy50b0ZpeGVkKDApKSxcbiAgICAgIG5hbWU6IFwibXVsdGktY29sb3ItcmVwbGFjZS1maWx0ZXJcIlxuICAgIH0pO1xuICAgIHN1cGVyKHtcbiAgICAgIGdwdVByb2dyYW0sXG4gICAgICBnbFByb2dyYW0sXG4gICAgICByZXNvdXJjZXM6IHtcbiAgICAgICAgbXVsdGlDb2xvclJlcGxhY2VVbmlmb3Jtczoge1xuICAgICAgICAgIHVPcmlnaW5hbENvbG9yczoge1xuICAgICAgICAgICAgdmFsdWU6IG5ldyBGbG9hdDMyQXJyYXkoMyAqIG1heENvbG9ycyksXG4gICAgICAgICAgICB0eXBlOiBcInZlYzM8ZjMyPlwiLFxuICAgICAgICAgICAgc2l6ZTogbWF4Q29sb3JzXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1VGFyZ2V0Q29sb3JzOiB7XG4gICAgICAgICAgICB2YWx1ZTogbmV3IEZsb2F0MzJBcnJheSgzICogbWF4Q29sb3JzKSxcbiAgICAgICAgICAgIHR5cGU6IFwidmVjMzxmMzI+XCIsXG4gICAgICAgICAgICBzaXplOiBtYXhDb2xvcnNcbiAgICAgICAgICB9LFxuICAgICAgICAgIHVUb2xlcmFuY2U6IHsgdmFsdWU6IG9wdGlvbnMudG9sZXJhbmNlLCB0eXBlOiBcImYzMlwiIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ1bmlmb3Jtc1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX3JlcGxhY2VtZW50c1wiLCBbXSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9tYXhDb2xvcnNcIik7XG4gICAgdGhpcy5fbWF4Q29sb3JzID0gbWF4Q29sb3JzO1xuICAgIHRoaXMudW5pZm9ybXMgPSB0aGlzLnJlc291cmNlcy5tdWx0aUNvbG9yUmVwbGFjZVVuaWZvcm1zLnVuaWZvcm1zO1xuICAgIHRoaXMucmVwbGFjZW1lbnRzID0gb3B0aW9ucy5yZXBsYWNlbWVudHM7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBjb2xsZWN0aW9uIG9mIHJlcGxhY2VtZW50IGl0ZW1zLiBFYWNoIGl0ZW0gaXMgY29sb3ItcGFpclxuICAgKiAoYW4gYXJyYXkgbGVuZ3RoIGlzIDIpLiBJbiB0aGUgcGFpciwgdGhlIGZpcnN0IHZhbHVlIGlzIG9yaWdpbmFsIGNvbG9yICwgdGhlIHNlY29uZCB2YWx1ZSBpcyB0YXJnZXQgY29sb3JcbiAgICovXG4gIHNldCByZXBsYWNlbWVudHMocmVwbGFjZW1lbnRzKSB7XG4gICAgY29uc3Qgb3JpZ2luYWxzID0gdGhpcy51bmlmb3Jtcy51T3JpZ2luYWxDb2xvcnM7XG4gICAgY29uc3QgdGFyZ2V0cyA9IHRoaXMudW5pZm9ybXMudVRhcmdldENvbG9ycztcbiAgICBjb25zdCBjb2xvckNvdW50ID0gcmVwbGFjZW1lbnRzLmxlbmd0aDtcbiAgICBjb25zdCBjb2xvciA9IG5ldyBDb2xvcigpO1xuICAgIGlmIChjb2xvckNvdW50ID4gdGhpcy5fbWF4Q29sb3JzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYExlbmd0aCBvZiByZXBsYWNlbWVudHMgKCR7Y29sb3JDb3VudH0pIGV4Y2VlZHMgdGhlIG1heGltdW0gY29sb3JzIGxlbmd0aCAoJHt0aGlzLl9tYXhDb2xvcnN9KWApO1xuICAgIH1cbiAgICBvcmlnaW5hbHNbY29sb3JDb3VudCAqIDNdID0gLTE7XG4gICAgbGV0IHI7XG4gICAgbGV0IGc7XG4gICAgbGV0IGI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2xvckNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHBhaXIgPSByZXBsYWNlbWVudHNbaV07XG4gICAgICBjb2xvci5zZXRWYWx1ZShwYWlyWzBdKTtcbiAgICAgIFtyLCBnLCBiXSA9IGNvbG9yLnRvQXJyYXkoKTtcbiAgICAgIG9yaWdpbmFsc1tpICogM10gPSByO1xuICAgICAgb3JpZ2luYWxzW2kgKiAzICsgMV0gPSBnO1xuICAgICAgb3JpZ2luYWxzW2kgKiAzICsgMl0gPSBiO1xuICAgICAgY29sb3Iuc2V0VmFsdWUocGFpclsxXSk7XG4gICAgICBbciwgZywgYl0gPSBjb2xvci50b0FycmF5KCk7XG4gICAgICB0YXJnZXRzW2kgKiAzXSA9IHI7XG4gICAgICB0YXJnZXRzW2kgKiAzICsgMV0gPSBnO1xuICAgICAgdGFyZ2V0c1tpICogMyArIDJdID0gYjtcbiAgICB9XG4gICAgdGhpcy5fcmVwbGFjZW1lbnRzID0gcmVwbGFjZW1lbnRzO1xuICB9XG4gIGdldCByZXBsYWNlbWVudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlcGxhY2VtZW50cztcbiAgfVxuICAvKipcbiAgICAqIFNob3VsZCBiZSBjYWxsZWQgYWZ0ZXIgY2hhbmdpbmcgYW55IG9mIHRoZSBjb250ZW50cyBvZiB0aGUgcmVwbGFjZW1lbnRzLlxuICAgICogVGhpcyBpcyBhIGNvbnZlbmllbmNlIG1ldGhvZCBmb3IgcmVzZXR0aW5nIHRoZSBgcmVwbGFjZW1lbnRzYC5cbiAgICAqIEB0b2RvIGltcGxlbWVudCBuZXN0ZWQgcHJveHkgdG8gcmVtb3ZlIHRoZSBuZWVkIGZvciB0aGlzIGZ1bmN0aW9uXG4gICAgKi9cbiAgcmVmcmVzaCgpIHtcbiAgICB0aGlzLnJlcGxhY2VtZW50cyA9IHRoaXMuX3JlcGxhY2VtZW50cztcbiAgfVxuICAvKipcbiAgICAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBjb2xvciByZXBsYWNlbWVudHMgc3VwcG9ydGVkIGJ5IHRoaXMgZmlsdGVyLiBDYW4gYmUgY2hhbmdlZFxuICAgICogX29ubHlfIGR1cmluZyBjb25zdHJ1Y3Rpb24uXG4gICAgKiBAcmVhZG9ubHlcbiAgICAqL1xuICBnZXQgbWF4Q29sb3JzKCkge1xuICAgIHJldHVybiB0aGlzLl9tYXhDb2xvcnM7XG4gIH1cbiAgLyoqXG4gICAgKiBUb2xlcmFuY2Ugb2YgdGhlIGZsb2F0aW5nLXBvaW50IGNvbXBhcmlzb24gYmV0d2VlbiBjb2xvcnMgKGxvd2VyID0gbW9yZSBleGFjdCwgaGlnaGVyID0gbW9yZSBpbmNsdXNpdmUpXG4gICAgKiBAZGVmYXVsdCAwLjA1XG4gICAgKi9cbiAgZ2V0IHRvbGVyYW5jZSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy51VG9sZXJhbmNlO1xuICB9XG4gIHNldCB0b2xlcmFuY2UodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnVUb2xlcmFuY2UgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgNi4wLjBcbiAgICpcbiAgICogVG9sZXJhbmNlIG9mIHRoZSBmbG9hdGluZy1wb2ludCBjb21wYXJpc29uIGJldHdlZW4gY29sb3JzIChsb3dlciA9IG1vcmUgZXhhY3QsIGhpZ2hlciA9IG1vcmUgaW5jbHVzaXZlKVxuICAgKiBAZGVmYXVsdCAwLjA1XG4gICAqL1xuICBzZXQgZXBzaWxvbih2YWx1ZSkge1xuICAgIGRlcHJlY2F0aW9uKFwiNi4wLjBcIiwgXCJNdWx0aUNvbG9yUmVwbGFjZUZpbHRlci5lcHNpbG9uIGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgTXVsdGlDb2xvclJlcGxhY2VGaWx0ZXIudG9sZXJhbmNlIGluc3RlYWRcIik7XG4gICAgdGhpcy50b2xlcmFuY2UgPSB2YWx1ZTtcbiAgfVxuICBnZXQgZXBzaWxvbigpIHtcbiAgICBkZXByZWNhdGlvbihcIjYuMC4wXCIsIFwiTXVsdGlDb2xvclJlcGxhY2VGaWx0ZXIuZXBzaWxvbiBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIE11bHRpQ29sb3JSZXBsYWNlRmlsdGVyLnRvbGVyYW5jZSBpbnN0ZWFkXCIpO1xuICAgIHJldHVybiB0aGlzLnRvbGVyYW5jZTtcbiAgfVxufTtcbi8qKiBEZWZhdWx0IHZhbHVlcyBmb3Igb3B0aW9ucy4gKi9cbl9fcHVibGljRmllbGQoX011bHRpQ29sb3JSZXBsYWNlRmlsdGVyLCBcIkRFRkFVTFRfT1BUSU9OU1wiLCB7XG4gIHJlcGxhY2VtZW50czogW1sxNjcxMTY4MCwgMjU1XV0sXG4gIHRvbGVyYW5jZTogMC4wNSxcbiAgbWF4Q29sb3JzOiB2b2lkIDBcbn0pO1xubGV0IE11bHRpQ29sb3JSZXBsYWNlRmlsdGVyID0gX011bHRpQ29sb3JSZXBsYWNlRmlsdGVyO1xuXG5leHBvcnQgeyBNdWx0aUNvbG9yUmVwbGFjZUZpbHRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TXVsdGlDb2xvclJlcGxhY2VGaWx0ZXIubWpzLm1hcFxuIiwidmFyIHNvdXJjZSA9IFwic3RydWN0IE11bHRpQ29sb3JSZXBsYWNlVW5pZm9ybXMge1xcbiAgdU9yaWdpbmFsQ29sb3JzOiBhcnJheTx2ZWMzPGYzMj4sIE1BWF9DT0xPUlM+LFxcbiAgdVRhcmdldENvbG9yczogYXJyYXk8dmVjMzxmMzI+LCBNQVhfQ09MT1JTPixcXG4gIHVUb2xlcmFuY2U6ZjMyLFxcbn07XFxuXFxuQGdyb3VwKDApIEBiaW5kaW5nKDEpIHZhciB1VGV4dHVyZTogdGV4dHVyZV8yZDxmMzI+OyBcXG5AZ3JvdXAoMCkgQGJpbmRpbmcoMikgdmFyIHVTYW1wbGVyOiBzYW1wbGVyO1xcbkBncm91cCgxKSBAYmluZGluZygwKSB2YXI8dW5pZm9ybT4gbXVsdGlDb2xvclJlcGxhY2VVbmlmb3JtcyA6IE11bHRpQ29sb3JSZXBsYWNlVW5pZm9ybXM7XFxuXFxuQGZyYWdtZW50XFxuZm4gbWFpbkZyYWdtZW50KFxcbiAgQGJ1aWx0aW4ocG9zaXRpb24pIHBvc2l0aW9uOiB2ZWM0PGYzMj4sXFxuICBAbG9jYXRpb24oMCkgdXYgOiB2ZWMyPGYzMj5cXG4pIC0+IEBsb2NhdGlvbigwKSB2ZWM0PGYzMj4ge1xcbiAgbGV0IHVPcmlnaW5hbENvbG9ycyA9IG11bHRpQ29sb3JSZXBsYWNlVW5pZm9ybXMudU9yaWdpbmFsQ29sb3JzO1xcbiAgbGV0IHVUYXJnZXRDb2xvcnMgPSBtdWx0aUNvbG9yUmVwbGFjZVVuaWZvcm1zLnVUYXJnZXRDb2xvcnM7XFxuICBsZXQgdVRvbGVyYW5jZSA9IG11bHRpQ29sb3JSZXBsYWNlVW5pZm9ybXMudVRvbGVyYW5jZTtcXG5cXG4gIHZhciBjb2xvcjogdmVjNDxmMzI+ID0gdGV4dHVyZVNhbXBsZSh1VGV4dHVyZSwgdVNhbXBsZXIsIHV2KTtcXG5cXG4gIGxldCBhbHBoYTogZjMyID0gY29sb3IuYTtcXG5cXG4gIGlmIChhbHBoYSA+IDAuMDAwMSlcXG4gIHtcXG4gICAgdmFyIG1vZENvbG9yOiB2ZWMzPGYzMj4gPSB2ZWMzPGYzMj4oY29sb3IucmdiKSAvIGFscGhhO1xcblxcbiAgICBmb3IodmFyIGk6IGkzMiA9IDA7IGkgPCBNQVhfQ09MT1JTOyBpICs9IDEpXFxuICAgIHtcXG4gICAgICBsZXQgb3JpZ0NvbG9yOiB2ZWMzPGYzMj4gPSB1T3JpZ2luYWxDb2xvcnNbaV07XFxuICAgICAgaWYgKG9yaWdDb2xvci5yIDwgMC4wKVxcbiAgICAgIHtcXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIH1cXG4gICAgICBsZXQgY29sb3JEaWZmOiB2ZWMzPGYzMj4gPSBvcmlnQ29sb3IgLSBtb2RDb2xvcjtcXG4gICAgICBcXG4gICAgICBpZiAobGVuZ3RoKGNvbG9yRGlmZikgPCB1VG9sZXJhbmNlKVxcbiAgICAgIHtcXG4gICAgICAgIGxldCB0YXJnZXRDb2xvcjogdmVjMzxmMzI+ID0gdVRhcmdldENvbG9yc1tpXTtcXG4gICAgICAgIGNvbG9yID0gdmVjNCgodGFyZ2V0Q29sb3IgKyBjb2xvckRpZmYpICogYWxwaGEsIGFscGhhKTtcXG4gICAgICAgIHJldHVybiBjb2xvcjtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiBjb2xvcjtcXG59XFxuXFxuY29uc3QgTUFYX0NPTE9SUzogaTMyID0gJHtNQVhfQ09MT1JTfTtcIjtcblxuZXhwb3J0IHsgc291cmNlIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW11bHRpLWNvbG9yLXJlcGxhY2UubWpzLm1hcFxuIiwidmFyIGZyYWdtZW50ID0gXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuaW4gdmVjMiB2VGV4dHVyZUNvb3JkO1xcbm91dCB2ZWM0IGZpbmFsQ29sb3I7XFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxudW5pZm9ybSBmbG9hdCB1U2VwaWE7XFxudW5pZm9ybSB2ZWMyIHVOb2lzZTtcXG51bmlmb3JtIHZlYzMgdVNjcmF0Y2g7XFxudW5pZm9ybSB2ZWMzIHVWaWduZXR0aW5nO1xcbnVuaWZvcm0gZmxvYXQgdVNlZWQ7XFxudW5pZm9ybSB2ZWMyIHVEaW1lbnNpb25zO1xcblxcbnVuaWZvcm0gdmVjNCB1SW5wdXRTaXplO1xcblxcbmNvbnN0IGZsb2F0IFNRUlRfMiA9IDEuNDE0MjEzO1xcbmNvbnN0IHZlYzMgU0VQSUFfUkdCID0gdmVjMygxMTIuMCAvIDI1NS4wLCA2Ni4wIC8gMjU1LjAsIDIwLjAgLyAyNTUuMCk7XFxuXFxuZmxvYXQgcmFuZCh2ZWMyIGNvKSB7XFxuICAgIHJldHVybiBmcmFjdChzaW4oZG90KGNvLnh5LCB2ZWMyKDEyLjk4OTgsIDc4LjIzMykpKSAqIDQzNzU4LjU0NTMpO1xcbn1cXG5cXG52ZWMzIE92ZXJsYXkodmVjMyBzcmMsIHZlYzMgZHN0KVxcbntcXG4gICAgLy8gaWYgKGRzdCA8PSAwLjUpIHRoZW46IDIgKiBzcmMgKiBkc3RcXG4gICAgLy8gaWYgKGRzdCA+IDAuNSkgdGhlbjogMSAtIDIgKiAoMSAtIGRzdCkgKiAoMSAtIHNyYylcXG4gICAgcmV0dXJuIHZlYzMoKGRzdC54IDw9IDAuNSkgPyAoMi4wICogc3JjLnggKiBkc3QueCkgOiAoMS4wIC0gMi4wICogKDEuMCAtIGRzdC54KSAqICgxLjAgLSBzcmMueCkpLFxcbiAgICAgICAgICAgICAgICAoZHN0LnkgPD0gMC41KSA/ICgyLjAgKiBzcmMueSAqIGRzdC55KSA6ICgxLjAgLSAyLjAgKiAoMS4wIC0gZHN0LnkpICogKDEuMCAtIHNyYy55KSksXFxuICAgICAgICAgICAgICAgIChkc3QueiA8PSAwLjUpID8gKDIuMCAqIHNyYy56ICogZHN0LnopIDogKDEuMCAtIDIuMCAqICgxLjAgLSBkc3QueikgKiAoMS4wIC0gc3JjLnopKSk7XFxufVxcblxcblxcbnZvaWQgbWFpbigpXFxue1xcbiAgICBmaW5hbENvbG9yID0gdGV4dHVyZSh1VGV4dHVyZSwgdlRleHR1cmVDb29yZCk7XFxuICAgIHZlYzMgY29sb3IgPSBmaW5hbENvbG9yLnJnYjtcXG5cXG4gICAgaWYgKHVTZXBpYSA+IDAuMClcXG4gICAge1xcbiAgICAgICAgZmxvYXQgZ3JheSA9IChjb2xvci54ICsgY29sb3IueSArIGNvbG9yLnopIC8gMy4wO1xcbiAgICAgICAgdmVjMyBncmF5c2NhbGUgPSB2ZWMzKGdyYXkpO1xcblxcbiAgICAgICAgY29sb3IgPSBPdmVybGF5KFNFUElBX1JHQiwgZ3JheXNjYWxlKTtcXG5cXG4gICAgICAgIGNvbG9yID0gZ3JheXNjYWxlICsgdVNlcGlhICogKGNvbG9yIC0gZ3JheXNjYWxlKTtcXG4gICAgfVxcblxcbiAgICB2ZWMyIGNvb3JkID0gdlRleHR1cmVDb29yZCAqIHVJbnB1dFNpemUueHkgLyB1RGltZW5zaW9ucy54eTtcXG5cXG4gICAgZmxvYXQgdmlnbmV0dGUgPSB1VmlnbmV0dGluZ1swXTtcXG4gICAgZmxvYXQgdmlnbmV0dGVBbHBoYSA9IHVWaWduZXR0aW5nWzFdO1xcbiAgICBmbG9hdCB2aWduZXR0ZUJsdXIgPSB1VmlnbmV0dGluZ1syXTtcXG5cXG4gICAgaWYgKHZpZ25ldHRlID4gMC4wKVxcbiAgICB7XFxuICAgICAgICBmbG9hdCBvdXR0ZXIgPSBTUVJUXzIgLSB2aWduZXR0ZSAqIFNRUlRfMjtcXG4gICAgICAgIHZlYzIgZGlyID0gdmVjMih2ZWMyKDAuNSwgMC41KSAtIGNvb3JkKTtcXG4gICAgICAgIGRpci55ICo9IHVEaW1lbnNpb25zLnkgLyB1RGltZW5zaW9ucy54O1xcbiAgICAgICAgZmxvYXQgZGFya2VyID0gY2xhbXAoKG91dHRlciAtIGxlbmd0aChkaXIpICogU1FSVF8yKSAvICggMC4wMDAwMSArIHZpZ25ldHRlQmx1ciAqIFNRUlRfMiksIDAuMCwgMS4wKTtcXG4gICAgICAgIGNvbG9yLnJnYiAqPSBkYXJrZXIgKyAoMS4wIC0gZGFya2VyKSAqICgxLjAgLSB2aWduZXR0ZUFscGhhKTtcXG4gICAgfVxcblxcbiAgICBmbG9hdCBzY3JhdGNoID0gdVNjcmF0Y2hbMF07XFxuICAgIGZsb2F0IHNjcmF0Y2hEZW5zaXR5ID0gdVNjcmF0Y2hbMV07XFxuICAgIGZsb2F0IHNjcmF0Y2hXaWR0aCA9IHVTY3JhdGNoWzJdO1xcblxcbiAgICBpZiAoc2NyYXRjaERlbnNpdHkgPiB1U2VlZCAmJiBzY3JhdGNoICE9IDAuMClcXG4gICAge1xcbiAgICAgICAgZmxvYXQgcGhhc2UgPSB1U2VlZCAqIDI1Ni4wO1xcbiAgICAgICAgZmxvYXQgcyA9IG1vZChmbG9vcihwaGFzZSksIDIuMCk7XFxuICAgICAgICBmbG9hdCBkaXN0ID0gMS4wIC8gc2NyYXRjaERlbnNpdHk7XFxuICAgICAgICBmbG9hdCBkID0gZGlzdGFuY2UoY29vcmQsIHZlYzIodVNlZWQgKiBkaXN0LCBhYnMocyAtIHVTZWVkICogZGlzdCkpKTtcXG4gICAgICAgIGlmIChkIDwgdVNlZWQgKiAwLjYgKyAwLjQpXFxuICAgICAgICB7XFxuICAgICAgICAgICAgaGlnaHAgZmxvYXQgcGVyaW9kID0gc2NyYXRjaERlbnNpdHkgKiAxMC4wO1xcblxcbiAgICAgICAgICAgIGZsb2F0IHh4ID0gY29vcmQueCAqIHBlcmlvZCArIHBoYXNlO1xcbiAgICAgICAgICAgIGZsb2F0IGFhID0gYWJzKG1vZCh4eCwgMC41KSAqIDQuMCk7XFxuICAgICAgICAgICAgZmxvYXQgYmIgPSBtb2QoZmxvb3IoeHggLyAwLjUpLCAyLjApO1xcbiAgICAgICAgICAgIGZsb2F0IHl5ID0gKDEuMCAtIGJiKSAqIGFhICsgYmIgKiAoMi4wIC0gYWEpO1xcblxcbiAgICAgICAgICAgIGZsb2F0IGtrID0gMi4wICogcGVyaW9kO1xcbiAgICAgICAgICAgIGZsb2F0IGR3ID0gc2NyYXRjaFdpZHRoIC8gdURpbWVuc2lvbnMueCAqICgwLjc1ICsgdVNlZWQpO1xcbiAgICAgICAgICAgIGZsb2F0IGRoID0gZHcgKiBraztcXG5cXG4gICAgICAgICAgICBmbG9hdCB0aW5lID0gKHl5IC0gKDIuMCAtIGRoKSk7XFxuXFxuICAgICAgICAgICAgaWYgKHRpbmUgPiAwLjApIHtcXG4gICAgICAgICAgICAgICAgZmxvYXQgX3NpZ24gPSBzaWduKHNjcmF0Y2gpO1xcblxcbiAgICAgICAgICAgICAgICB0aW5lID0gcyAqIHRpbmUgLyBwZXJpb2QgKyBzY3JhdGNoICsgMC4xO1xcbiAgICAgICAgICAgICAgICB0aW5lID0gY2xhbXAodGluZSArIDEuMCwgMC41ICsgX3NpZ24gKiAwLjUsIDEuNSArIF9zaWduICogMC41KTtcXG5cXG4gICAgICAgICAgICAgICAgY29sb3IucmdiICo9IHRpbmU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGZsb2F0IG5vaXNlID0gdU5vaXNlWzBdO1xcbiAgICBmbG9hdCBub2lzZVNpemUgPSB1Tm9pc2VbMV07XFxuXFxuICAgIGlmIChub2lzZSA+IDAuMCAmJiBub2lzZVNpemUgPiAwLjApXFxuICAgIHtcXG4gICAgICAgIHZlYzIgcGl4ZWxDb29yZCA9IHZUZXh0dXJlQ29vcmQueHkgKiB1SW5wdXRTaXplLnh5O1xcbiAgICAgICAgcGl4ZWxDb29yZC54ID0gZmxvb3IocGl4ZWxDb29yZC54IC8gbm9pc2VTaXplKTtcXG4gICAgICAgIHBpeGVsQ29vcmQueSA9IGZsb29yKHBpeGVsQ29vcmQueSAvIG5vaXNlU2l6ZSk7XFxuICAgICAgICAvLyB2ZWMyIGQgPSBwaXhlbENvb3JkICogbm9pc2VTaXplICogdmVjMigxMDI0LjAgKyB1U2VlZCAqIDUxMi4wLCAxMDI0LjAgLSB1U2VlZCAqIDUxMi4wKTtcXG4gICAgICAgIC8vIGZsb2F0IF9ub2lzZSA9IHNub2lzZShkKSAqIDAuNTtcXG4gICAgICAgIGZsb2F0IF9ub2lzZSA9IHJhbmQocGl4ZWxDb29yZCAqIG5vaXNlU2l6ZSAqIHVTZWVkKSAtIDAuNTtcXG4gICAgICAgIGNvbG9yICs9IF9ub2lzZSAqIG5vaXNlO1xcbiAgICB9XFxuXFxuICAgIGZpbmFsQ29sb3IucmdiID0gY29sb3I7XFxufVwiO1xuXG5leHBvcnQgeyBmcmFnbWVudCBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vbGQtZmlsbTIubWpzLm1hcFxuIiwiaW1wb3J0IHsgRmlsdGVyLCBHcHVQcm9ncmFtLCBHbFByb2dyYW0gfSBmcm9tICdwaXhpLmpzJztcbmltcG9ydCB2ZXJ0ZXggZnJvbSAnLi4vZGVmYXVsdHMvZGVmYXVsdDIubWpzJztcbmltcG9ydCB3Z3NsVmVydGV4IGZyb20gJy4uL2RlZmF1bHRzL2RlZmF1bHQubWpzJztcbmltcG9ydCBmcmFnbWVudCBmcm9tICcuL29sZC1maWxtMi5tanMnO1xuaW1wb3J0IHNvdXJjZSBmcm9tICcuL29sZC1maWxtLm1qcyc7XG5cbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbmNvbnN0IF9PbGRGaWxtRmlsdGVyID0gY2xhc3MgX09sZEZpbG1GaWx0ZXIgZXh0ZW5kcyBGaWx0ZXIge1xuICAvKipcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGZvciB0aGUgT2xkRmlsbUZpbHRlciBjb25zdHJ1Y3Rvci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0geyAuLi5fT2xkRmlsbUZpbHRlci5ERUZBVUxUX09QVElPTlMsIC4uLm9wdGlvbnMgfTtcbiAgICBjb25zdCBncHVQcm9ncmFtID0gR3B1UHJvZ3JhbS5mcm9tKHtcbiAgICAgIHZlcnRleDoge1xuICAgICAgICBzb3VyY2U6IHdnc2xWZXJ0ZXgsXG4gICAgICAgIGVudHJ5UG9pbnQ6IFwibWFpblZlcnRleFwiXG4gICAgICB9LFxuICAgICAgZnJhZ21lbnQ6IHtcbiAgICAgICAgc291cmNlLFxuICAgICAgICBlbnRyeVBvaW50OiBcIm1haW5GcmFnbWVudFwiXG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgZ2xQcm9ncmFtID0gR2xQcm9ncmFtLmZyb20oe1xuICAgICAgdmVydGV4LFxuICAgICAgZnJhZ21lbnQsXG4gICAgICBuYW1lOiBcIm9sZC1maWxtLWZpbHRlclwiXG4gICAgfSk7XG4gICAgc3VwZXIoe1xuICAgICAgZ3B1UHJvZ3JhbSxcbiAgICAgIGdsUHJvZ3JhbSxcbiAgICAgIHJlc291cmNlczoge1xuICAgICAgICBvbGRGaWxtVW5pZm9ybXM6IHtcbiAgICAgICAgICB1U2VwaWE6IHsgdmFsdWU6IG9wdGlvbnMuc2VwaWEsIHR5cGU6IFwiZjMyXCIgfSxcbiAgICAgICAgICB1Tm9pc2U6IHsgdmFsdWU6IG5ldyBGbG9hdDMyQXJyYXkoMiksIHR5cGU6IFwidmVjMjxmMzI+XCIgfSxcbiAgICAgICAgICB1U2NyYXRjaDogeyB2YWx1ZTogbmV3IEZsb2F0MzJBcnJheSgzKSwgdHlwZTogXCJ2ZWMzPGYzMj5cIiB9LFxuICAgICAgICAgIHVWaWduZXR0aW5nOiB7IHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KDMpLCB0eXBlOiBcInZlYzM8ZjMyPlwiIH0sXG4gICAgICAgICAgdVNlZWQ6IHsgdmFsdWU6IG9wdGlvbnMuc2VlZCwgdHlwZTogXCJmMzJcIiB9LFxuICAgICAgICAgIHVEaW1lbnNpb25zOiB7IHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KDIpLCB0eXBlOiBcInZlYzI8ZjMyPlwiIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ1bmlmb3Jtc1wiKTtcbiAgICAvKipcbiAgICAgKiBBIHNlZWQgdmFsdWUgdG8gYXBwbHkgdG8gdGhlIHJhbmRvbSBub2lzZSBnZW5lcmF0aW9uXG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzZWVkXCIpO1xuICAgIHRoaXMudW5pZm9ybXMgPSB0aGlzLnJlc291cmNlcy5vbGRGaWxtVW5pZm9ybXMudW5pZm9ybXM7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogT3ZlcnJpZGUgZXhpc3RpbmcgYXBwbHkgbWV0aG9kIGluIGBGaWx0ZXJgXG4gICAqIEBvdmVycmlkZVxuICAgKiBAaWdub3JlXG4gICAqL1xuICBhcHBseShmaWx0ZXJNYW5hZ2VyLCBpbnB1dCwgb3V0cHV0LCBjbGVhck1vZGUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnVEaW1lbnNpb25zWzBdID0gaW5wdXQuZnJhbWUud2lkdGg7XG4gICAgdGhpcy51bmlmb3Jtcy51RGltZW5zaW9uc1sxXSA9IGlucHV0LmZyYW1lLmhlaWdodDtcbiAgICB0aGlzLnVuaWZvcm1zLnVTZWVkID0gdGhpcy5zZWVkO1xuICAgIGZpbHRlck1hbmFnZXIuYXBwbHlGaWx0ZXIodGhpcywgaW5wdXQsIG91dHB1dCwgY2xlYXJNb2RlKTtcbiAgfVxuICAvKipcbiAgICogVGhlIGFtb3VudCBvZiBzYXR1cmF0aW9uIG9mIHNlcGlhIGVmZmVjdCxcbiAgICogYSB2YWx1ZSBvZiBgMWAgaXMgbW9yZSBzYXR1cmF0aW9uIGFuZCBjbG9zZXIgdG8gYDBgIGlzIGxlc3MsIGFuZCBhIHZhbHVlIG9mIGAwYCBwcm9kdWNlcyBubyBzZXBpYSBlZmZlY3RcbiAgICogQGRlZmF1bHQgMC4zXG4gICAqL1xuICBnZXQgc2VwaWEoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMudVNlcGlhO1xuICB9XG4gIHNldCBzZXBpYSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMudVNlcGlhID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIE9wYWNpdHkvaW50ZW5zaXR5IG9mIHRoZSBub2lzZSBlZmZlY3QgYmV0d2VlbiBgMGAgYW5kIGAxYFxuICAgKiBAZGVmYXVsdCAwLjNcbiAgICovXG4gIGdldCBub2lzZSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy51Tm9pc2VbMF07XG4gIH1cbiAgc2V0IG5vaXNlKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy51Tm9pc2VbMF0gPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIHNpemUgb2YgdGhlIG5vaXNlIHBhcnRpY2xlc1xuICAgKiBAZGVmYXVsdCAxXG4gICAqL1xuICBnZXQgbm9pc2VTaXplKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnVOb2lzZVsxXTtcbiAgfVxuICBzZXQgbm9pc2VTaXplKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy51Tm9pc2VbMV0gPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogSG93IG9mdGVuIHNjcmF0Y2hlcyBhcHBlYXJcbiAgICogQGRlZmF1bHQgMC41XG4gICAqL1xuICBnZXQgc2NyYXRjaCgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy51U2NyYXRjaFswXTtcbiAgfVxuICBzZXQgc2NyYXRjaCh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMudVNjcmF0Y2hbMF0gPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGRlbnNpdHkgb2YgdGhlIG51bWJlciBvZiBzY3JhdGNoZXNcbiAgICogQGRlZmF1bHQgMC4zXG4gICAqL1xuICBnZXQgc2NyYXRjaERlbnNpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMudVNjcmF0Y2hbMV07XG4gIH1cbiAgc2V0IHNjcmF0Y2hEZW5zaXR5KHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy51U2NyYXRjaFsxXSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgd2lkdGggb2YgdGhlIHNjcmF0Y2hlc1xuICAgKiBAZGVmYXVsdCAxXG4gICAqL1xuICBnZXQgc2NyYXRjaFdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnVTY3JhdGNoWzJdO1xuICB9XG4gIHNldCBzY3JhdGNoV2lkdGgodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnVTY3JhdGNoWzJdID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSByYWRpdXMgb2YgdGhlIHZpZ25ldHRlIGVmZmVjdCwgc21hbGxlciB2YWx1ZXMgcHJvZHVjZXMgYSBzbWFsbGVyIHZpZ25ldHRlXG4gICAqIEBkZWZhdWx0IDAuM1xuICAgKi9cbiAgZ2V0IHZpZ25ldHRpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMudVZpZ25ldHRpbmdbMF07XG4gIH1cbiAgc2V0IHZpZ25ldHRpbmcodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnVWaWduZXR0aW5nWzBdID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIEFtb3VudCBvZiBvcGFjaXR5IG9uIHRoZSB2aWduZXR0ZVxuICAgKiBAZGVmYXVsdCAxXG4gICAqL1xuICBnZXQgdmlnbmV0dGluZ0FscGhhKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnVWaWduZXR0aW5nWzFdO1xuICB9XG4gIHNldCB2aWduZXR0aW5nQWxwaGEodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnVWaWduZXR0aW5nWzFdID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIEJsdXIgaW50ZW5zaXR5IG9mIHRoZSB2aWduZXR0ZVxuICAgKiBAZGVmYXVsdCAxXG4gICAqL1xuICBnZXQgdmlnbmV0dGluZ0JsdXIoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMudVZpZ25ldHRpbmdbMl07XG4gIH1cbiAgc2V0IHZpZ25ldHRpbmdCbHVyKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy51VmlnbmV0dGluZ1syXSA9IHZhbHVlO1xuICB9XG59O1xuLyoqIERlZmF1bHQgdmFsdWVzIGZvciBvcHRpb25zLiAqL1xuX19wdWJsaWNGaWVsZChfT2xkRmlsbUZpbHRlciwgXCJERUZBVUxUX09QVElPTlNcIiwge1xuICBzZXBpYTogMC4zLFxuICBub2lzZTogMC4zLFxuICBub2lzZVNpemU6IDEsXG4gIHNjcmF0Y2g6IDAuNSxcbiAgc2NyYXRjaERlbnNpdHk6IDAuMyxcbiAgc2NyYXRjaFdpZHRoOiAxLFxuICB2aWduZXR0aW5nOiAwLjMsXG4gIHZpZ25ldHRpbmdBbHBoYTogMSxcbiAgdmlnbmV0dGluZ0JsdXI6IDAuMyxcbiAgc2VlZDogMFxufSk7XG5sZXQgT2xkRmlsbUZpbHRlciA9IF9PbGRGaWxtRmlsdGVyO1xuXG5leHBvcnQgeyBPbGRGaWxtRmlsdGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1PbGRGaWxtRmlsdGVyLm1qcy5tYXBcbiIsInZhciBzb3VyY2UgPSBcInN0cnVjdCBPbGRGaWxtVW5pZm9ybXMge1xcbiAgICB1U2VwaWE6IGYzMixcXG4gICAgdU5vaXNlOiB2ZWMyPGYzMj4sXFxuICAgIHVTY3JhdGNoOiB2ZWMzPGYzMj4sXFxuICAgIHVWaWduZXR0aW5nOiB2ZWMzPGYzMj4sXFxuICAgIHVTZWVkOiBmMzIsXFxuICAgIHVEaW1lbnNpb25zOiB2ZWMyPGYzMj4sXFxufTtcXG5cXG5zdHJ1Y3QgR2xvYmFsRmlsdGVyVW5pZm9ybXMge1xcbiAgdUlucHV0U2l6ZTp2ZWM0PGYzMj4sXFxuICB1SW5wdXRQaXhlbDp2ZWM0PGYzMj4sXFxuICB1SW5wdXRDbGFtcDp2ZWM0PGYzMj4sXFxuICB1T3V0cHV0RnJhbWU6dmVjNDxmMzI+LFxcbiAgdUdsb2JhbEZyYW1lOnZlYzQ8ZjMyPixcXG4gIHVPdXRwdXRUZXh0dXJlOnZlYzQ8ZjMyPixcXG59O1xcblxcbkBncm91cCgwKSBAYmluZGluZygwKSB2YXI8dW5pZm9ybT4gZ2Z1OiBHbG9iYWxGaWx0ZXJVbmlmb3JtcztcXG5cXG5AZ3JvdXAoMCkgQGJpbmRpbmcoMSkgdmFyIHVUZXh0dXJlOiB0ZXh0dXJlXzJkPGYzMj47IFxcbkBncm91cCgwKSBAYmluZGluZygyKSB2YXIgdVNhbXBsZXI6IHNhbXBsZXI7XFxuQGdyb3VwKDEpIEBiaW5kaW5nKDApIHZhcjx1bmlmb3JtPiBvbGRGaWxtVW5pZm9ybXMgOiBPbGRGaWxtVW5pZm9ybXM7XFxuXFxuQGZyYWdtZW50XFxuZm4gbWFpbkZyYWdtZW50KFxcbiAgQGJ1aWx0aW4ocG9zaXRpb24pIHBvc2l0aW9uOiB2ZWM0PGYzMj4sXFxuICBAbG9jYXRpb24oMCkgdXYgOiB2ZWMyPGYzMj5cXG4pIC0+IEBsb2NhdGlvbigwKSB2ZWM0PGYzMj4ge1xcbiAgdmFyIGNvbG9yOiB2ZWM0PGYzMj4gPSB0ZXh0dXJlU2FtcGxlKHVUZXh0dXJlLCB1U2FtcGxlciwgdXYpO1xcblxcbiAgaWYgKG9sZEZpbG1Vbmlmb3Jtcy51U2VwaWEgPiAwLilcXG4gIHtcXG4gICAgY29sb3IgPSB2ZWM0PGYzMj4oc2VwaWEoY29sb3IucmdiKSwgY29sb3IuYSk7XFxuICB9XFxuXFxuICBsZXQgY29vcmQ6IHZlYzI8ZjMyPiA9IHV2ICogZ2Z1LnVJbnB1dFNpemUueHkgLyBvbGRGaWxtVW5pZm9ybXMudURpbWVuc2lvbnM7XFxuXFxuICBpZiAob2xkRmlsbVVuaWZvcm1zLnVWaWduZXR0aW5nWzBdID4gMC4pXFxuICB7XFxuICAgIGNvbG9yICo9IHZlYzQ8ZjMyPih2ZWMzPGYzMj4odmlnbmV0dGUoY29sb3IucmdiLCBjb29yZCkpLCBjb2xvci5hKTtcXG4gIH1cXG5cXG4gIGxldCB1U2NyYXRjaCA9IG9sZEZpbG1Vbmlmb3Jtcy51U2NyYXRjaDsgXFxuXFxuICBpZiAodVNjcmF0Y2hbMV0gPiBvbGRGaWxtVW5pZm9ybXMudVNlZWQgJiYgdVNjcmF0Y2hbMF0gIT0gMC4pXFxuICB7XFxuICAgIGNvbG9yID0gdmVjNDxmMzI+KHNjcmF0Y2goY29sb3IucmdiLCBjb29yZCksIGNvbG9yLmEpO1xcbiAgfVxcblxcbiAgbGV0IHVOb2lzZSA9IG9sZEZpbG1Vbmlmb3Jtcy51Tm9pc2U7XFxuXFxuICBpZiAodU5vaXNlWzBdID4gMC4wICYmIHVOb2lzZVsxXSA+IDAuMClcXG4gIHtcXG4gICAgY29sb3IgKz0gdmVjNDxmMzI+KHZlYzM8ZjMyPihub2lzZSh1dikpLCBjb2xvci5hKTtcXG4gIH1cXG5cXG4gIHJldHVybiBjb2xvcjtcXG59XFxuXFxuY29uc3QgU1FSVF8yOiBmMzIgPSAxLjQxNDIxMztcXG5jb25zdCBTRVBJQV9SR0I6IHZlYzM8ZjMyPiA9IHZlYzM8ZjMyPigxMTIuMCAvIDI1NS4wLCA2Ni4wIC8gMjU1LjAsIDIwLjAgLyAyNTUuMCk7XFxuXFxuZm4gbW9kdWxvKHg6IGYzMiwgeTogZjMyKSAtPiBmMzJcXG57XFxuICByZXR1cm4geCAtIHkgKiBmbG9vcih4L3kpO1xcbn1cXG5cXG5mbiByYW5kKGNvOiB2ZWMyPGYzMj4pIC0+IGYzMlxcbntcXG4gIHJldHVybiBmcmFjdChzaW4oZG90KGNvLCB2ZWMyPGYzMj4oMTIuOTg5OCwgNzguMjMzKSkpICogNDM3NTguNTQ1Myk7XFxufVxcblxcbmZuIG92ZXJsYXkoc3JjOiB2ZWMzPGYzMj4sIGRzdDogdmVjMzxmMzI+KSAtPiB2ZWMzPGYzMj5cXG57XFxuICAgIC8vIGlmIChkc3QgPD0gMC41KSB0aGVuOiAyICogc3JjICogZHN0XFxuICAgIC8vIGlmIChkc3QgPiAwLjUpIHRoZW46IDEgLSAyICogKDEgLSBkc3QpICogKDEgLSBzcmMpXFxuXFxuICAgIHJldHVybiB2ZWMzPGYzMj4oXFxuICAgICAgc2VsZWN0KCgxLjAgLSAyLjAgKiAoMS4wIC0gZHN0LngpICogKDEuMCAtIHNyYy54KSksICgyLjAgKiBzcmMueCAqIGRzdC54KSwgKGRzdC54IDw9IDAuNSkpLCBcXG4gICAgICBzZWxlY3QoKDEuMCAtIDIuMCAqICgxLjAgLSBkc3QueSkgKiAoMS4wIC0gc3JjLnkpKSwgKDIuMCAqIHNyYy55ICogZHN0LnkpLCAoZHN0LnkgPD0gMC41KSksXFxuICAgICAgc2VsZWN0KCgxLjAgLSAyLjAgKiAoMS4wIC0gZHN0LnopICogKDEuMCAtIHNyYy56KSksICgyLjAgKiBzcmMueiAqIGRzdC56KSwgKGRzdC56IDw9IDAuNSkpXFxuICAgICk7XFxufVxcblxcbmZuIHNlcGlhKGNvOiB2ZWMzPGYzMj4pIC0+IHZlYzM8ZjMyPlxcbntcXG4gIGxldCBncmF5OiBmMzIgPSAoY28ueCArIGNvLnkgKyBjby56KSAvIDMuMDtcXG4gIGxldCBncmF5c2NhbGU6IHZlYzM8ZjMyPiA9IHZlYzM8ZjMyPihncmF5KTtcXG4gIGxldCBjb2xvciA9IG92ZXJsYXkoU0VQSUFfUkdCLCBncmF5c2NhbGUpO1xcbiAgcmV0dXJuIGdyYXlzY2FsZSArIG9sZEZpbG1Vbmlmb3Jtcy51U2VwaWEgKiAoY29sb3IgLSBncmF5c2NhbGUpO1xcbn1cXG5cXG5mbiB2aWduZXR0ZShjbzogdmVjMzxmMzI+LCBjb29yZDogdmVjMjxmMzI+KSAtPiBmMzJcXG57XFxuICBsZXQgdVZpZ25ldHRpbmcgPSBvbGRGaWxtVW5pZm9ybXMudVZpZ25ldHRpbmc7XFxuICBsZXQgdURpbWVuc2lvbnMgPSBvbGRGaWxtVW5pZm9ybXMudURpbWVuc2lvbnM7XFxuICBcXG4gIGxldCBvdXR0ZXI6IGYzMiA9IFNRUlRfMiAtIHVWaWduZXR0aW5nWzBdICogU1FSVF8yO1xcbiAgdmFyIGRpcjogdmVjMjxmMzI+ID0gdmVjMjxmMzI+KHZlYzI8ZjMyPigwLjUpIC0gY29vcmQpO1xcbiAgZGlyLnkgKj0gdURpbWVuc2lvbnMueSAvIHVEaW1lbnNpb25zLng7XFxuICBsZXQgZGFya2VyOiBmMzIgPSBjbGFtcCgob3V0dGVyIC0gbGVuZ3RoKGRpcikgKiBTUVJUXzIpIC8gKCAwLjAwMDAxICsgdVZpZ25ldHRpbmdbMl0gKiBTUVJUXzIpLCAwLjAsIDEuMCk7XFxuICByZXR1cm4gZGFya2VyICsgKDEuMCAtIGRhcmtlcikgKiAoMS4wIC0gdVZpZ25ldHRpbmdbMV0pO1xcbn1cXG5cXG5mbiBzY3JhdGNoKGNvOiB2ZWMzPGYzMj4sIGNvb3JkOiB2ZWMyPGYzMj4pIC0+IHZlYzM8ZjMyPlxcbntcXG4gIHZhciBjb2xvciA9IGNvO1xcbiAgbGV0IHVTY3JhdGNoID0gb2xkRmlsbVVuaWZvcm1zLnVTY3JhdGNoO1xcbiAgbGV0IHVTZWVkID0gb2xkRmlsbVVuaWZvcm1zLnVTZWVkO1xcbiAgbGV0IHVEaW1lbnNpb25zID0gb2xkRmlsbVVuaWZvcm1zLnVEaW1lbnNpb25zO1xcblxcbiAgbGV0IHBoYXNlOiBmMzIgPSB1U2VlZCAqIDI1Ni4wO1xcbiAgbGV0IHM6IGYzMiA9IG1vZHVsbyhmbG9vcihwaGFzZSksIDIuMCk7XFxuICBsZXQgZGlzdDogZjMyID0gMS4wIC8gdVNjcmF0Y2hbMV07XFxuICBsZXQgZDogZjMyID0gZGlzdGFuY2UoY29vcmQsIHZlYzI8ZjMyPih1U2VlZCAqIGRpc3QsIGFicyhzIC0gdVNlZWQgKiBkaXN0KSkpO1xcblxcbiAgaWYgKGQgPCB1U2VlZCAqIDAuNiArIDAuNClcXG4gIHtcXG4gICAgbGV0IHBlcmlvZDogZjMyID0gdVNjcmF0Y2hbMV0gKiAxMC4wO1xcblxcbiAgICBsZXQgeHg6IGYzMiA9IGNvb3JkLnggKiBwZXJpb2QgKyBwaGFzZTtcXG4gICAgbGV0IGFhOiBmMzIgPSBhYnMobW9kdWxvKHh4LCAwLjUpICogNC4wKTtcXG4gICAgbGV0IGJiOiBmMzIgPSBtb2R1bG8oZmxvb3IoeHggLyAwLjUpLCAyLjApO1xcbiAgICBsZXQgeXk6IGYzMiA9ICgxLjAgLSBiYikgKiBhYSArIGJiICogKDIuMCAtIGFhKTtcXG5cXG4gICAgbGV0IGtrOiBmMzIgPSAyLjAgKiBwZXJpb2Q7XFxuICAgIGxldCBkdzogZjMyID0gdVNjcmF0Y2hbMl0gLyB1RGltZW5zaW9ucy54ICogKDAuNzUgKyB1U2VlZCk7XFxuICAgIGxldCBkaDogZjMyID0gZHcgKiBraztcXG5cXG4gICAgdmFyIHRpbmU6IGYzMiA9ICh5eSAtICgyLjAgLSBkaCkpO1xcblxcbiAgICBpZiAodGluZSA+IDAuMCkge1xcbiAgICAgICAgbGV0IF9zaWduOiBmMzIgPSBzaWduKHVTY3JhdGNoWzBdKTtcXG5cXG4gICAgICAgIHRpbmUgPSBzICogdGluZSAvIHBlcmlvZCArIHVTY3JhdGNoWzBdICsgMC4xO1xcbiAgICAgICAgdGluZSA9IGNsYW1wKHRpbmUgKyAxLjAsIDAuNSArIF9zaWduICogMC41LCAxLjUgKyBfc2lnbiAqIDAuNSk7XFxuXFxuICAgICAgICBjb2xvciAqPSB0aW5lO1xcbiAgICB9XFxuICB9XFxuXFxuICByZXR1cm4gY29sb3I7XFxufVxcblxcbmZuIG5vaXNlKGNvb3JkOiB2ZWMyPGYzMj4pIC0+IGYzMlxcbntcXG4gIGxldCB1Tm9pc2UgPSBvbGRGaWxtVW5pZm9ybXMudU5vaXNlO1xcbiAgbGV0IHVTZWVkID0gb2xkRmlsbVVuaWZvcm1zLnVTZWVkO1xcblxcbiAgdmFyIHBpeGVsQ29vcmQ6IHZlYzI8ZjMyPiA9IGNvb3JkICogZ2Z1LnVJbnB1dFNpemUueHk7XFxuICBwaXhlbENvb3JkLnggPSBmbG9vcihwaXhlbENvb3JkLnggLyB1Tm9pc2VbMV0pO1xcbiAgcGl4ZWxDb29yZC55ID0gZmxvb3IocGl4ZWxDb29yZC55IC8gdU5vaXNlWzFdKTtcXG4gIHJldHVybiAocmFuZChwaXhlbENvb3JkICogdU5vaXNlWzFdICogdVNlZWQpIC0gMC41KSAqIHVOb2lzZVswXTtcXG59XCI7XG5cbmV4cG9ydCB7IHNvdXJjZSBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vbGQtZmlsbS5tanMubWFwXG4iLCJ2YXIgZnJhZ21lbnQgPSBcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5pbiB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxub3V0IHZlYzQgZmluYWxDb2xvcjtcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG51bmlmb3JtIHZlYzIgdVRoaWNrbmVzcztcXG51bmlmb3JtIHZlYzMgdUNvbG9yO1xcbnVuaWZvcm0gZmxvYXQgdUFscGhhO1xcbnVuaWZvcm0gZmxvYXQgdUtub2Nrb3V0O1xcblxcbnVuaWZvcm0gdmVjNCB1SW5wdXRDbGFtcDtcXG5cXG5jb25zdCBmbG9hdCBET1VCTEVfUEkgPSAyLiAqIDMuMTQxNTkyNjUzNTg5NzkzMjM4NDYyNjQ7XFxuY29uc3QgZmxvYXQgQU5HTEVfU1RFUCA9ICR7QU5HTEVfU1RFUH07XFxuXFxuZmxvYXQgb3V0bGluZU1heEFscGhhQXRQb3ModmVjMiBwb3MpIHtcXG4gICAgaWYgKHVUaGlja25lc3MueCA9PSAwLiB8fCB1VGhpY2tuZXNzLnkgPT0gMC4pIHtcXG4gICAgICAgIHJldHVybiAwLjtcXG4gICAgfVxcblxcbiAgICB2ZWM0IGRpc3BsYWNlZENvbG9yO1xcbiAgICB2ZWMyIGRpc3BsYWNlZFBvcztcXG4gICAgZmxvYXQgbWF4QWxwaGEgPSAwLjtcXG5cXG4gICAgZm9yIChmbG9hdCBhbmdsZSA9IDAuOyBhbmdsZSA8PSBET1VCTEVfUEk7IGFuZ2xlICs9IEFOR0xFX1NURVApIHtcXG4gICAgICAgIGRpc3BsYWNlZFBvcy54ID0gdlRleHR1cmVDb29yZC54ICsgdVRoaWNrbmVzcy54ICogY29zKGFuZ2xlKTtcXG4gICAgICAgIGRpc3BsYWNlZFBvcy55ID0gdlRleHR1cmVDb29yZC55ICsgdVRoaWNrbmVzcy55ICogc2luKGFuZ2xlKTtcXG4gICAgICAgIGRpc3BsYWNlZENvbG9yID0gdGV4dHVyZSh1VGV4dHVyZSwgY2xhbXAoZGlzcGxhY2VkUG9zLCB1SW5wdXRDbGFtcC54eSwgdUlucHV0Q2xhbXAuencpKTtcXG4gICAgICAgIG1heEFscGhhID0gbWF4KG1heEFscGhhLCBkaXNwbGFjZWRDb2xvci5hKTtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gbWF4QWxwaGE7XFxufVxcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAgIHZlYzQgc291cmNlQ29sb3IgPSB0ZXh0dXJlKHVUZXh0dXJlLCB2VGV4dHVyZUNvb3JkKTtcXG4gICAgdmVjNCBjb250ZW50Q29sb3IgPSBzb3VyY2VDb2xvciAqIGZsb2F0KHVLbm9ja291dCA8IDAuNSk7XFxuICAgIGZsb2F0IG91dGxpbmVBbHBoYSA9IHVBbHBoYSAqIG91dGxpbmVNYXhBbHBoYUF0UG9zKHZUZXh0dXJlQ29vcmQueHkpICogKDEuLXNvdXJjZUNvbG9yLmEpO1xcbiAgICB2ZWM0IG91dGxpbmVDb2xvciA9IHZlYzQodmVjMyh1Q29sb3IpICogb3V0bGluZUFscGhhLCBvdXRsaW5lQWxwaGEpO1xcbiAgICBmaW5hbENvbG9yID0gY29udGVudENvbG9yICsgb3V0bGluZUNvbG9yO1xcbn1cXG5cIjtcblxuZXhwb3J0IHsgZnJhZ21lbnQgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b3V0bGluZS5tanMubWFwXG4iLCJpbXBvcnQgeyBGaWx0ZXIsIGRlcHJlY2F0aW9uLCBHcHVQcm9ncmFtLCBHbFByb2dyYW0sIENvbG9yIH0gZnJvbSAncGl4aS5qcyc7XG5pbXBvcnQgdmVydGV4IGZyb20gJy4uL2RlZmF1bHRzL2RlZmF1bHQyLm1qcyc7XG5pbXBvcnQgd2dzbFZlcnRleCBmcm9tICcuLi9kZWZhdWx0cy9kZWZhdWx0Lm1qcyc7XG5pbXBvcnQgZnJhZ21lbnQgZnJvbSAnLi9vdXRsaW5lLm1qcyc7XG5pbXBvcnQgc291cmNlIGZyb20gJy4vb3V0bGluZTIubWpzJztcblxudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuY29uc3QgX091dGxpbmVGaWx0ZXIgPSBjbGFzcyBfT3V0bGluZUZpbHRlciBleHRlbmRzIEZpbHRlciB7XG4gIC8qKiBAaWdub3JlICovXG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3NbMF0gPz8ge307XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcIm51bWJlclwiKSB7XG4gICAgICBkZXByZWNhdGlvbihcIjYuMC4wXCIsIFwiT3V0bGluZUZpbHRlciBjb25zdHJ1Y3RvciBwYXJhbXMgYXJlIG5vdyBvcHRpb25zIG9iamVjdC4gU2VlIHBhcmFtczogeyB0aGlja25lc3MsIGNvbG9yLCBxdWFsaXR5LCBhbHBoYSwga25vY2tvdXQgfVwiKTtcbiAgICAgIG9wdGlvbnMgPSB7IHRoaWNrbmVzczogb3B0aW9ucyB9O1xuICAgICAgaWYgKGFyZ3NbMV0gIT09IHZvaWQgMClcbiAgICAgICAgb3B0aW9ucy5jb2xvciA9IGFyZ3NbMV07XG4gICAgICBpZiAoYXJnc1syXSAhPT0gdm9pZCAwKVxuICAgICAgICBvcHRpb25zLnF1YWxpdHkgPSBhcmdzWzJdO1xuICAgICAgaWYgKGFyZ3NbM10gIT09IHZvaWQgMClcbiAgICAgICAgb3B0aW9ucy5hbHBoYSA9IGFyZ3NbM107XG4gICAgICBpZiAoYXJnc1s0XSAhPT0gdm9pZCAwKVxuICAgICAgICBvcHRpb25zLmtub2Nrb3V0ID0gYXJnc1s0XTtcbiAgICB9XG4gICAgb3B0aW9ucyA9IHsgLi4uX091dGxpbmVGaWx0ZXIuREVGQVVMVF9PUFRJT05TLCAuLi5vcHRpb25zIH07XG4gICAgY29uc3QgcXVhbGl0eSA9IG9wdGlvbnMucXVhbGl0eSA/PyAwLjE7XG4gICAgY29uc3QgZ3B1UHJvZ3JhbSA9IEdwdVByb2dyYW0uZnJvbSh7XG4gICAgICB2ZXJ0ZXg6IHtcbiAgICAgICAgc291cmNlOiB3Z3NsVmVydGV4LFxuICAgICAgICBlbnRyeVBvaW50OiBcIm1haW5WZXJ0ZXhcIlxuICAgICAgfSxcbiAgICAgIGZyYWdtZW50OiB7XG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgZW50cnlQb2ludDogXCJtYWluRnJhZ21lbnRcIlxuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGdsUHJvZ3JhbSA9IEdsUHJvZ3JhbS5mcm9tKHtcbiAgICAgIHZlcnRleCxcbiAgICAgIGZyYWdtZW50OiBmcmFnbWVudC5yZXBsYWNlKC9cXCRcXHtBTkdMRV9TVEVQXFx9LywgX091dGxpbmVGaWx0ZXIuZ2V0QW5nbGVTdGVwKHF1YWxpdHkpLnRvRml4ZWQoNykpLFxuICAgICAgbmFtZTogXCJvdXRsaW5lLWZpbHRlclwiXG4gICAgfSk7XG4gICAgc3VwZXIoe1xuICAgICAgZ3B1UHJvZ3JhbSxcbiAgICAgIGdsUHJvZ3JhbSxcbiAgICAgIHJlc291cmNlczoge1xuICAgICAgICBvdXRsaW5lVW5pZm9ybXM6IHtcbiAgICAgICAgICB1VGhpY2tuZXNzOiB7IHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KDIpLCB0eXBlOiBcInZlYzI8ZjMyPlwiIH0sXG4gICAgICAgICAgdUNvbG9yOiB7IHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KDMpLCB0eXBlOiBcInZlYzM8ZjMyPlwiIH0sXG4gICAgICAgICAgdUFscGhhOiB7IHZhbHVlOiBvcHRpb25zLmFscGhhLCB0eXBlOiBcImYzMlwiIH0sXG4gICAgICAgICAgdUFuZ2xlU3RlcDogeyB2YWx1ZTogMCwgdHlwZTogXCJmMzJcIiB9LFxuICAgICAgICAgIHVLbm9ja291dDogeyB2YWx1ZTogb3B0aW9ucy5rbm9ja291dCA/IDEgOiAwLCB0eXBlOiBcImYzMlwiIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ1bmlmb3Jtc1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX3RoaWNrbmVzc1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX3F1YWxpdHlcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9jb2xvclwiKTtcbiAgICB0aGlzLnVuaWZvcm1zID0gdGhpcy5yZXNvdXJjZXMub3V0bGluZVVuaWZvcm1zLnVuaWZvcm1zO1xuICAgIHRoaXMudW5pZm9ybXMudUFuZ2xlU3RlcCA9IF9PdXRsaW5lRmlsdGVyLmdldEFuZ2xlU3RlcChxdWFsaXR5KTtcbiAgICB0aGlzLl9jb2xvciA9IG5ldyBDb2xvcigpO1xuICAgIHRoaXMuY29sb3IgPSBvcHRpb25zLmNvbG9yID8/IDA7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogT3ZlcnJpZGUgZXhpc3RpbmcgYXBwbHkgbWV0aG9kIGluIGBGaWx0ZXJgXG4gICAqIEBvdmVycmlkZVxuICAgKiBAaWdub3JlXG4gICAqL1xuICBhcHBseShmaWx0ZXJNYW5hZ2VyLCBpbnB1dCwgb3V0cHV0LCBjbGVhck1vZGUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnVUaGlja25lc3NbMF0gPSB0aGlzLnRoaWNrbmVzcyAvIGlucHV0LnNvdXJjZS53aWR0aDtcbiAgICB0aGlzLnVuaWZvcm1zLnVUaGlja25lc3NbMV0gPSB0aGlzLnRoaWNrbmVzcyAvIGlucHV0LnNvdXJjZS5oZWlnaHQ7XG4gICAgZmlsdGVyTWFuYWdlci5hcHBseUZpbHRlcih0aGlzLCBpbnB1dCwgb3V0cHV0LCBjbGVhck1vZGUpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGFuZ2xlU3RlcCBieSBxdWFsaXR5XG4gICAqIEBwYXJhbSBxdWFsaXR5XG4gICAqL1xuICBzdGF0aWMgZ2V0QW5nbGVTdGVwKHF1YWxpdHkpIHtcbiAgICByZXR1cm4gcGFyc2VGbG9hdCgoTWF0aC5QSSAqIDIgLyBNYXRoLm1heChcbiAgICAgIHF1YWxpdHkgKiBfT3V0bGluZUZpbHRlci5NQVhfU0FNUExFUyxcbiAgICAgIF9PdXRsaW5lRmlsdGVyLk1JTl9TQU1QTEVTXG4gICAgKSkudG9GaXhlZCg3KSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSB0aGlja25lc3Mgb2YgdGhlIG91dGxpbmVcbiAgICogQGRlZmF1bHQgMVxuICAgKi9cbiAgZ2V0IHRoaWNrbmVzcygpIHtcbiAgICByZXR1cm4gdGhpcy5fdGhpY2tuZXNzO1xuICB9XG4gIHNldCB0aGlja25lc3ModmFsdWUpIHtcbiAgICB0aGlzLl90aGlja25lc3MgPSB0aGlzLnBhZGRpbmcgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGNvbG9yIHZhbHVlIG9mIHRoZSBhbWJpZW50IGNvbG9yXG4gICAqIEBleGFtcGxlIFsxLjAsIDEuMCwgMS4wXSA9IDB4ZmZmZmZmXG4gICAqIEBkZWZhdWx0IDB4MDAwMDAwXG4gICAqL1xuICBnZXQgY29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbG9yLnZhbHVlO1xuICB9XG4gIHNldCBjb2xvcih2YWx1ZSkge1xuICAgIHRoaXMuX2NvbG9yLnNldFZhbHVlKHZhbHVlKTtcbiAgICBjb25zdCBbciwgZywgYl0gPSB0aGlzLl9jb2xvci50b0FycmF5KCk7XG4gICAgdGhpcy51bmlmb3Jtcy51Q29sb3JbMF0gPSByO1xuICAgIHRoaXMudW5pZm9ybXMudUNvbG9yWzFdID0gZztcbiAgICB0aGlzLnVuaWZvcm1zLnVDb2xvclsyXSA9IGI7XG4gIH1cbiAgLyoqXG4gICAqIENvZWZmaWNpZW50IGZvciBhbHBoYSBtdWx0aXBsaWNhdGlvblxuICAgKiBAZGVmYXVsdCAxXG4gICAqL1xuICBnZXQgYWxwaGEoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMudUFscGhhO1xuICB9XG4gIHNldCBhbHBoYSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMudUFscGhhID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBxdWFsaXR5IG9mIHRoZSBvdXRsaW5lIGZyb20gYDBgIHRvIGAxYC5cbiAgICogVXNpbmcgYSBoaWdoZXIgcXVhbGl0eSBzZXR0aW5nIHdpbGwgcmVzdWx0IGluIG1vcmUgYWNjdXJhY3kgYnV0IHNsb3dlciBwZXJmb3JtYW5jZVxuICAgKiBAZGVmYXVsdCAwLjFcbiAgICovXG4gIGdldCBxdWFsaXR5KCkge1xuICAgIHJldHVybiB0aGlzLl9xdWFsaXR5O1xuICB9XG4gIHNldCBxdWFsaXR5KHZhbHVlKSB7XG4gICAgdGhpcy5fcXVhbGl0eSA9IHZhbHVlO1xuICAgIHRoaXMudW5pZm9ybXMudUFuZ2xlU3RlcCA9IF9PdXRsaW5lRmlsdGVyLmdldEFuZ2xlU3RlcCh2YWx1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gb25seSByZW5kZXIgb3V0bGluZSwgbm90IHRoZSBjb250ZW50cy5cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGdldCBrbm9ja291dCgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy51S25vY2tvdXQgPT09IDE7XG4gIH1cbiAgc2V0IGtub2Nrb3V0KHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy51S25vY2tvdXQgPSB2YWx1ZSA/IDEgOiAwO1xuICB9XG59O1xuLyoqIERlZmF1bHQgdmFsdWVzIGZvciBvcHRpb25zLiAqL1xuX19wdWJsaWNGaWVsZChfT3V0bGluZUZpbHRlciwgXCJERUZBVUxUX09QVElPTlNcIiwge1xuICB0aGlja25lc3M6IDEsXG4gIGNvbG9yOiAwLFxuICBhbHBoYTogMSxcbiAgcXVhbGl0eTogMC4xLFxuICBrbm9ja291dDogZmFsc2Vcbn0pO1xuLyoqIFRoZSBtaW5pbXVtIG51bWJlciBvZiBzYW1wbGVzIGZvciByZW5kZXJpbmcgb3V0bGluZS4gKi9cbl9fcHVibGljRmllbGQoX091dGxpbmVGaWx0ZXIsIFwiTUlOX1NBTVBMRVNcIiwgMSk7XG4vKiogVGhlIG1heGltdW0gbnVtYmVyIG9mIHNhbXBsZXMgZm9yIHJlbmRlcmluZyBvdXRsaW5lLiAqL1xuX19wdWJsaWNGaWVsZChfT3V0bGluZUZpbHRlciwgXCJNQVhfU0FNUExFU1wiLCAxMDApO1xubGV0IE91dGxpbmVGaWx0ZXIgPSBfT3V0bGluZUZpbHRlcjtcblxuZXhwb3J0IHsgT3V0bGluZUZpbHRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T3V0bGluZUZpbHRlci5tanMubWFwXG4iLCJ2YXIgc291cmNlID0gXCJzdHJ1Y3QgT3V0bGluZVVuaWZvcm1zIHtcXG4gIHVUaGlja25lc3M6dmVjMjxmMzI+LFxcbiAgdUNvbG9yOnZlYzM8ZjMyPixcXG4gIHVBbHBoYTpmMzIsXFxuICB1QW5nbGVTdGVwOmYzMixcXG4gIHVLbm9ja291dDpmMzIsXFxufTtcXG5cXG5zdHJ1Y3QgR2xvYmFsRmlsdGVyVW5pZm9ybXMge1xcbiAgdUlucHV0U2l6ZTp2ZWM0PGYzMj4sXFxuICB1SW5wdXRQaXhlbDp2ZWM0PGYzMj4sXFxuICB1SW5wdXRDbGFtcDp2ZWM0PGYzMj4sXFxuICB1T3V0cHV0RnJhbWU6dmVjNDxmMzI+LFxcbiAgdUdsb2JhbEZyYW1lOnZlYzQ8ZjMyPixcXG4gIHVPdXRwdXRUZXh0dXJlOnZlYzQ8ZjMyPixcXG59O1xcblxcbkBncm91cCgwKSBAYmluZGluZygwKSB2YXI8dW5pZm9ybT4gZ2Z1OiBHbG9iYWxGaWx0ZXJVbmlmb3JtcztcXG5cXG5AZ3JvdXAoMCkgQGJpbmRpbmcoMSkgdmFyIHVUZXh0dXJlOiB0ZXh0dXJlXzJkPGYzMj47IFxcbkBncm91cCgwKSBAYmluZGluZygyKSB2YXIgdVNhbXBsZXI6IHNhbXBsZXI7XFxuQGdyb3VwKDEpIEBiaW5kaW5nKDApIHZhcjx1bmlmb3JtPiBvdXRsaW5lVW5pZm9ybXMgOiBPdXRsaW5lVW5pZm9ybXM7XFxuXFxuQGZyYWdtZW50XFxuZm4gbWFpbkZyYWdtZW50KFxcbiAgQGJ1aWx0aW4ocG9zaXRpb24pIHBvc2l0aW9uOiB2ZWM0PGYzMj4sXFxuICBAbG9jYXRpb24oMCkgdXYgOiB2ZWMyPGYzMj5cXG4pIC0+IEBsb2NhdGlvbigwKSB2ZWM0PGYzMj4ge1xcbiAgbGV0IHNvdXJjZUNvbG9yOiB2ZWM0PGYzMj4gPSB0ZXh0dXJlU2FtcGxlKHVUZXh0dXJlLCB1U2FtcGxlciwgdXYpO1xcbiAgbGV0IGNvbnRlbnRDb2xvcjogdmVjNDxmMzI+ID0gc291cmNlQ29sb3IgKiAoMS4gLSBvdXRsaW5lVW5pZm9ybXMudUtub2Nrb3V0KTtcXG4gIFxcbiAgbGV0IG91dGxpbmVBbHBoYTogZjMyID0gb3V0bGluZVVuaWZvcm1zLnVBbHBoYSAqIG91dGxpbmVNYXhBbHBoYUF0UG9zKHV2KSAqICgxLiAtIHNvdXJjZUNvbG9yLmEpO1xcbiAgbGV0IG91dGxpbmVDb2xvcjogdmVjNDxmMzI+ID0gdmVjNDxmMzI+KHZlYzM8ZjMyPihvdXRsaW5lVW5pZm9ybXMudUNvbG9yKSAqIG91dGxpbmVBbHBoYSwgb3V0bGluZUFscGhhKTtcXG4gIFxcbiAgcmV0dXJuIGNvbnRlbnRDb2xvciArIG91dGxpbmVDb2xvcjtcXG59XFxuXFxuZm4gb3V0bGluZU1heEFscGhhQXRQb3ModXY6IHZlYzI8ZjMyPikgLT4gZjMyIHtcXG4gIGxldCB0aGlja25lc3MgPSBvdXRsaW5lVW5pZm9ybXMudVRoaWNrbmVzcztcXG5cXG4gIGlmICh0aGlja25lc3MueCA9PSAwLiB8fCB0aGlja25lc3MueSA9PSAwLikge1xcbiAgICByZXR1cm4gMC47XFxuICB9XFxuICBcXG4gIGxldCBhbmdsZVN0ZXAgPSBvdXRsaW5lVW5pZm9ybXMudUFuZ2xlU3RlcDtcXG5cXG4gIHZhciBkaXNwbGFjZWRDb2xvcjogdmVjNDxmMzI+O1xcbiAgdmFyIGRpc3BsYWNlZFBvczogdmVjMjxmMzI+O1xcblxcbiAgdmFyIG1heEFscGhhOiBmMzIgPSAwLjtcXG4gIHZhciBkaXNwbGFjZWQ6IHZlYzI8ZjMyPjtcXG4gIHZhciBjdXJDb2xvcjogdmVjNDxmMzI+O1xcblxcbiAgZm9yICh2YXIgYW5nbGUgPSAwLjsgYW5nbGUgPD0gRE9VQkxFX1BJOyBhbmdsZSArPSBhbmdsZVN0ZXApXFxuICB7XFxuICAgIGRpc3BsYWNlZC54ID0gdXYueCArIHRoaWNrbmVzcy54ICogY29zKGFuZ2xlKTtcXG4gICAgZGlzcGxhY2VkLnkgPSB1di55ICsgdGhpY2tuZXNzLnkgKiBzaW4oYW5nbGUpO1xcbiAgICBjdXJDb2xvciA9IHRleHR1cmVTYW1wbGUodVRleHR1cmUsIHVTYW1wbGVyLCBjbGFtcChkaXNwbGFjZWQsIGdmdS51SW5wdXRDbGFtcC54eSwgZ2Z1LnVJbnB1dENsYW1wLnp3KSk7XFxuICAgIG1heEFscGhhID0gbWF4KG1heEFscGhhLCBjdXJDb2xvci5hKTtcXG4gIH1cXG5cXG4gIHJldHVybiBtYXhBbHBoYTtcXG59XFxuXFxuY29uc3QgRE9VQkxFX1BJOiBmMzIgPSAzLjE0MTU5MjY1MzU4OTc5MzIzODQ2MjY0ICogMi47XCI7XG5cbmV4cG9ydCB7IHNvdXJjZSBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vdXRsaW5lMi5tanMubWFwXG4iLCJpbXBvcnQgeyBGaWx0ZXIsIEdwdVByb2dyYW0sIEdsUHJvZ3JhbSwgUG9pbnQgfSBmcm9tICdwaXhpLmpzJztcbmltcG9ydCB2ZXJ0ZXggZnJvbSAnLi4vZGVmYXVsdHMvZGVmYXVsdDIubWpzJztcbmltcG9ydCB3Z3NsVmVydGV4IGZyb20gJy4uL2RlZmF1bHRzL2RlZmF1bHQubWpzJztcbmltcG9ydCBmcmFnbWVudCBmcm9tICcuL3BpeGVsYXRlMi5tanMnO1xuaW1wb3J0IHNvdXJjZSBmcm9tICcuL3BpeGVsYXRlLm1qcyc7XG5cbmNsYXNzIFBpeGVsYXRlRmlsdGVyIGV4dGVuZHMgRmlsdGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7UG9pbnR8QXJyYXk8bnVtYmVyPnxudW1iZXJ9IFtzaXplPTEwXSAtIEVpdGhlciB0aGUgd2lkdGgvaGVpZ2h0IG9mIHRoZSBzaXplIG9mIHRoZSBwaXhlbHMsIG9yIHNxdWFyZSBzaXplXG4gICAqL1xuICBjb25zdHJ1Y3RvcihzaXplID0gMTApIHtcbiAgICBjb25zdCBncHVQcm9ncmFtID0gR3B1UHJvZ3JhbS5mcm9tKHtcbiAgICAgIHZlcnRleDoge1xuICAgICAgICBzb3VyY2U6IHdnc2xWZXJ0ZXgsXG4gICAgICAgIGVudHJ5UG9pbnQ6IFwibWFpblZlcnRleFwiXG4gICAgICB9LFxuICAgICAgZnJhZ21lbnQ6IHtcbiAgICAgICAgc291cmNlLFxuICAgICAgICBlbnRyeVBvaW50OiBcIm1haW5GcmFnbWVudFwiXG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgZ2xQcm9ncmFtID0gR2xQcm9ncmFtLmZyb20oe1xuICAgICAgdmVydGV4LFxuICAgICAgZnJhZ21lbnQsXG4gICAgICBuYW1lOiBcInBpeGVsYXRlLWZpbHRlclwiXG4gICAgfSk7XG4gICAgc3VwZXIoe1xuICAgICAgZ3B1UHJvZ3JhbSxcbiAgICAgIGdsUHJvZ3JhbSxcbiAgICAgIHJlc291cmNlczoge1xuICAgICAgICBwaXhlbGF0ZVVuaWZvcm1zOiB7XG4gICAgICAgICAgdVNpemU6IHsgdmFsdWU6IG5ldyBGbG9hdDMyQXJyYXkoMiksIHR5cGU6IFwidmVjMjxmMzI+XCIgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIHNpemUgb2YgdGhlIHBpeGVsc1xuICAgKiBAZGVmYXVsdCBbMTAsMTBdXG4gICAqL1xuICBnZXQgc2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvdXJjZXMucGl4ZWxhdGVVbmlmb3Jtcy51bmlmb3Jtcy51U2l6ZTtcbiAgfVxuICBzZXQgc2l6ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFBvaW50KSB7XG4gICAgICB0aGlzLnNpemVYID0gdmFsdWUueDtcbiAgICAgIHRoaXMuc2l6ZVkgPSB2YWx1ZS55O1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHRoaXMucmVzb3VyY2VzLnBpeGVsYXRlVW5pZm9ybXMudW5pZm9ybXMudVNpemUgPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zaXplWCA9IHRoaXMuc2l6ZVkgPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICogVGhlIHNpemUgb2YgdGhlIHBpeGVscyBvbiB0aGUgYHhgIGF4aXNcbiAgKiBAZGVmYXVsdCAxMFxuICAqL1xuICBnZXQgc2l6ZVgoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb3VyY2VzLnBpeGVsYXRlVW5pZm9ybXMudW5pZm9ybXMudVNpemVbMF07XG4gIH1cbiAgc2V0IHNpemVYKHZhbHVlKSB7XG4gICAgdGhpcy5yZXNvdXJjZXMucGl4ZWxhdGVVbmlmb3Jtcy51bmlmb3Jtcy51U2l6ZVswXSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAqIFRoZSBzaXplIG9mIHRoZSBwaXhlbHMgb24gdGhlIGB5YCBheGlzXG4gICogQGRlZmF1bHQgMTBcbiAgKi9cbiAgZ2V0IHNpemVZKCkge1xuICAgIHJldHVybiB0aGlzLnJlc291cmNlcy5waXhlbGF0ZVVuaWZvcm1zLnVuaWZvcm1zLnVTaXplWzFdO1xuICB9XG4gIHNldCBzaXplWSh2YWx1ZSkge1xuICAgIHRoaXMucmVzb3VyY2VzLnBpeGVsYXRlVW5pZm9ybXMudW5pZm9ybXMudVNpemVbMV0gPSB2YWx1ZTtcbiAgfVxufVxuXG5leHBvcnQgeyBQaXhlbGF0ZUZpbHRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UGl4ZWxhdGVGaWx0ZXIubWpzLm1hcFxuIiwidmFyIGZyYWdtZW50ID0gXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuaW4gdmVjMiB2VGV4dHVyZUNvb3JkO1xcbm91dCB2ZWM0IGZpbmFsQ29sb3I7XFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxudW5pZm9ybSBmbG9hdCB1UmFkaWFuO1xcbnVuaWZvcm0gdmVjMiB1Q2VudGVyO1xcbnVuaWZvcm0gZmxvYXQgdVJhZGl1cztcXG51bmlmb3JtIGludCB1S2VybmVsU2l6ZTtcXG5cXG51bmlmb3JtIHZlYzQgdUlucHV0U2l6ZTtcXG5cXG5jb25zdCBpbnQgTUFYX0tFUk5FTF9TSVpFID0gMjA0ODtcXG5cXG52b2lkIG1haW4odm9pZClcXG57XFxuICAgIHZlYzQgY29sb3IgPSB0ZXh0dXJlKHVUZXh0dXJlLCB2VGV4dHVyZUNvb3JkKTtcXG5cXG4gICAgaWYgKHVLZXJuZWxTaXplID09IDApXFxuICAgIHtcXG4gICAgICAgIGZpbmFsQ29sb3IgPSBjb2xvcjtcXG4gICAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICBmbG9hdCBhc3BlY3QgPSB1SW5wdXRTaXplLnkgLyB1SW5wdXRTaXplLng7XFxuICAgIHZlYzIgY2VudGVyID0gdUNlbnRlci54eSAvIHVJbnB1dFNpemUueHk7XFxuICAgIGZsb2F0IGdyYWRpZW50ID0gdVJhZGl1cyAvIHVJbnB1dFNpemUueCAqIDAuMztcXG4gICAgZmxvYXQgcmFkaXVzID0gdVJhZGl1cyAvIHVJbnB1dFNpemUueCAtIGdyYWRpZW50ICogMC41O1xcbiAgICBpbnQgayA9IHVLZXJuZWxTaXplIC0gMTtcXG5cXG4gICAgdmVjMiBjb29yZCA9IHZUZXh0dXJlQ29vcmQ7XFxuICAgIHZlYzIgZGlyID0gdmVjMihjZW50ZXIgLSBjb29yZCk7XFxuICAgIGZsb2F0IGRpc3QgPSBsZW5ndGgodmVjMihkaXIueCwgZGlyLnkgKiBhc3BlY3QpKTtcXG5cXG4gICAgZmxvYXQgcmFkaWFuU3RlcCA9IHVSYWRpYW47XFxuICAgIGlmIChyYWRpdXMgPj0gMC4wICYmIGRpc3QgPiByYWRpdXMpIHtcXG4gICAgICAgIGZsb2F0IGRlbHRhID0gZGlzdCAtIHJhZGl1cztcXG4gICAgICAgIGZsb2F0IGdhcCA9IGdyYWRpZW50O1xcbiAgICAgICAgZmxvYXQgc2NhbGUgPSAxLjAgLSBhYnMoZGVsdGEgLyBnYXApO1xcbiAgICAgICAgaWYgKHNjYWxlIDw9IDAuMCkge1xcbiAgICAgICAgICAgIGZpbmFsQ29sb3IgPSBjb2xvcjtcXG4gICAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuICAgICAgICByYWRpYW5TdGVwICo9IHNjYWxlO1xcbiAgICB9XFxuICAgIHJhZGlhblN0ZXAgLz0gZmxvYXQoayk7XFxuXFxuICAgIGZsb2F0IHMgPSBzaW4ocmFkaWFuU3RlcCk7XFxuICAgIGZsb2F0IGMgPSBjb3MocmFkaWFuU3RlcCk7XFxuICAgIG1hdDIgcm90YXRpb25NYXRyaXggPSBtYXQyKHZlYzIoYywgLXMpLCB2ZWMyKHMsIGMpKTtcXG5cXG4gICAgZm9yKGludCBpID0gMDsgaSA8IE1BWF9LRVJORUxfU0laRSAtIDE7IGkrKykge1xcbiAgICAgICAgaWYgKGkgPT0gaykge1xcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgY29vcmQgLT0gY2VudGVyO1xcbiAgICAgICAgY29vcmQueSAqPSBhc3BlY3Q7XFxuICAgICAgICBjb29yZCA9IHJvdGF0aW9uTWF0cml4ICogY29vcmQ7XFxuICAgICAgICBjb29yZC55IC89IGFzcGVjdDtcXG4gICAgICAgIGNvb3JkICs9IGNlbnRlcjtcXG5cXG4gICAgICAgIHZlYzQgc2FtcGxlID0gdGV4dHVyZSh1VGV4dHVyZSwgY29vcmQpO1xcblxcbiAgICAgICAgLy8gc3dpdGNoIHRvIHByZS1tdWx0aXBsaWVkIGFscGhhIHRvIGNvcnJlY3RseSBibHVyIHRyYW5zcGFyZW50IGltYWdlc1xcbiAgICAgICAgLy8gc2FtcGxlLnJnYiAqPSBzYW1wbGUuYTtcXG5cXG4gICAgICAgIGNvbG9yICs9IHNhbXBsZTtcXG4gICAgfVxcblxcbiAgICBmaW5hbENvbG9yID0gY29sb3IgLyBmbG9hdCh1S2VybmVsU2l6ZSk7XFxufVxcblwiO1xuXG5leHBvcnQgeyBmcmFnbWVudCBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yYWRpYWwtYmx1ci5tanMubWFwXG4iLCJpbXBvcnQgeyBGaWx0ZXIsIGRlcHJlY2F0aW9uLCBHcHVQcm9ncmFtLCBHbFByb2dyYW0gfSBmcm9tICdwaXhpLmpzJztcbmltcG9ydCB2ZXJ0ZXggZnJvbSAnLi4vZGVmYXVsdHMvZGVmYXVsdDIubWpzJztcbmltcG9ydCB3Z3NsVmVydGV4IGZyb20gJy4uL2RlZmF1bHRzL2RlZmF1bHQubWpzJztcbmltcG9ydCBmcmFnbWVudCBmcm9tICcuL3JhZGlhbC1ibHVyLm1qcyc7XG5pbXBvcnQgc291cmNlIGZyb20gJy4vcmFkaWFsLWJsdXIyLm1qcyc7XG5cbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbmNvbnN0IF9SYWRpYWxCbHVyRmlsdGVyID0gY2xhc3MgX1JhZGlhbEJsdXJGaWx0ZXIgZXh0ZW5kcyBGaWx0ZXIge1xuICAvKiogQGlnbm9yZSAqL1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmdzWzBdID8/IHt9O1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJudW1iZXJcIikge1xuICAgICAgZGVwcmVjYXRpb24oXCI2LjAuMFwiLCBcIlJhZGlhbEJsdXJGaWx0ZXIgY29uc3RydWN0b3IgcGFyYW1zIGFyZSBub3cgb3B0aW9ucyBvYmplY3QuIFNlZSBwYXJhbXM6IHsgYW5nbGUsIGNlbnRlciwga2VybmVsU2l6ZSwgcmFkaXVzIH1cIik7XG4gICAgICBvcHRpb25zID0geyBhbmdsZTogb3B0aW9ucyB9O1xuICAgICAgaWYgKGFyZ3NbMV0pIHtcbiAgICAgICAgY29uc3QgeCA9IFwieFwiIGluIGFyZ3NbMV0gPyBhcmdzWzFdLnggOiBhcmdzWzFdWzBdO1xuICAgICAgICBjb25zdCB5ID0gXCJ5XCIgaW4gYXJnc1sxXSA/IGFyZ3NbMV0ueSA6IGFyZ3NbMV1bMV07XG4gICAgICAgIG9wdGlvbnMuY2VudGVyID0geyB4LCB5IH07XG4gICAgICB9XG4gICAgICBpZiAoYXJnc1syXSlcbiAgICAgICAgb3B0aW9ucy5rZXJuZWxTaXplID0gYXJnc1syXTtcbiAgICAgIGlmIChhcmdzWzNdKVxuICAgICAgICBvcHRpb25zLnJhZGl1cyA9IGFyZ3NbM107XG4gICAgfVxuICAgIG9wdGlvbnMgPSB7IC4uLl9SYWRpYWxCbHVyRmlsdGVyLkRFRkFVTFRfT1BUSU9OUywgLi4ub3B0aW9ucyB9O1xuICAgIGNvbnN0IGdwdVByb2dyYW0gPSBHcHVQcm9ncmFtLmZyb20oe1xuICAgICAgdmVydGV4OiB7XG4gICAgICAgIHNvdXJjZTogd2dzbFZlcnRleCxcbiAgICAgICAgZW50cnlQb2ludDogXCJtYWluVmVydGV4XCJcbiAgICAgIH0sXG4gICAgICBmcmFnbWVudDoge1xuICAgICAgICBzb3VyY2UsXG4gICAgICAgIGVudHJ5UG9pbnQ6IFwibWFpbkZyYWdtZW50XCJcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBnbFByb2dyYW0gPSBHbFByb2dyYW0uZnJvbSh7XG4gICAgICB2ZXJ0ZXgsXG4gICAgICBmcmFnbWVudCxcbiAgICAgIG5hbWU6IFwicmFkaWFsLWJsdXItZmlsdGVyXCJcbiAgICB9KTtcbiAgICBzdXBlcih7XG4gICAgICBncHVQcm9ncmFtLFxuICAgICAgZ2xQcm9ncmFtLFxuICAgICAgcmVzb3VyY2VzOiB7XG4gICAgICAgIHJhZGlhbEJsdXJVbmlmb3Jtczoge1xuICAgICAgICAgIHVSYWRpYW46IHsgdmFsdWU6IDAsIHR5cGU6IFwiZjMyXCIgfSxcbiAgICAgICAgICB1Q2VudGVyOiB7IHZhbHVlOiBvcHRpb25zLmNlbnRlciwgdHlwZTogXCJ2ZWMyPGYzMj5cIiB9LFxuICAgICAgICAgIHVLZXJuZWxTaXplOiB7IHZhbHVlOiBvcHRpb25zLmtlcm5lbFNpemUsIHR5cGU6IFwiaTMyXCIgfSxcbiAgICAgICAgICB1UmFkaXVzOiB7IHZhbHVlOiBvcHRpb25zLnJhZGl1cywgdHlwZTogXCJmMzJcIiB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidW5pZm9ybXNcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9hbmdsZVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX2tlcm5lbFNpemVcIik7XG4gICAgdGhpcy51bmlmb3JtcyA9IHRoaXMucmVzb3VyY2VzLnJhZGlhbEJsdXJVbmlmb3Jtcy51bmlmb3JtcztcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIG9wdGlvbnMpO1xuICB9XG4gIF91cGRhdGVLZXJuZWxTaXplKCkge1xuICAgIHRoaXMudW5pZm9ybXMudUtlcm5lbFNpemUgPSB0aGlzLl9hbmdsZSAhPT0gMCA/IHRoaXMua2VybmVsU2l6ZSA6IDA7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGFuZ2xlIGluIGRlZ3JlZXMgb2YgdGhlIG1vdGlvbiBmb3IgYmx1ciBlZmZlY3QuXG4gICAqIEBkZWZhdWx0IDBcbiAgICovXG4gIGdldCBhbmdsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYW5nbGU7XG4gIH1cbiAgc2V0IGFuZ2xlKHZhbHVlKSB7XG4gICAgdGhpcy5fYW5nbGUgPSB2YWx1ZTtcbiAgICB0aGlzLnVuaWZvcm1zLnVSYWRpYW4gPSB2YWx1ZSAqIE1hdGguUEkgLyAxODA7XG4gICAgdGhpcy5fdXBkYXRlS2VybmVsU2l6ZSgpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYHhgIGFuZCBgeWAgb2Zmc2V0IGNvb3JkaW5hdGVzIHRvIGNoYW5nZSB0aGUgcG9zaXRpb24gb2YgdGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlIG9mIGVmZmVjdC5cbiAgICogVGhpcyBzaG91bGQgYmUgYSBzaXplIDIgYXJyYXkgb3IgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYHhgIGFuZCBgeWAgdmFsdWVzLCB5b3UgY2Fubm90IGNoYW5nZSB0eXBlc1xuICAgKiBvbmNlIGRlZmluZWQgaW4gdGhlIGNvbnN0cnVjdG9yXG4gICAqIEBkZWZhdWx0IHt4OjAseTowfVxuICAgKi9cbiAgZ2V0IGNlbnRlcigpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy51Q2VudGVyO1xuICB9XG4gIHNldCBjZW50ZXIodmFsdWUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHZhbHVlID0geyB4OiB2YWx1ZVswXSwgeTogdmFsdWVbMV0gfTtcbiAgICB9XG4gICAgdGhpcy51bmlmb3Jtcy51Q2VudGVyID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHZlbG9jaXR5IG9mIHRoZSBtb3Rpb24gZm9yIGJsdXIgZWZmZWN0IG9uIHRoZSBgeGAgYXhpc1xuICAgKiBAZGVmYXVsdCAwXG4gICAqL1xuICBnZXQgY2VudGVyWCgpIHtcbiAgICByZXR1cm4gdGhpcy5jZW50ZXIueDtcbiAgfVxuICBzZXQgY2VudGVyWCh2YWx1ZSkge1xuICAgIHRoaXMuY2VudGVyLnggPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgdmVsb2NpdHkgb2YgdGhlIG1vdGlvbiBmb3IgYmx1ciBlZmZlY3Qgb24gdGhlIGB4YCBheGlzXG4gICAqIEBkZWZhdWx0IDBcbiAgICovXG4gIGdldCBjZW50ZXJZKCkge1xuICAgIHJldHVybiB0aGlzLmNlbnRlci55O1xuICB9XG4gIHNldCBjZW50ZXJZKHZhbHVlKSB7XG4gICAgdGhpcy5jZW50ZXIueSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUga2VybmVsU2l6ZSBvZiB0aGUgYmx1ciBmaWx0ZXIuIE11c3QgYmUgb2RkIG51bWJlciA+PSAzXG4gICAqIEBkZWZhdWx0IDVcbiAgICovXG4gIGdldCBrZXJuZWxTaXplKCkge1xuICAgIHJldHVybiB0aGlzLl9rZXJuZWxTaXplO1xuICB9XG4gIHNldCBrZXJuZWxTaXplKHZhbHVlKSB7XG4gICAgdGhpcy5fa2VybmVsU2l6ZSA9IHZhbHVlO1xuICAgIHRoaXMuX3VwZGF0ZUtlcm5lbFNpemUoKTtcbiAgfVxuICAvKipcbiAgICogVGhlIG1heGltdW0gc2l6ZSBvZiB0aGUgYmx1ciByYWRpdXMsIGxlc3MgdGhhbiBgMGAgZXF1YXRlcyB0byBpbmZpbml0eVxuICAgKiBAZGVmYXVsdCAtMVxuICAgKi9cbiAgZ2V0IHJhZGl1cygpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy51UmFkaXVzO1xuICB9XG4gIHNldCByYWRpdXModmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnVSYWRpdXMgPSB2YWx1ZSA8IDAgfHwgdmFsdWUgPT09IEluZmluaXR5ID8gLTEgOiB2YWx1ZTtcbiAgfVxufTtcbi8qKiBEZWZhdWx0IHZhbHVlcyBmb3Igb3B0aW9ucy4gKi9cbl9fcHVibGljRmllbGQoX1JhZGlhbEJsdXJGaWx0ZXIsIFwiREVGQVVMVF9PUFRJT05TXCIsIHtcbiAgYW5nbGU6IDAsXG4gIGNlbnRlcjogeyB4OiAwLCB5OiAwIH0sXG4gIGtlcm5lbFNpemU6IDUsXG4gIHJhZGl1czogLTFcbn0pO1xubGV0IFJhZGlhbEJsdXJGaWx0ZXIgPSBfUmFkaWFsQmx1ckZpbHRlcjtcblxuZXhwb3J0IHsgUmFkaWFsQmx1ckZpbHRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmFkaWFsQmx1ckZpbHRlci5tanMubWFwXG4iLCJ2YXIgc291cmNlID0gXCJzdHJ1Y3QgUmFkaWFsQmx1clVuaWZvcm1zIHtcXG4gIHVSYWRpYW46IGYzMixcXG4gIHVDZW50ZXI6IHZlYzI8ZjMyPixcXG4gIHVLZXJuZWxTaXplOiBmMzIsXFxuICB1UmFkaXVzOiBmMzIsXFxufTtcXG5cXG5zdHJ1Y3QgR2xvYmFsRmlsdGVyVW5pZm9ybXMge1xcbiAgdUlucHV0U2l6ZTp2ZWM0PGYzMj4sXFxuICB1SW5wdXRQaXhlbDp2ZWM0PGYzMj4sXFxuICB1SW5wdXRDbGFtcDp2ZWM0PGYzMj4sXFxuICB1T3V0cHV0RnJhbWU6dmVjNDxmMzI+LFxcbiAgdUdsb2JhbEZyYW1lOnZlYzQ8ZjMyPixcXG4gIHVPdXRwdXRUZXh0dXJlOnZlYzQ8ZjMyPixcXG59O1xcblxcbkBncm91cCgwKSBAYmluZGluZygwKSB2YXI8dW5pZm9ybT4gZ2Z1OiBHbG9iYWxGaWx0ZXJVbmlmb3JtcztcXG5cXG5AZ3JvdXAoMCkgQGJpbmRpbmcoMSkgdmFyIHVUZXh0dXJlOiB0ZXh0dXJlXzJkPGYzMj47IFxcbkBncm91cCgwKSBAYmluZGluZygyKSB2YXIgdVNhbXBsZXI6IHNhbXBsZXI7XFxuQGdyb3VwKDEpIEBiaW5kaW5nKDApIHZhcjx1bmlmb3JtPiByYWRpYWxCbHVyVW5pZm9ybXMgOiBSYWRpYWxCbHVyVW5pZm9ybXM7XFxuXFxuQGZyYWdtZW50XFxuZm4gbWFpbkZyYWdtZW50KFxcbiAgQGJ1aWx0aW4ocG9zaXRpb24pIHBvc2l0aW9uOiB2ZWM0PGYzMj4sXFxuICBAbG9jYXRpb24oMCkgdXYgOiB2ZWMyPGYzMj5cXG4pIC0+IEBsb2NhdGlvbigwKSB2ZWM0PGYzMj4ge1xcbiAgbGV0IHVSYWRpYW4gPSByYWRpYWxCbHVyVW5pZm9ybXMudVJhZGlhbjtcXG4gIGxldCB1Q2VudGVyID0gcmFkaWFsQmx1clVuaWZvcm1zLnVDZW50ZXI7XFxuICBsZXQgdUtlcm5lbFNpemUgPSByYWRpYWxCbHVyVW5pZm9ybXMudUtlcm5lbFNpemU7XFxuICBsZXQgdVJhZGl1cyA9IHJhZGlhbEJsdXJVbmlmb3Jtcy51UmFkaXVzO1xcbiAgXFxuICB2YXIgcmV0dXJuQ29sb3JPbmx5ID0gZmFsc2U7XFxuXFxuICBpZiAodUtlcm5lbFNpemUgPT0gMClcXG4gIHtcXG4gICAgcmV0dXJuQ29sb3JPbmx5ID0gdHJ1ZTtcXG4gIH1cXG5cXG4gIGxldCBhc3BlY3Q6IGYzMiA9IGdmdS51SW5wdXRTaXplLnkgLyBnZnUudUlucHV0U2l6ZS54O1xcbiAgbGV0IGNlbnRlcjogdmVjMjxmMzI+ID0gdUNlbnRlci54eSAvIGdmdS51SW5wdXRTaXplLnh5O1xcbiAgbGV0IGdyYWRpZW50OiBmMzIgPSB1UmFkaXVzIC8gZ2Z1LnVJbnB1dFNpemUueCAqIDAuMztcXG4gIGxldCByYWRpdXM6IGYzMiA9IHVSYWRpdXMgLyBnZnUudUlucHV0U2l6ZS54IC0gZ3JhZGllbnQgKiAwLjU7XFxuICBsZXQgazogaTMyID0gaTMyKHVLZXJuZWxTaXplIC0gMSk7XFxuXFxuICB2YXIgY29vcmQ6IHZlYzI8ZjMyPiA9IHV2O1xcbiAgbGV0IGRpcjogdmVjMjxmMzI+ID0gdmVjMjxmMzI+KGNlbnRlciAtIGNvb3JkKTtcXG4gIGxldCBkaXN0OiBmMzIgPSBsZW5ndGgodmVjMjxmMzI+KGRpci54LCBkaXIueSAqIGFzcGVjdCkpO1xcblxcbiAgdmFyIHJhZGlhblN0ZXA6IGYzMiA9IHVSYWRpYW47XFxuICBcXG4gIGlmIChyYWRpdXMgPj0gMC4wICYmIGRpc3QgPiByYWRpdXMpXFxuICB7XFxuICAgIGxldCBkZWx0YTogZjMyID0gZGlzdCAtIHJhZGl1cztcXG4gICAgbGV0IGdhcDogZjMyID0gZ3JhZGllbnQ7XFxuICAgIGxldCBzY2FsZTogZjMyID0gMS4wIC0gYWJzKGRlbHRhIC8gZ2FwKTtcXG4gICAgaWYgKHNjYWxlIDw9IDAuMCkge1xcbiAgICAgIHJldHVybkNvbG9yT25seSA9IHRydWU7XFxuICAgIH1cXG4gICAgcmFkaWFuU3RlcCAqPSBzY2FsZTtcXG4gIH1cXG5cXG4gIHJhZGlhblN0ZXAgLz0gZjMyKGspO1xcblxcbiAgbGV0IHM6IGYzMiA9IHNpbihyYWRpYW5TdGVwKTtcXG4gIGxldCBjOiBmMzIgPSBjb3MocmFkaWFuU3RlcCk7XFxuICBsZXQgcm90YXRpb25NYXRyaXg6IG1hdDJ4MjxmMzI+ID0gbWF0MngyPGYzMj4odmVjMjxmMzI+KGMsIC1zKSwgdmVjMjxmMzI+KHMsIGMpKTtcXG4gIFxcbiAgdmFyIGNvbG9yOiB2ZWM0PGYzMj4gPSB0ZXh0dXJlU2FtcGxlKHVUZXh0dXJlLCB1U2FtcGxlciwgdXYpO1xcbiAgbGV0IGJhc2VDb2xvciA9IHZlYzQ8ZjMyPihjb2xvcik7XFxuXFxuICBsZXQgbWluSzogaTMyID0gbWluKGkzMih1S2VybmVsU2l6ZSkgLSAxLCBNQVhfS0VSTkVMX1NJWkUgLSAxKTtcXG5cXG4gIGZvcih2YXIgaTogaTMyID0gMDsgaSA8IG1pbks7IGkgKz0gMSkgXFxuICB7XFxuICAgIGNvb3JkIC09IGNlbnRlcjtcXG4gICAgY29vcmQueSAqPSBhc3BlY3Q7XFxuICAgIGNvb3JkID0gcm90YXRpb25NYXRyaXggKiBjb29yZDtcXG4gICAgY29vcmQueSAvPSBhc3BlY3Q7XFxuICAgIGNvb3JkICs9IGNlbnRlcjtcXG4gICAgbGV0IHNhbXBsZTogdmVjNDxmMzI+ID0gdGV4dHVyZVNhbXBsZSh1VGV4dHVyZSwgdVNhbXBsZXIsIGNvb3JkKTtcXG4gICAgLy8gc3dpdGNoIHRvIHByZS1tdWx0aXBsaWVkIGFscGhhIHRvIGNvcnJlY3RseSBibHVyIHRyYW5zcGFyZW50IGltYWdlc1xcbiAgICAvLyBzYW1wbGUucmdiICo9IHNhbXBsZS5hO1xcbiAgICBjb2xvciArPSBzYW1wbGU7XFxuICB9XFxuXFxuICByZXR1cm4gc2VsZWN0KGNvbG9yIC8gZjMyKHVLZXJuZWxTaXplKSwgYmFzZUNvbG9yLCByZXR1cm5Db2xvck9ubHkpO1xcbn1cXG5cXG5jb25zdCBNQVhfS0VSTkVMX1NJWkU6IGkzMiA9IDIwNDg7XCI7XG5cbmV4cG9ydCB7IHNvdXJjZSBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yYWRpYWwtYmx1cjIubWpzLm1hcFxuIiwidmFyIGZyYWdtZW50ID0gXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuaW4gdmVjMiB2VGV4dHVyZUNvb3JkO1xcbm91dCB2ZWM0IGZpbmFsQ29sb3I7XFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxudW5pZm9ybSBmbG9hdCB1TWlycm9yO1xcbnVuaWZvcm0gZmxvYXQgdUJvdW5kYXJ5O1xcbnVuaWZvcm0gdmVjMiB1QW1wbGl0dWRlO1xcbnVuaWZvcm0gdmVjMiB1V2F2ZWxlbmd0aDtcXG51bmlmb3JtIHZlYzIgdUFscGhhO1xcbnVuaWZvcm0gZmxvYXQgdVRpbWU7XFxudW5pZm9ybSB2ZWMyIHVEaW1lbnNpb25zO1xcblxcbnVuaWZvcm0gdmVjNCB1SW5wdXRTaXplO1xcbnVuaWZvcm0gdmVjNCB1SW5wdXRDbGFtcDtcXG5cXG5mbG9hdCByYW5kKHZlYzIgY28pIHtcXG4gICAgcmV0dXJuIGZyYWN0KHNpbihkb3QoY28ueHksIHZlYzIoMTIuOTg5OCwgNzguMjMzKSkpICogNDM3NTguNTQ1Myk7XFxufVxcblxcbnZvaWQgbWFpbih2b2lkKVxcbntcXG4gICAgdmVjMiBwaXhlbENvb3JkID0gdlRleHR1cmVDb29yZC54eSAqIHVJbnB1dFNpemUueHk7XFxuICAgIHZlYzIgY29vcmQgPSBwaXhlbENvb3JkIC8gdURpbWVuc2lvbnM7XFxuXFxuICAgIGlmIChjb29yZC55IDwgdUJvdW5kYXJ5KSB7XFxuICAgICAgICBmaW5hbENvbG9yID0gdGV4dHVyZSh1VGV4dHVyZSwgdlRleHR1cmVDb29yZCk7XFxuICAgICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgZmxvYXQgayA9IChjb29yZC55IC0gdUJvdW5kYXJ5KSAvICgxLiAtIHVCb3VuZGFyeSArIDAuMDAwMSk7XFxuICAgIGZsb2F0IGFyZWFZID0gdUJvdW5kYXJ5ICogdURpbWVuc2lvbnMueSAvIHVJbnB1dFNpemUueTtcXG4gICAgZmxvYXQgdiA9IGFyZWFZICsgYXJlYVkgLSB2VGV4dHVyZUNvb3JkLnk7XFxuICAgIGZsb2F0IHkgPSB1TWlycm9yID4gMC41ID8gdiA6IHZUZXh0dXJlQ29vcmQueTtcXG5cXG4gICAgZmxvYXQgX2FtcGxpdHVkZSA9ICgodUFtcGxpdHVkZS55IC0gdUFtcGxpdHVkZS54KSAqIGsgKyB1QW1wbGl0dWRlLnggKSAvIHVJbnB1dFNpemUueDtcXG4gICAgZmxvYXQgX3dhdmVMZW5ndGggPSAoKHVXYXZlbGVuZ3RoLnkgLSB1V2F2ZWxlbmd0aC54KSAqIGsgKyB1V2F2ZWxlbmd0aC54KSAvIHVJbnB1dFNpemUueTtcXG4gICAgZmxvYXQgX2FscGhhID0gKHVBbHBoYS55IC0gdUFscGhhLngpICogayArIHVBbHBoYS54O1xcblxcbiAgICBmbG9hdCB4ID0gdlRleHR1cmVDb29yZC54ICsgY29zKHYgKiA2LjI4IC8gX3dhdmVMZW5ndGggLSB1VGltZSkgKiBfYW1wbGl0dWRlO1xcbiAgICB4ID0gY2xhbXAoeCwgdUlucHV0Q2xhbXAueCwgdUlucHV0Q2xhbXAueik7XFxuXFxuICAgIHZlYzQgY29sb3IgPSB0ZXh0dXJlKHVUZXh0dXJlLCB2ZWMyKHgsIHkpKTtcXG5cXG4gICAgZmluYWxDb2xvciA9IGNvbG9yICogX2FscGhhO1xcbn1cXG5cIjtcblxuZXhwb3J0IHsgZnJhZ21lbnQgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVmbGVjdGlvbi5tanMubWFwXG4iLCJpbXBvcnQgeyBGaWx0ZXIsIEdwdVByb2dyYW0sIEdsUHJvZ3JhbSB9IGZyb20gJ3BpeGkuanMnO1xuaW1wb3J0IHZlcnRleCBmcm9tICcuLi9kZWZhdWx0cy9kZWZhdWx0Mi5tanMnO1xuaW1wb3J0IHdnc2xWZXJ0ZXggZnJvbSAnLi4vZGVmYXVsdHMvZGVmYXVsdC5tanMnO1xuaW1wb3J0IGZyYWdtZW50IGZyb20gJy4vcmVmbGVjdGlvbi5tanMnO1xuaW1wb3J0IHNvdXJjZSBmcm9tICcuL3JlZmxlY3Rpb24yLm1qcyc7XG5cbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbmNvbnN0IF9SZWZsZWN0aW9uRmlsdGVyID0gY2xhc3MgX1JlZmxlY3Rpb25GaWx0ZXIgZXh0ZW5kcyBGaWx0ZXIge1xuICAvKipcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGZvciB0aGUgUmVmbGVjdGlvbkZpbHRlciBjb25zdHJ1Y3Rvci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0geyAuLi5fUmVmbGVjdGlvbkZpbHRlci5ERUZBVUxUX09QVElPTlMsIC4uLm9wdGlvbnMgfTtcbiAgICBjb25zdCBncHVQcm9ncmFtID0gR3B1UHJvZ3JhbS5mcm9tKHtcbiAgICAgIHZlcnRleDoge1xuICAgICAgICBzb3VyY2U6IHdnc2xWZXJ0ZXgsXG4gICAgICAgIGVudHJ5UG9pbnQ6IFwibWFpblZlcnRleFwiXG4gICAgICB9LFxuICAgICAgZnJhZ21lbnQ6IHtcbiAgICAgICAgc291cmNlLFxuICAgICAgICBlbnRyeVBvaW50OiBcIm1haW5GcmFnbWVudFwiXG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgZ2xQcm9ncmFtID0gR2xQcm9ncmFtLmZyb20oe1xuICAgICAgdmVydGV4LFxuICAgICAgZnJhZ21lbnQsXG4gICAgICBuYW1lOiBcInJlZmxlY3Rpb24tZmlsdGVyXCJcbiAgICB9KTtcbiAgICBzdXBlcih7XG4gICAgICBncHVQcm9ncmFtLFxuICAgICAgZ2xQcm9ncmFtLFxuICAgICAgcmVzb3VyY2VzOiB7XG4gICAgICAgIHJlZmxlY3Rpb25Vbmlmb3Jtczoge1xuICAgICAgICAgIHVNaXJyb3I6IHsgdmFsdWU6IG9wdGlvbnMubWlycm9yID8gMSA6IDAsIHR5cGU6IFwiZjMyXCIgfSxcbiAgICAgICAgICB1Qm91bmRhcnk6IHsgdmFsdWU6IG9wdGlvbnMuYm91bmRhcnksIHR5cGU6IFwiZjMyXCIgfSxcbiAgICAgICAgICB1QW1wbGl0dWRlOiB7IHZhbHVlOiBvcHRpb25zLmFtcGxpdHVkZSwgdHlwZTogXCJ2ZWMyPGYzMj5cIiB9LFxuICAgICAgICAgIHVXYXZlbGVuZ3RoOiB7IHZhbHVlOiBvcHRpb25zLndhdmVMZW5ndGgsIHR5cGU6IFwidmVjMjxmMzI+XCIgfSxcbiAgICAgICAgICB1QWxwaGE6IHsgdmFsdWU6IG9wdGlvbnMuYWxwaGEsIHR5cGU6IFwidmVjMjxmMzI+XCIgfSxcbiAgICAgICAgICB1VGltZTogeyB2YWx1ZTogb3B0aW9ucy50aW1lLCB0eXBlOiBcImYzMlwiIH0sXG4gICAgICAgICAgdURpbWVuc2lvbnM6IHsgdmFsdWU6IG5ldyBGbG9hdDMyQXJyYXkoMiksIHR5cGU6IFwidmVjMjxmMzI+XCIgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInVuaWZvcm1zXCIpO1xuICAgIC8qKlxuICAgICAqIFRpbWUgZm9yIGFuaW1hdGluZyBwb3NpdGlvbiBvZiB3YXZlc1xuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidGltZVwiLCAwKTtcbiAgICB0aGlzLnVuaWZvcm1zID0gdGhpcy5yZXNvdXJjZXMucmVmbGVjdGlvblVuaWZvcm1zLnVuaWZvcm1zO1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywgb3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIE92ZXJyaWRlIGV4aXN0aW5nIGFwcGx5IG1ldGhvZCBpbiBgRmlsdGVyYFxuICAgKiBAb3ZlcnJpZGVcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgYXBwbHkoZmlsdGVyTWFuYWdlciwgaW5wdXQsIG91dHB1dCwgY2xlYXJNb2RlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy51RGltZW5zaW9uc1swXSA9IGlucHV0LmZyYW1lLndpZHRoO1xuICAgIHRoaXMudW5pZm9ybXMudURpbWVuc2lvbnNbMV0gPSBpbnB1dC5mcmFtZS5oZWlnaHQ7XG4gICAgdGhpcy51bmlmb3Jtcy51VGltZSA9IHRoaXMudGltZTtcbiAgICBmaWx0ZXJNYW5hZ2VyLmFwcGx5RmlsdGVyKHRoaXMsIGlucHV0LCBvdXRwdXQsIGNsZWFyTW9kZSk7XG4gIH1cbiAgLyoqXG4gICAqIGB0cnVlYCB0byByZWZsZWN0IHRoZSBpbWFnZSwgYGZhbHNlYCBmb3Igd2F2ZXMtb25seVxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICBnZXQgbWlycm9yKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnVNaXJyb3IgPiAwLjU7XG4gIH1cbiAgc2V0IG1pcnJvcih2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMudU1pcnJvciA9IHZhbHVlID8gMSA6IDA7XG4gIH1cbiAgLyoqXG4gICAqIFZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSByZWZsZWN0aW9uIHBvaW50LCBkZWZhdWx0IGlzIDUwJSAobWlkZGxlKVxuICAgKiBzbWFsbGVyIG51bWJlcnMgcHJvZHVjZSBhIGxhcmdlciByZWZsZWN0aW9uLCBsYXJnZXIgbnVtYmVycyBwcm9kdWNlIGEgc21hbGxlciByZWZsZWN0aW9uLlxuICAgKiBAZGVmYXVsdCAwLjVcbiAgICovXG4gIGdldCBib3VuZGFyeSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy51Qm91bmRhcnk7XG4gIH1cbiAgc2V0IGJvdW5kYXJ5KHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy51Qm91bmRhcnkgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU3RhcnRpbmcgYW5kIGVuZGluZyBhbXBsaXR1ZGUgb2Ygd2F2ZXNcbiAgICogQGRlZmF1bHQgWzAsMjBdXG4gICAqL1xuICBnZXQgYW1wbGl0dWRlKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMudW5pZm9ybXMudUFtcGxpdHVkZSk7XG4gIH1cbiAgc2V0IGFtcGxpdHVkZSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMudUFtcGxpdHVkZVswXSA9IHZhbHVlWzBdO1xuICAgIHRoaXMudW5pZm9ybXMudUFtcGxpdHVkZVsxXSA9IHZhbHVlWzFdO1xuICB9XG4gIC8qKlxuICAgKiBTdGFydGluZyBhbXBsaXR1ZGUgb2Ygd2F2ZXNcbiAgICogQGRlZmF1bHQgMFxuICAgKi9cbiAgZ2V0IGFtcGxpdHVkZVN0YXJ0KCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnVBbXBsaXR1ZGVbMF07XG4gIH1cbiAgc2V0IGFtcGxpdHVkZVN0YXJ0KHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy51QW1wbGl0dWRlWzBdID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFN0YXJ0aW5nIGFtcGxpdHVkZSBvZiB3YXZlc1xuICAgKiBAZGVmYXVsdCAyMFxuICAgKi9cbiAgZ2V0IGFtcGxpdHVkZUVuZCgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy51QW1wbGl0dWRlWzFdO1xuICB9XG4gIHNldCBhbXBsaXR1ZGVFbmQodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnVBbXBsaXR1ZGVbMV0gPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU3RhcnRpbmcgYW5kIGVuZGluZyBsZW5ndGggb2Ygd2F2ZXNcbiAgICogQGRlZmF1bHQgWzMwLDEwMF1cbiAgICovXG4gIGdldCB3YXZlTGVuZ3RoKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMudW5pZm9ybXMudVdhdmVsZW5ndGgpO1xuICB9XG4gIHNldCB3YXZlTGVuZ3RoKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy51V2F2ZWxlbmd0aFswXSA9IHZhbHVlWzBdO1xuICAgIHRoaXMudW5pZm9ybXMudVdhdmVsZW5ndGhbMV0gPSB2YWx1ZVsxXTtcbiAgfVxuICAvKipcbiAgICogU3RhcnRpbmcgd2F2ZWxlbmd0aCBvZiB3YXZlc1xuICAgKiBAZGVmYXVsdCAzMFxuICAgKi9cbiAgZ2V0IHdhdmVsZW5ndGhTdGFydCgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy51V2F2ZWxlbmd0aFswXTtcbiAgfVxuICBzZXQgd2F2ZWxlbmd0aFN0YXJ0KHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy51V2F2ZWxlbmd0aFswXSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTdGFydGluZyB3YXZlbGVuZ3RoIG9mIHdhdmVzXG4gICAqIEBkZWZhdWx0IDEwMFxuICAgKi9cbiAgZ2V0IHdhdmVsZW5ndGhFbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMudVdhdmVsZW5ndGhbMV07XG4gIH1cbiAgc2V0IHdhdmVsZW5ndGhFbmQodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnVXYXZlbGVuZ3RoWzFdID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFN0YXJ0aW5nIGFuZCBlbmRpbmcgYWxwaGEgdmFsdWVzXG4gICAqIEBkZWZhdWx0IFsxLDFdXG4gICAqL1xuICBnZXQgYWxwaGEoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy51bmlmb3Jtcy51QWxwaGEpO1xuICB9XG4gIHNldCBhbHBoYSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMudUFscGhhWzBdID0gdmFsdWVbMF07XG4gICAgdGhpcy51bmlmb3Jtcy51QWxwaGFbMV0gPSB2YWx1ZVsxXTtcbiAgfVxuICAvKipcbiAgICogU3RhcnRpbmcgd2F2ZWxlbmd0aCBvZiB3YXZlc1xuICAgKiBAZGVmYXVsdCAxXG4gICAqL1xuICBnZXQgYWxwaGFTdGFydCgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy51QWxwaGFbMF07XG4gIH1cbiAgc2V0IGFscGhhU3RhcnQodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnVBbHBoYVswXSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTdGFydGluZyB3YXZlbGVuZ3RoIG9mIHdhdmVzXG4gICAqIEBkZWZhdWx0IDFcbiAgICovXG4gIGdldCBhbHBoYUVuZCgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy51QWxwaGFbMV07XG4gIH1cbiAgc2V0IGFscGhhRW5kKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy51QWxwaGFbMV0gPSB2YWx1ZTtcbiAgfVxufTtcbi8qKiBEZWZhdWx0IHZhbHVlcyBmb3Igb3B0aW9ucy4gKi9cbl9fcHVibGljRmllbGQoX1JlZmxlY3Rpb25GaWx0ZXIsIFwiREVGQVVMVF9PUFRJT05TXCIsIHtcbiAgbWlycm9yOiB0cnVlLFxuICBib3VuZGFyeTogMC41LFxuICBhbXBsaXR1ZGU6IFswLCAyMF0sXG4gIHdhdmVMZW5ndGg6IFszMCwgMTAwXSxcbiAgYWxwaGE6IFsxLCAxXSxcbiAgdGltZTogMFxufSk7XG5sZXQgUmVmbGVjdGlvbkZpbHRlciA9IF9SZWZsZWN0aW9uRmlsdGVyO1xuXG5leHBvcnQgeyBSZWZsZWN0aW9uRmlsdGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZWZsZWN0aW9uRmlsdGVyLm1qcy5tYXBcbiIsInZhciBzb3VyY2UgPSBcInN0cnVjdCBSZWZsZWN0aW9uVW5pZm9ybXMge1xcbiAgdU1pcnJvcjogZjMyLFxcbiAgdUJvdW5kYXJ5OiBmMzIsXFxuICB1QW1wbGl0dWRlOiB2ZWMyPGYzMj4sXFxuICB1V2F2ZWxlbmd0aDogdmVjMjxmMzI+LFxcbiAgdUFscGhhOiB2ZWMyPGYzMj4sXFxuICB1VGltZTogZjMyLFxcbiAgdURpbWVuc2lvbnM6IHZlYzI8ZjMyPixcXG59O1xcblxcbnN0cnVjdCBHbG9iYWxGaWx0ZXJVbmlmb3JtcyB7XFxuICB1SW5wdXRTaXplOnZlYzQ8ZjMyPixcXG4gIHVJbnB1dFBpeGVsOnZlYzQ8ZjMyPixcXG4gIHVJbnB1dENsYW1wOnZlYzQ8ZjMyPixcXG4gIHVPdXRwdXRGcmFtZTp2ZWM0PGYzMj4sXFxuICB1R2xvYmFsRnJhbWU6dmVjNDxmMzI+LFxcbiAgdU91dHB1dFRleHR1cmU6dmVjNDxmMzI+LFxcbn07XFxuXFxuQGdyb3VwKDApIEBiaW5kaW5nKDApIHZhcjx1bmlmb3JtPiBnZnU6IEdsb2JhbEZpbHRlclVuaWZvcm1zO1xcblxcbkBncm91cCgwKSBAYmluZGluZygxKSB2YXIgdVRleHR1cmU6IHRleHR1cmVfMmQ8ZjMyPjsgXFxuQGdyb3VwKDApIEBiaW5kaW5nKDIpIHZhciB1U2FtcGxlcjogc2FtcGxlcjtcXG5AZ3JvdXAoMSkgQGJpbmRpbmcoMCkgdmFyPHVuaWZvcm0+IHJlZmxlY3Rpb25Vbmlmb3JtcyA6IFJlZmxlY3Rpb25Vbmlmb3JtcztcXG5cXG5AZnJhZ21lbnRcXG5mbiBtYWluRnJhZ21lbnQoXFxuICBAYnVpbHRpbihwb3NpdGlvbikgcG9zaXRpb246IHZlYzQ8ZjMyPixcXG4gIEBsb2NhdGlvbigwKSB1diA6IHZlYzI8ZjMyPlxcbikgLT4gQGxvY2F0aW9uKDApIHZlYzQ8ZjMyPiB7XFxuICBsZXQgdURpbWVuc2lvbnM6IHZlYzI8ZjMyPiA9IHJlZmxlY3Rpb25Vbmlmb3Jtcy51RGltZW5zaW9ucztcXG4gIGxldCB1Qm91bmRhcnk6IGYzMiA9IHJlZmxlY3Rpb25Vbmlmb3Jtcy51Qm91bmRhcnk7XFxuICBsZXQgdU1pcnJvcjogYm9vbCA9IHJlZmxlY3Rpb25Vbmlmb3Jtcy51TWlycm9yID4gMC41O1xcbiAgbGV0IHVBbXBsaXR1ZGU6IHZlYzI8ZjMyPiA9IHJlZmxlY3Rpb25Vbmlmb3Jtcy51QW1wbGl0dWRlO1xcbiAgbGV0IHVXYXZlbGVuZ3RoOiB2ZWMyPGYzMj4gPSByZWZsZWN0aW9uVW5pZm9ybXMudVdhdmVsZW5ndGg7XFxuICBsZXQgdUFscGhhOiB2ZWMyPGYzMj4gPSByZWZsZWN0aW9uVW5pZm9ybXMudUFscGhhO1xcbiAgbGV0IHVUaW1lOiBmMzIgPSByZWZsZWN0aW9uVW5pZm9ybXMudVRpbWU7XFxuXFxuICBsZXQgcGl4ZWxDb29yZDogdmVjMjxmMzI+ID0gdXYgKiBnZnUudUlucHV0U2l6ZS54eTtcXG4gIGxldCBjb29yZDogdmVjMjxmMzI+ID0gcGl4ZWxDb29yZCAvdURpbWVuc2lvbnM7XFxuICB2YXIgcmV0dXJuQ29sb3JPbmx5OiBib29sID0gZmFsc2U7XFxuXFxuICBpZiAoY29vcmQueSA8IHVCb3VuZGFyeSkge1xcbiAgICByZXR1cm5Db2xvck9ubHkgPSB0cnVlO1xcbiAgfVxcblxcbiAgbGV0IGs6IGYzMiA9IChjb29yZC55IC0gdUJvdW5kYXJ5KSAvICgxLiAtIHVCb3VuZGFyeSArIDAuMDAwMSk7XFxuICBsZXQgYXJlYVk6IGYzMiA9IHVCb3VuZGFyeSAqIHVEaW1lbnNpb25zLnkgLyBnZnUudUlucHV0U2l6ZS55O1xcbiAgbGV0IHY6IGYzMiA9IGFyZWFZICsgYXJlYVkgLSB1di55O1xcbiAgbGV0IHk6IGYzMiA9IHNlbGVjdCh1di55LCB2LCB1TWlycm9yKTtcXG5cXG4gIGxldCBhbXBsaXR1ZGU6IGYzMiA9ICgodUFtcGxpdHVkZS55IC0gdUFtcGxpdHVkZS54KSAqIGsgKyB1QW1wbGl0dWRlLnggKSAvIGdmdS51SW5wdXRTaXplLng7XFxuICBsZXQgd2F2ZUxlbmd0aDogZjMyID0gKCh1V2F2ZWxlbmd0aC55IC0gdVdhdmVsZW5ndGgueCkgKiBrICsgdVdhdmVsZW5ndGgueCkgLyBnZnUudUlucHV0U2l6ZS55O1xcbiAgbGV0IGFscGhhOiBmMzIgPSBzZWxlY3QoKHVBbHBoYS55IC0gdUFscGhhLngpICogayArIHVBbHBoYS54LCAxLiwgcmV0dXJuQ29sb3JPbmx5KTtcXG5cXG4gIHZhciB4OiBmMzIgPSB1di54ICsgY29zKHYgKiA2LjI4IC8gd2F2ZUxlbmd0aCAtIHVUaW1lKSAqIGFtcGxpdHVkZTtcXG4gIHggPSBjbGFtcCh4LCBnZnUudUlucHV0Q2xhbXAueCwgZ2Z1LnVJbnB1dENsYW1wLnopO1xcbiAgXFxuICByZXR1cm4gdGV4dHVyZVNhbXBsZSh1VGV4dHVyZSwgdVNhbXBsZXIsIHNlbGVjdCh2ZWMyPGYzMj4oeCwgeSksIHV2LCByZXR1cm5Db2xvck9ubHkpKSAqIGFscGhhO1xcbn1cXG5cXG5mbiByYW5kKGNvOiB2ZWMyPGYzMj4pIC0+IGYzMiBcXG57XFxuICByZXR1cm4gZnJhY3Qoc2luKGRvdChjby54eSwgdmVjMigxMi45ODk4LCA3OC4yMzMpKSkgKiA0Mzc1OC41NDUzKTtcXG59XCI7XG5cbmV4cG9ydCB7IHNvdXJjZSBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWZsZWN0aW9uMi5tanMubWFwXG4iLCJ2YXIgZnJhZ21lbnQgPSBcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5pbiB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxub3V0IHZlYzQgZmluYWxDb2xvcjtcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG51bmlmb3JtIHZlYzQgdUlucHV0U2l6ZTtcXG51bmlmb3JtIHZlYzIgdVJlZDtcXG51bmlmb3JtIHZlYzIgdUdyZWVuO1xcbnVuaWZvcm0gdmVjMiB1Qmx1ZTtcXG5cXG52b2lkIG1haW4odm9pZClcXG57XFxuICAgZmxvYXQgciA9IHRleHR1cmUodVRleHR1cmUsIHZUZXh0dXJlQ29vcmQgKyB1UmVkL3VJbnB1dFNpemUueHkpLnI7XFxuICAgZmxvYXQgZyA9IHRleHR1cmUodVRleHR1cmUsIHZUZXh0dXJlQ29vcmQgKyB1R3JlZW4vdUlucHV0U2l6ZS54eSkuZztcXG4gICBmbG9hdCBiID0gdGV4dHVyZSh1VGV4dHVyZSwgdlRleHR1cmVDb29yZCArIHVCbHVlL3VJbnB1dFNpemUueHkpLmI7XFxuICAgZmxvYXQgYSA9IHRleHR1cmUodVRleHR1cmUsIHZUZXh0dXJlQ29vcmQpLmE7XFxuICAgZmluYWxDb2xvciA9IHZlYzQociwgZywgYiwgYSk7XFxufVxcblwiO1xuXG5leHBvcnQgeyBmcmFnbWVudCBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZ2Itc3BsaXQubWpzLm1hcFxuIiwiaW1wb3J0IHsgRmlsdGVyLCBkZXByZWNhdGlvbiwgR3B1UHJvZ3JhbSwgR2xQcm9ncmFtIH0gZnJvbSAncGl4aS5qcyc7XG5pbXBvcnQgdmVydGV4IGZyb20gJy4uL2RlZmF1bHRzL2RlZmF1bHQyLm1qcyc7XG5pbXBvcnQgd2dzbFZlcnRleCBmcm9tICcuLi9kZWZhdWx0cy9kZWZhdWx0Lm1qcyc7XG5pbXBvcnQgZnJhZ21lbnQgZnJvbSAnLi9yZ2Itc3BsaXQubWpzJztcbmltcG9ydCBzb3VyY2UgZnJvbSAnLi9yZ2Itc3BsaXQyLm1qcyc7XG5cbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbmNvbnN0IF9SR0JTcGxpdEZpbHRlciA9IGNsYXNzIF9SR0JTcGxpdEZpbHRlciBleHRlbmRzIEZpbHRlciB7XG4gIC8qKiBAaWdub3JlICovXG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3NbMF0gPz8ge307XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucykgfHwgXCJ4XCIgaW4gb3B0aW9ucyAmJiBcInlcIiBpbiBvcHRpb25zKSB7XG4gICAgICBkZXByZWNhdGlvbihcIjYuMC4wXCIsIFwiUkdCU3BsaXRGaWx0ZXIgY29uc3RydWN0b3IgcGFyYW1zIGFyZSBub3cgb3B0aW9ucyBvYmplY3QuIFNlZSBwYXJhbXM6IHsgcmVkLCBncmVlbiwgYmx1ZSB9XCIpO1xuICAgICAgb3B0aW9ucyA9IHsgcmVkOiBvcHRpb25zIH07XG4gICAgICBpZiAoYXJnc1sxXSAhPT0gdm9pZCAwKVxuICAgICAgICBvcHRpb25zLmdyZWVuID0gYXJnc1sxXTtcbiAgICAgIGlmIChhcmdzWzJdICE9PSB2b2lkIDApXG4gICAgICAgIG9wdGlvbnMuYmx1ZSA9IGFyZ3NbMl07XG4gICAgfVxuICAgIG9wdGlvbnMgPSB7IC4uLl9SR0JTcGxpdEZpbHRlci5ERUZBVUxUX09QVElPTlMsIC4uLm9wdGlvbnMgfTtcbiAgICBjb25zdCBncHVQcm9ncmFtID0gR3B1UHJvZ3JhbS5mcm9tKHtcbiAgICAgIHZlcnRleDoge1xuICAgICAgICBzb3VyY2U6IHdnc2xWZXJ0ZXgsXG4gICAgICAgIGVudHJ5UG9pbnQ6IFwibWFpblZlcnRleFwiXG4gICAgICB9LFxuICAgICAgZnJhZ21lbnQ6IHtcbiAgICAgICAgc291cmNlLFxuICAgICAgICBlbnRyeVBvaW50OiBcIm1haW5GcmFnbWVudFwiXG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgZ2xQcm9ncmFtID0gR2xQcm9ncmFtLmZyb20oe1xuICAgICAgdmVydGV4LFxuICAgICAgZnJhZ21lbnQsXG4gICAgICBuYW1lOiBcInJnYi1zcGxpdC1maWx0ZXJcIlxuICAgIH0pO1xuICAgIHN1cGVyKHtcbiAgICAgIGdwdVByb2dyYW0sXG4gICAgICBnbFByb2dyYW0sXG4gICAgICByZXNvdXJjZXM6IHtcbiAgICAgICAgcmdiU3BsaXRVbmlmb3Jtczoge1xuICAgICAgICAgIHVSZWQ6IHsgdmFsdWU6IG9wdGlvbnMucmVkLCB0eXBlOiBcInZlYzI8ZjMyPlwiIH0sXG4gICAgICAgICAgdUdyZWVuOiB7IHZhbHVlOiBvcHRpb25zLmdyZWVuLCB0eXBlOiBcInZlYzI8ZjMyPlwiIH0sXG4gICAgICAgICAgdUJsdWU6IHsgdmFsdWU6IG9wdGlvbnMuYmx1ZSwgdHlwZTogXCJ2ZWMyPGYzMj5cIiB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidW5pZm9ybXNcIik7XG4gICAgdGhpcy51bmlmb3JtcyA9IHRoaXMucmVzb3VyY2VzLnJnYlNwbGl0VW5pZm9ybXMudW5pZm9ybXM7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogUmVkIGNoYW5uZWwgb2Zmc2V0LlxuICAgKiBAZGVmYXVsdCB7eDotMTAseTowfVxuICAgKi9cbiAgZ2V0IHJlZCgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy51UmVkO1xuICB9XG4gIHNldCByZWQodmFsdWUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHZhbHVlID0geyB4OiB2YWx1ZVswXSwgeTogdmFsdWVbMV0gfTtcbiAgICB9XG4gICAgdGhpcy51bmlmb3Jtcy51UmVkID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIEFtb3VudCBvZiB4LWF4aXMgb2Zmc2V0IGZvciB0aGUgcmVkIGNoYW5uZWwuXG4gICAqIEBkZWZhdWx0IC0xMFxuICAgKi9cbiAgZ2V0IHJlZFgoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVkLng7XG4gIH1cbiAgc2V0IHJlZFgodmFsdWUpIHtcbiAgICB0aGlzLnJlZC54ID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIEFtb3VudCBvZiB5LWF4aXMgb2Zmc2V0IGZvciB0aGUgcmVkIGNoYW5uZWwuXG4gICAqIEBkZWZhdWx0IDBcbiAgICovXG4gIGdldCByZWRZKCkge1xuICAgIHJldHVybiB0aGlzLnJlZC55O1xuICB9XG4gIHNldCByZWRZKHZhbHVlKSB7XG4gICAgdGhpcy5yZWQueSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBHcmVlbiBjaGFubmVsIG9mZnNldC5cbiAgICogQGRlZmF1bHQge3g6MCx5OjEwfVxuICAgKi9cbiAgZ2V0IGdyZWVuKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnVHcmVlbjtcbiAgfVxuICBzZXQgZ3JlZW4odmFsdWUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHZhbHVlID0geyB4OiB2YWx1ZVswXSwgeTogdmFsdWVbMV0gfTtcbiAgICB9XG4gICAgdGhpcy51bmlmb3Jtcy51R3JlZW4gPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogQW1vdW50IG9mIHgtYXhpcyBvZmZzZXQgZm9yIHRoZSBncmVlbiBjaGFubmVsLlxuICAgKiBAZGVmYXVsdCAwXG4gICAqL1xuICBnZXQgZ3JlZW5YKCkge1xuICAgIHJldHVybiB0aGlzLmdyZWVuLng7XG4gIH1cbiAgc2V0IGdyZWVuWCh2YWx1ZSkge1xuICAgIHRoaXMuZ3JlZW4ueCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBBbW91bnQgb2YgeS1heGlzIG9mZnNldCBmb3IgdGhlIGdyZWVuIGNoYW5uZWwuXG4gICAqIEBkZWZhdWx0IDEwXG4gICAqL1xuICBnZXQgZ3JlZW5ZKCkge1xuICAgIHJldHVybiB0aGlzLmdyZWVuLnk7XG4gIH1cbiAgc2V0IGdyZWVuWSh2YWx1ZSkge1xuICAgIHRoaXMuZ3JlZW4ueSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBCbHVlIGNoYW5uZWwgb2Zmc2V0LlxuICAgKiBAZGVmYXVsdCB7eDowLHk6MH1cbiAgICovXG4gIGdldCBibHVlKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnVCbHVlO1xuICB9XG4gIHNldCBibHVlKHZhbHVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB2YWx1ZSA9IHsgeDogdmFsdWVbMF0sIHk6IHZhbHVlWzFdIH07XG4gICAgfVxuICAgIHRoaXMudW5pZm9ybXMudUJsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogQW1vdW50IG9mIHgtYXhpcyBvZmZzZXQgZm9yIHRoZSBibHVlIGNoYW5uZWwuXG4gICAqIEBkZWZhdWx0IDBcbiAgICovXG4gIGdldCBibHVlWCgpIHtcbiAgICByZXR1cm4gdGhpcy5ibHVlLng7XG4gIH1cbiAgc2V0IGJsdWVYKHZhbHVlKSB7XG4gICAgdGhpcy5ibHVlLnggPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogQW1vdW50IG9mIHktYXhpcyBvZmZzZXQgZm9yIHRoZSBibHVlIGNoYW5uZWwuXG4gICAqIEBkZWZhdWx0IDBcbiAgICovXG4gIGdldCBibHVlWSgpIHtcbiAgICByZXR1cm4gdGhpcy5ibHVlLnk7XG4gIH1cbiAgc2V0IGJsdWVZKHZhbHVlKSB7XG4gICAgdGhpcy5ibHVlLnkgPSB2YWx1ZTtcbiAgfVxufTtcbi8qKiBEZWZhdWx0IHZhbHVlcyBmb3Igb3B0aW9ucy4gKi9cbl9fcHVibGljRmllbGQoX1JHQlNwbGl0RmlsdGVyLCBcIkRFRkFVTFRfT1BUSU9OU1wiLCB7XG4gIHJlZDogeyB4OiAtMTAsIHk6IDAgfSxcbiAgZ3JlZW46IHsgeDogMCwgeTogMTAgfSxcbiAgYmx1ZTogeyB4OiAwLCB5OiAwIH1cbn0pO1xubGV0IFJHQlNwbGl0RmlsdGVyID0gX1JHQlNwbGl0RmlsdGVyO1xuXG5leHBvcnQgeyBSR0JTcGxpdEZpbHRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UkdCU3BsaXRGaWx0ZXIubWpzLm1hcFxuIiwidmFyIHNvdXJjZSA9IFwic3RydWN0IFJnYlNwbGl0VW5pZm9ybXMge1xcbiAgICB1UmVkOiB2ZWMyPGYzMj4sXFxuICAgIHVHcmVlbjogdmVjMjxmMzI+LFxcbiAgICB1Qmx1ZTogdmVjMzxmMzI+LFxcbn07XFxuXFxuc3RydWN0IEdsb2JhbEZpbHRlclVuaWZvcm1zIHtcXG4gICAgdUlucHV0U2l6ZTp2ZWM0PGYzMj4sXFxuICAgIHVJbnB1dFBpeGVsOnZlYzQ8ZjMyPixcXG4gICAgdUlucHV0Q2xhbXA6dmVjNDxmMzI+LFxcbiAgICB1T3V0cHV0RnJhbWU6dmVjNDxmMzI+LFxcbiAgICB1R2xvYmFsRnJhbWU6dmVjNDxmMzI+LFxcbiAgICB1T3V0cHV0VGV4dHVyZTp2ZWM0PGYzMj4sXFxufTtcXG5cXG5AZ3JvdXAoMCkgQGJpbmRpbmcoMCkgdmFyPHVuaWZvcm0+IGdmdTogR2xvYmFsRmlsdGVyVW5pZm9ybXM7XFxuXFxuQGdyb3VwKDApIEBiaW5kaW5nKDEpIHZhciB1VGV4dHVyZTogdGV4dHVyZV8yZDxmMzI+OyBcXG5AZ3JvdXAoMCkgQGJpbmRpbmcoMikgdmFyIHVTYW1wbGVyOiBzYW1wbGVyO1xcbkBncm91cCgxKSBAYmluZGluZygwKSB2YXI8dW5pZm9ybT4gcmdiU3BsaXRVbmlmb3JtcyA6IFJnYlNwbGl0VW5pZm9ybXM7XFxuXFxuQGZyYWdtZW50XFxuZm4gbWFpbkZyYWdtZW50KFxcbiAgICBAYnVpbHRpbihwb3NpdGlvbikgcG9zaXRpb246IHZlYzQ8ZjMyPixcXG4gICAgQGxvY2F0aW9uKDApIHV2IDogdmVjMjxmMzI+XFxuKSAtPiBAbG9jYXRpb24oMCkgdmVjNDxmMzI+IHtcXG4gICAgbGV0IHIgPSB0ZXh0dXJlU2FtcGxlKHVUZXh0dXJlLCB1U2FtcGxlciwgdXYgKyB2ZWMyPGYzMj4ocmdiU3BsaXRVbmlmb3Jtcy51UmVkLnggLyBnZnUudUlucHV0U2l6ZS54LCByZ2JTcGxpdFVuaWZvcm1zLnVSZWQueSAvIGdmdS51SW5wdXRTaXplLnkpKS5yO1xcbiAgICBsZXQgZyA9IHRleHR1cmVTYW1wbGUodVRleHR1cmUsIHVTYW1wbGVyLCB1diArIHZlYzI8ZjMyPihyZ2JTcGxpdFVuaWZvcm1zLnVHcmVlbi54IC8gZ2Z1LnVJbnB1dFNpemUueCwgcmdiU3BsaXRVbmlmb3Jtcy51R3JlZW4ueSAvIGdmdS51SW5wdXRTaXplLnkpKS5nO1xcbiAgICBsZXQgYiA9IHRleHR1cmVTYW1wbGUodVRleHR1cmUsIHVTYW1wbGVyLCB1diArIHZlYzI8ZjMyPihyZ2JTcGxpdFVuaWZvcm1zLnVCbHVlLnggLyBnZnUudUlucHV0U2l6ZS54LCByZ2JTcGxpdFVuaWZvcm1zLnVCbHVlLnkgLyBnZnUudUlucHV0U2l6ZS55KSkuYjtcXG4gICAgbGV0IGEgPSB0ZXh0dXJlU2FtcGxlKHVUZXh0dXJlLCB1U2FtcGxlciwgdXYpLmE7XFxuICAgIHJldHVybiB2ZWM0PGYzMj4ociwgZywgYiwgYSk7XFxufVxcblwiO1xuXG5leHBvcnQgeyBzb3VyY2UgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmdiLXNwbGl0Mi5tanMubWFwXG4iLCJ2YXIgZnJhZ21lbnQgPSBcIlxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5pbiB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxub3V0IHZlYzQgZmluYWxDb2xvcjtcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG51bmlmb3JtIHZlYzIgdUNlbnRlcjtcXG51bmlmb3JtIGZsb2F0IHVUaW1lO1xcbnVuaWZvcm0gZmxvYXQgdVNwZWVkO1xcbnVuaWZvcm0gdmVjNCB1V2F2ZTtcXG5cXG51bmlmb3JtIHZlYzQgdUlucHV0U2l6ZTtcXG51bmlmb3JtIHZlYzQgdUlucHV0Q2xhbXA7XFxuXFxuY29uc3QgZmxvYXQgUEkgPSAzLjE0MTU5O1xcblxcbnZvaWQgbWFpbigpXFxue1xcbiAgICBmbG9hdCB1QW1wbGl0dWRlID0gdVdhdmVbMF07XFxuICAgIGZsb2F0IHVXYXZlbGVuZ3RoID0gdVdhdmVbMV07XFxuICAgIGZsb2F0IHVCcmlnaHRuZXNzID0gdVdhdmVbMl07XFxuICAgIGZsb2F0IHVSYWRpdXMgPSB1V2F2ZVszXTtcXG5cXG4gICAgZmxvYXQgaGFsZldhdmVsZW5ndGggPSB1V2F2ZWxlbmd0aCAqIDAuNSAvIHVJbnB1dFNpemUueDtcXG4gICAgZmxvYXQgbWF4UmFkaXVzID0gdVJhZGl1cyAvIHVJbnB1dFNpemUueDtcXG4gICAgZmxvYXQgY3VycmVudFJhZGl1cyA9IHVUaW1lICogdVNwZWVkIC8gdUlucHV0U2l6ZS54O1xcblxcbiAgICBmbG9hdCBmYWRlID0gMS4wO1xcblxcbiAgICBpZiAobWF4UmFkaXVzID4gMC4wKSB7XFxuICAgICAgICBpZiAoY3VycmVudFJhZGl1cyA+IG1heFJhZGl1cykge1xcbiAgICAgICAgICAgIGZpbmFsQ29sb3IgPSB0ZXh0dXJlKHVUZXh0dXJlLCB2VGV4dHVyZUNvb3JkKTtcXG4gICAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuICAgICAgICBmYWRlID0gMS4wIC0gcG93KGN1cnJlbnRSYWRpdXMgLyBtYXhSYWRpdXMsIDIuMCk7XFxuICAgIH1cXG5cXG4gICAgdmVjMiBkaXIgPSB2ZWMyKHZUZXh0dXJlQ29vcmQgLSB1Q2VudGVyIC8gdUlucHV0U2l6ZS54eSk7XFxuICAgIGRpci55ICo9IHVJbnB1dFNpemUueSAvIHVJbnB1dFNpemUueDtcXG4gICAgZmxvYXQgZGlzdCA9IGxlbmd0aChkaXIpO1xcblxcbiAgICBpZiAoZGlzdCA8PSAwLjAgfHwgZGlzdCA8IGN1cnJlbnRSYWRpdXMgLSBoYWxmV2F2ZWxlbmd0aCB8fCBkaXN0ID4gY3VycmVudFJhZGl1cyArIGhhbGZXYXZlbGVuZ3RoKSB7XFxuICAgICAgICBmaW5hbENvbG9yID0gdGV4dHVyZSh1VGV4dHVyZSwgdlRleHR1cmVDb29yZCk7XFxuICAgICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgdmVjMiBkaWZmVVYgPSBub3JtYWxpemUoZGlyKTtcXG5cXG4gICAgZmxvYXQgZGlmZiA9IChkaXN0IC0gY3VycmVudFJhZGl1cykgLyBoYWxmV2F2ZWxlbmd0aDtcXG5cXG4gICAgZmxvYXQgcCA9IDEuMCAtIHBvdyhhYnMoZGlmZiksIDIuMCk7XFxuXFxuICAgIC8vIGZsb2F0IHBvd0RpZmYgPSBkaWZmICogcG93KHAsIDIuMCkgKiAoIGFtcGxpdHVkZSAqIGZhZGUgKTtcXG4gICAgZmxvYXQgcG93RGlmZiA9IDEuMjUgKiBzaW4oZGlmZiAqIFBJKSAqIHAgKiAoIHVBbXBsaXR1ZGUgKiBmYWRlICk7XFxuXFxuICAgIHZlYzIgb2Zmc2V0ID0gZGlmZlVWICogcG93RGlmZiAvIHVJbnB1dFNpemUueHk7XFxuXFxuICAgIC8vIERvIGNsYW1wIDpcXG4gICAgdmVjMiBjb29yZCA9IHZUZXh0dXJlQ29vcmQgKyBvZmZzZXQ7XFxuICAgIHZlYzIgY2xhbXBlZENvb3JkID0gY2xhbXAoY29vcmQsIHVJbnB1dENsYW1wLnh5LCB1SW5wdXRDbGFtcC56dyk7XFxuICAgIHZlYzQgY29sb3IgPSB0ZXh0dXJlKHVUZXh0dXJlLCBjbGFtcGVkQ29vcmQpO1xcbiAgICBpZiAoY29vcmQgIT0gY2xhbXBlZENvb3JkKSB7XFxuICAgICAgICBjb2xvciAqPSBtYXgoMC4wLCAxLjAgLSBsZW5ndGgoY29vcmQgLSBjbGFtcGVkQ29vcmQpKTtcXG4gICAgfVxcblxcbiAgICAvLyBObyBjbGFtcCA6XFxuICAgIC8vIGZpbmFsQ29sb3IgPSB0ZXh0dXJlKHVUZXh0dXJlLCB2VGV4dHVyZUNvb3JkICsgb2Zmc2V0KTtcXG5cXG4gICAgY29sb3IucmdiICo9IDEuMCArICh1QnJpZ2h0bmVzcyAtIDEuMCkgKiBwICogZmFkZTtcXG5cXG4gICAgZmluYWxDb2xvciA9IGNvbG9yO1xcbn1cXG5cIjtcblxuZXhwb3J0IHsgZnJhZ21lbnQgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hvY2t3YXZlMi5tanMubWFwXG4iLCJpbXBvcnQgeyBGaWx0ZXIsIGRlcHJlY2F0aW9uLCBHcHVQcm9ncmFtLCBHbFByb2dyYW0gfSBmcm9tICdwaXhpLmpzJztcbmltcG9ydCB2ZXJ0ZXggZnJvbSAnLi4vZGVmYXVsdHMvZGVmYXVsdDIubWpzJztcbmltcG9ydCB3Z3NsVmVydGV4IGZyb20gJy4uL2RlZmF1bHRzL2RlZmF1bHQubWpzJztcbmltcG9ydCBmcmFnbWVudCBmcm9tICcuL3Nob2Nrd2F2ZTIubWpzJztcbmltcG9ydCBzb3VyY2UgZnJvbSAnLi9zaG9ja3dhdmUubWpzJztcblxudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuY29uc3QgX1Nob2Nrd2F2ZUZpbHRlciA9IGNsYXNzIF9TaG9ja3dhdmVGaWx0ZXIgZXh0ZW5kcyBGaWx0ZXIge1xuICAvKiogQGlnbm9yZSAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmdzWzBdID8/IHt9O1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMpIHx8IFwieFwiIGluIG9wdGlvbnMgJiYgXCJ5XCIgaW4gb3B0aW9ucykge1xuICAgICAgZGVwcmVjYXRpb24oXCI2LjAuMFwiLCBcIlNob2Nrd2F2ZUZpbHRlciBjb25zdHJ1Y3RvciBwYXJhbXMgYXJlIG5vdyBvcHRpb25zIG9iamVjdC4gU2VlIHBhcmFtczogeyBjZW50ZXIsIHNwZWVkLCBhbXBsaXR1ZGUsIHdhdmVsZW5ndGgsIGJyaWdodG5lc3MsIHJhZGl1cywgdGltZSB9XCIpO1xuICAgICAgb3B0aW9ucyA9IHsgY2VudGVyOiBvcHRpb25zLCAuLi5hcmdzWzFdIH07XG4gICAgICBpZiAoYXJnc1syXSAhPT0gdm9pZCAwKVxuICAgICAgICBvcHRpb25zLnRpbWUgPSBhcmdzWzJdO1xuICAgIH1cbiAgICBvcHRpb25zID0geyAuLi5fU2hvY2t3YXZlRmlsdGVyLkRFRkFVTFRfT1BUSU9OUywgLi4ub3B0aW9ucyB9O1xuICAgIGNvbnN0IGdwdVByb2dyYW0gPSBHcHVQcm9ncmFtLmZyb20oe1xuICAgICAgdmVydGV4OiB7XG4gICAgICAgIHNvdXJjZTogd2dzbFZlcnRleCxcbiAgICAgICAgZW50cnlQb2ludDogXCJtYWluVmVydGV4XCJcbiAgICAgIH0sXG4gICAgICBmcmFnbWVudDoge1xuICAgICAgICBzb3VyY2UsXG4gICAgICAgIGVudHJ5UG9pbnQ6IFwibWFpbkZyYWdtZW50XCJcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBnbFByb2dyYW0gPSBHbFByb2dyYW0uZnJvbSh7XG4gICAgICB2ZXJ0ZXgsXG4gICAgICBmcmFnbWVudCxcbiAgICAgIG5hbWU6IFwic2hvY2t3YXZlLWZpbHRlclwiXG4gICAgfSk7XG4gICAgc3VwZXIoe1xuICAgICAgZ3B1UHJvZ3JhbSxcbiAgICAgIGdsUHJvZ3JhbSxcbiAgICAgIHJlc291cmNlczoge1xuICAgICAgICBzaG9ja3dhdmVVbmlmb3Jtczoge1xuICAgICAgICAgIHVUaW1lOiB7IHZhbHVlOiBvcHRpb25zLnRpbWUsIHR5cGU6IFwiZjMyXCIgfSxcbiAgICAgICAgICB1Q2VudGVyOiB7IHZhbHVlOiBvcHRpb25zLmNlbnRlciwgdHlwZTogXCJ2ZWMyPGYzMj5cIiB9LFxuICAgICAgICAgIHVTcGVlZDogeyB2YWx1ZTogb3B0aW9ucy5zcGVlZCwgdHlwZTogXCJmMzJcIiB9LFxuICAgICAgICAgIHVXYXZlOiB7IHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KDQpLCB0eXBlOiBcInZlYzQ8ZjMyPlwiIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ1bmlmb3Jtc1wiKTtcbiAgICAvKiogU2V0cyB0aGUgZWxhcHNlZCB0aW1lIG9mIHRoZSBzaG9ja3dhdmUuIEl0IGNvdWxkIGNvbnRyb2wgdGhlIGN1cnJlbnQgc2l6ZSBvZiBzaG9ja3dhdmUuICovXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInRpbWVcIik7XG4gICAgdGhpcy50aW1lID0gMDtcbiAgICB0aGlzLnVuaWZvcm1zID0gdGhpcy5yZXNvdXJjZXMuc2hvY2t3YXZlVW5pZm9ybXMudW5pZm9ybXM7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBvcHRpb25zKTtcbiAgfVxuICBhcHBseShmaWx0ZXJNYW5hZ2VyLCBpbnB1dCwgb3V0cHV0LCBjbGVhck1vZGUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnVUaW1lID0gdGhpcy50aW1lO1xuICAgIGZpbHRlck1hbmFnZXIuYXBwbHlGaWx0ZXIodGhpcywgaW5wdXQsIG91dHB1dCwgY2xlYXJNb2RlKTtcbiAgfVxuICAvKipcbiAgICogVGhlIGB4YCBhbmQgYHlgIGNlbnRlciBjb29yZGluYXRlcyB0byBjaGFuZ2UgdGhlIHBvc2l0aW9uIG9mIHRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZSBvZiBlZmZlY3QuXG4gICAqIEBkZWZhdWx0IFswLDBdXG4gICAqL1xuICBnZXQgY2VudGVyKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnVDZW50ZXI7XG4gIH1cbiAgc2V0IGNlbnRlcih2YWx1ZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgdmFsdWUgPSB7IHg6IHZhbHVlWzBdLCB5OiB2YWx1ZVsxXSB9O1xuICAgIH1cbiAgICB0aGlzLnVuaWZvcm1zLnVDZW50ZXIgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgY2VudGVyIG9mIHRoZSBlZmZlY3QgaW4gbm9ybWFsaXplZCBzY3JlZW4gY29vcmRzIG9uIHRoZSBgeGAgYXhpc1xuICAgKiBAZGVmYXVsdCAwXG4gICAqL1xuICBnZXQgY2VudGVyWCgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy51Q2VudGVyLng7XG4gIH1cbiAgc2V0IGNlbnRlclgodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnVDZW50ZXIueCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjZW50ZXIgb2YgdGhlIGVmZmVjdCBpbiBub3JtYWxpemVkIHNjcmVlbiBjb29yZHMgb24gdGhlIGB5YCBheGlzXG4gICAqIEBkZWZhdWx0IDBcbiAgICovXG4gIGdldCBjZW50ZXJZKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnVDZW50ZXIueTtcbiAgfVxuICBzZXQgY2VudGVyWSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMudUNlbnRlci55ID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBzcGVlZCBhYm91dCB0aGUgc2hvY2t3YXZlIHJpcHBsZXMgb3V0LiBUaGUgdW5pdCBpcyBgcGl4ZWwtcGVyLXNlY29uZGBcbiAgICogQGRlZmF1bHQgNTAwXG4gICAqL1xuICBnZXQgc3BlZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMudVNwZWVkO1xuICB9XG4gIHNldCBzcGVlZCh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMudVNwZWVkID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBhbXBsaXR1ZGUgb2YgdGhlIHNob2Nrd2F2ZVxuICAgKiBAZGVmYXVsdCAzMFxuICAgKi9cbiAgZ2V0IGFtcGxpdHVkZSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy51V2F2ZVswXTtcbiAgfVxuICBzZXQgYW1wbGl0dWRlKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy51V2F2ZVswXSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgd2F2ZWxlbmd0aCBvZiB0aGUgc2hvY2t3YXZlXG4gICAqIEBkZWZhdWx0IDE2MFxuICAgKi9cbiAgZ2V0IHdhdmVsZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMudVdhdmVbMV07XG4gIH1cbiAgc2V0IHdhdmVsZW5ndGgodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnVXYXZlWzFdID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBicmlnaHRuZXNzIG9mIHRoZSBzaG9ja3dhdmVcbiAgICogQGRlZmF1bHQgMVxuICAgKi9cbiAgZ2V0IGJyaWdodG5lc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMudVdhdmVbMl07XG4gIH1cbiAgc2V0IGJyaWdodG5lc3ModmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnVXYXZlWzJdID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBtYXhpbXVtIHJhZGl1cyBvZiBzaG9ja3dhdmUuIGxlc3MgdGhhbiBgMGAgbWVhbnMgdGhlIG1heCBpcyBhbiBpbmZpbml0ZSBkaXN0YW5jZVxuICAgKiBAZGVmYXVsdCAtMVxuICAgKi9cbiAgZ2V0IHJhZGl1cygpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy51V2F2ZVszXTtcbiAgfVxuICBzZXQgcmFkaXVzKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy51V2F2ZVszXSA9IHZhbHVlO1xuICB9XG59O1xuLyoqIERlZmF1bHQgc2hvY2t3YXZlIGZpbHRlciBvcHRpb25zICovXG5fX3B1YmxpY0ZpZWxkKF9TaG9ja3dhdmVGaWx0ZXIsIFwiREVGQVVMVF9PUFRJT05TXCIsIHtcbiAgLyoqIFRoZSBgeGAgYW5kIGB5YCBjZW50ZXIgY29vcmRpbmF0ZXMgdG8gY2hhbmdlIHRoZSBwb3NpdGlvbiBvZiB0aGUgY2VudGVyIG9mIHRoZSBjaXJjbGUgb2YgZWZmZWN0LiAqL1xuICBjZW50ZXI6IHsgeDogMCwgeTogMCB9LFxuICAvKiogVGhlIHNwZWVkIGFib3V0IHRoZSBzaG9ja3dhdmUgcmlwcGxlcyBvdXQuIFRoZSB1bml0IGlzIGBwaXhlbC1wZXItc2Vjb25kYCAqL1xuICBzcGVlZDogNTAwLFxuICAvKiogVGhlIGFtcGxpdHVkZSBvZiB0aGUgc2hvY2t3YXZlICovXG4gIGFtcGxpdHVkZTogMzAsXG4gIC8qKiBUaGUgd2F2ZWxlbmd0aCBvZiB0aGUgc2hvY2t3YXZlICovXG4gIHdhdmVsZW5ndGg6IDE2MCxcbiAgLyoqIFRoZSBicmlnaHRuZXNzIG9mIHRoZSBzaG9ja3dhdmUgKi9cbiAgYnJpZ2h0bmVzczogMSxcbiAgLyoqIFRoZSBtYXhpbXVtIHJhZGl1cyBvZiBzaG9ja3dhdmUuIGxlc3MgdGhhbiBgMGAgbWVhbnMgdGhlIG1heCBpcyBhbiBpbmZpbml0ZSBkaXN0YW5jZSAqL1xuICByYWRpdXM6IC0xXG59KTtcbmxldCBTaG9ja3dhdmVGaWx0ZXIgPSBfU2hvY2t3YXZlRmlsdGVyO1xuXG5leHBvcnQgeyBTaG9ja3dhdmVGaWx0ZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNob2Nrd2F2ZUZpbHRlci5tanMubWFwXG4iLCJ2YXIgc291cmNlID0gXCJcXG5zdHJ1Y3QgU2hvY2tXYXZlVW5pZm9ybXMge1xcbiAgICB1VGltZTogZjMyLFxcbiAgICB1T2Zmc2V0OiB2ZWMyPGYzMj4sXFxuICAgIHVTcGVlZDogZjMyLFxcbiAgICB1V2F2ZTogdmVjNDxmMzI+LFxcbn07XFxuXFxuc3RydWN0IEdsb2JhbEZpbHRlclVuaWZvcm1zIHtcXG4gICAgdUlucHV0U2l6ZTp2ZWM0PGYzMj4sXFxuICAgIHVJbnB1dFBpeGVsOnZlYzQ8ZjMyPixcXG4gICAgdUlucHV0Q2xhbXA6dmVjNDxmMzI+LFxcbiAgICB1T3V0cHV0RnJhbWU6dmVjNDxmMzI+LFxcbiAgICB1R2xvYmFsRnJhbWU6dmVjNDxmMzI+LFxcbiAgICB1T3V0cHV0VGV4dHVyZTp2ZWM0PGYzMj4sXFxufTtcXG5cXG5AZ3JvdXAoMCkgQGJpbmRpbmcoMCkgdmFyPHVuaWZvcm0+IGdmdTogR2xvYmFsRmlsdGVyVW5pZm9ybXM7XFxuXFxuQGdyb3VwKDApIEBiaW5kaW5nKDEpIHZhciB1VGV4dHVyZTogdGV4dHVyZV8yZDxmMzI+OyBcXG5AZ3JvdXAoMCkgQGJpbmRpbmcoMikgdmFyIHVTYW1wbGVyOiBzYW1wbGVyO1xcbkBncm91cCgxKSBAYmluZGluZygwKSB2YXI8dW5pZm9ybT4gc2hvY2t3YXZlVW5pZm9ybXMgOiBTaG9ja1dhdmVVbmlmb3JtcztcXG5cXG5AZnJhZ21lbnRcXG5mbiBtYWluRnJhZ21lbnQoXFxuICAgIEBidWlsdGluKHBvc2l0aW9uKSBwb3NpdGlvbjogdmVjNDxmMzI+LFxcbiAgICBAbG9jYXRpb24oMCkgdXYgOiB2ZWMyPGYzMj5cXG4pIC0+IEBsb2NhdGlvbigwKSB2ZWM0PGYzMj4ge1xcblxcbiAgICBsZXQgdVRpbWUgPSBzaG9ja3dhdmVVbmlmb3Jtcy51VGltZTtcXG4gICAgbGV0IHVPZmZzZXQgPSBzaG9ja3dhdmVVbmlmb3Jtcy51T2Zmc2V0O1xcbiAgICBsZXQgdVNwZWVkID0gc2hvY2t3YXZlVW5pZm9ybXMudVNwZWVkO1xcbiAgICBsZXQgdUFtcGxpdHVkZSA9IHNob2Nrd2F2ZVVuaWZvcm1zLnVXYXZlWzBdO1xcbiAgICBsZXQgdVdhdmVsZW5ndGggPSBzaG9ja3dhdmVVbmlmb3Jtcy51V2F2ZVsxXTtcXG4gICAgbGV0IHVCcmlnaHRuZXNzID0gc2hvY2t3YXZlVW5pZm9ybXMudVdhdmVbMl07XFxuICAgIGxldCB1UmFkaXVzID0gc2hvY2t3YXZlVW5pZm9ybXMudVdhdmVbM107XFxuICAgIGxldCBoYWxmV2F2ZWxlbmd0aDogZjMyID0gdVdhdmVsZW5ndGggKiAwLjUgLyBnZnUudUlucHV0U2l6ZS54O1xcbiAgICBsZXQgbWF4UmFkaXVzOiBmMzIgPSB1UmFkaXVzIC8gZ2Z1LnVJbnB1dFNpemUueDtcXG4gICAgbGV0IGN1cnJlbnRSYWRpdXM6IGYzMiA9IHVUaW1lICogdVNwZWVkIC8gZ2Z1LnVJbnB1dFNpemUueDtcXG4gICAgdmFyIGZhZGU6IGYzMiA9IDEuMDtcXG4gICAgdmFyIHJldHVybkNvbG9yT25seTogYm9vbCA9IGZhbHNlO1xcbiAgICBcXG4gICAgaWYgKG1heFJhZGl1cyA+IDAuMCkge1xcbiAgICAgICAgaWYgKGN1cnJlbnRSYWRpdXMgPiBtYXhSYWRpdXMpIHtcXG4gICAgICAgICAgICByZXR1cm5Db2xvck9ubHkgPSB0cnVlO1xcbiAgICAgICAgfVxcbiAgICAgICAgZmFkZSA9IDEuMCAtIHBvdyhjdXJyZW50UmFkaXVzIC8gbWF4UmFkaXVzLCAyLjApO1xcbiAgICB9XFxuICAgIHZhciBkaXI6IHZlYzI8ZjMyPiA9IHZlYzI8ZjMyPih1diAtIHVPZmZzZXQgLyBnZnUudUlucHV0U2l6ZS54eSk7XFxuICAgIGRpci55ICo9IGdmdS51SW5wdXRTaXplLnkgLyBnZnUudUlucHV0U2l6ZS54O1xcblxcbiAgICBsZXQgZGlzdDpmMzIgPSBsZW5ndGgoZGlyKTtcXG5cXG4gICAgaWYgKGRpc3QgPD0gMC4wIHx8IGRpc3QgPCBjdXJyZW50UmFkaXVzIC0gaGFsZldhdmVsZW5ndGggfHwgZGlzdCA+IGN1cnJlbnRSYWRpdXMgKyBoYWxmV2F2ZWxlbmd0aCkge1xcbiAgICAgICAgcmV0dXJuQ29sb3JPbmx5ID0gdHJ1ZTtcXG4gICAgfVxcblxcbiAgICBsZXQgZGlmZlVWOiB2ZWMyPGYzMj4gPSBub3JtYWxpemUoZGlyKTtcXG4gICAgbGV0IGRpZmY6IGYzMiA9IChkaXN0IC0gY3VycmVudFJhZGl1cykgLyBoYWxmV2F2ZWxlbmd0aDtcXG4gICAgbGV0IHA6IGYzMiA9IDEuMCAtIHBvdyhhYnMoZGlmZiksIDIuMCk7XFxuICAgIGxldCBwb3dEaWZmOiBmMzIgPSAxLjI1ICogc2luKGRpZmYgKiBQSSkgKiBwICogKCB1QW1wbGl0dWRlICogZmFkZSApO1xcbiAgICBsZXQgb2Zmc2V0OiB2ZWMyPGYzMj4gPSBkaWZmVVYgKiBwb3dEaWZmIC8gZ2Z1LnVJbnB1dFNpemUueHk7XFxuICAgIC8vIERvIGNsYW1wIDpcXG4gICAgbGV0IGNvb3JkOiB2ZWMyPGYzMj4gPSB1diArIG9mZnNldDtcXG4gICAgbGV0IGNsYW1wZWRDb29yZDogdmVjMjxmMzI+ID0gY2xhbXAoY29vcmQsIGdmdS51SW5wdXRDbGFtcC54eSwgZ2Z1LnVJbnB1dENsYW1wLnp3KTtcXG5cXG4gICAgdmFyIGNsYW1wZWRDb2xvcjogdmVjNDxmMzI+ID0gdGV4dHVyZVNhbXBsZSh1VGV4dHVyZSwgdVNhbXBsZXIsIGNsYW1wZWRDb29yZCk7XFxuICAgIFxcbiAgICBpZiAoYm9vbFZlYzIoY29vcmQsIGNsYW1wZWRDb29yZCkpIFxcbiAgICB7XFxuICAgICAgICBjbGFtcGVkQ29sb3IgKj0gbWF4KDAuMCwgMS4wIC0gbGVuZ3RoKGNvb3JkIC0gY2xhbXBlZENvb3JkKSk7XFxuICAgIH1cXG4gICAgLy8gTm8gY2xhbXAgOlxcbiAgICB2YXIgZmluYWxDb2xvciA9IGNsYW1wZWRDb2xvcjtcXG5cXG4gICAgcmV0dXJuIHNlbGVjdChmaW5hbENvbG9yLCB0ZXh0dXJlU2FtcGxlKHVUZXh0dXJlLCB1U2FtcGxlciwgdXYpLCByZXR1cm5Db2xvck9ubHkpO1xcbn1cXG5cXG5mbiBib29sVmVjMih4OiB2ZWMyPGYzMj4sIHk6IHZlYzI8ZjMyPikgLT4gYm9vbFxcbntcXG4gICAgaWYgKHgueCA9PSB5LnggJiYgeC55ID09IHkueSlcXG4gICAge1xcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgIH1cXG4gICAgXFxuICAgIHJldHVybiBmYWxzZTtcXG59XFxuXFxuY29uc3QgUEk6IGYzMiA9IDMuMTQxNTkyNjUzNTg5NzkzMjM4NDYyNjQ7XFxuXCI7XG5cbmV4cG9ydCB7IHNvdXJjZSBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaG9ja3dhdmUubWpzLm1hcFxuIiwidmFyIGZyYWdtZW50ID0gXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuaW4gdmVjMiB2VGV4dHVyZUNvb3JkO1xcbm91dCB2ZWM0IGZpbmFsQ29sb3I7XFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxudW5pZm9ybSBzYW1wbGVyMkQgdU1hcFRleHR1cmU7XFxudW5pZm9ybSB2ZWMzIHVDb2xvcjtcXG51bmlmb3JtIGZsb2F0IHVBbHBoYTtcXG51bmlmb3JtIHZlYzIgdURpbWVuc2lvbnM7XFxuXFxudW5pZm9ybSB2ZWM0IHVJbnB1dFNpemU7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgICB2ZWM0IGRpZmZ1c2VDb2xvciA9IHRleHR1cmUodVRleHR1cmUsIHZUZXh0dXJlQ29vcmQpO1xcbiAgICB2ZWMyIGxpZ2h0Q29vcmQgPSAodlRleHR1cmVDb29yZCAqIHVJbnB1dFNpemUueHkpIC8gdURpbWVuc2lvbnM7XFxuICAgIHZlYzQgbGlnaHQgPSB0ZXh0dXJlKHVNYXBUZXh0dXJlLCBsaWdodENvb3JkKTtcXG4gICAgdmVjMyBhbWJpZW50ID0gdUNvbG9yLnJnYiAqIHVBbHBoYTtcXG4gICAgdmVjMyBpbnRlbnNpdHkgPSBhbWJpZW50ICsgbGlnaHQucmdiO1xcbiAgICB2ZWMzIGNvbG9yID0gZGlmZnVzZUNvbG9yLnJnYiAqIGludGVuc2l0eTtcXG4gICAgZmluYWxDb2xvciA9IHZlYzQoY29sb3IsIGRpZmZ1c2VDb2xvci5hKTtcXG59XFxuXCI7XG5cbmV4cG9ydCB7IGZyYWdtZW50IGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpbXBsZS1saWdodG1hcC5tanMubWFwXG4iLCJpbXBvcnQgeyBUZXh0dXJlLCBGaWx0ZXIsIGRlcHJlY2F0aW9uLCBHcHVQcm9ncmFtLCBHbFByb2dyYW0sIENvbG9yIH0gZnJvbSAncGl4aS5qcyc7XG5pbXBvcnQgdmVydGV4IGZyb20gJy4uL2RlZmF1bHRzL2RlZmF1bHQyLm1qcyc7XG5pbXBvcnQgd2dzbFZlcnRleCBmcm9tICcuLi9kZWZhdWx0cy9kZWZhdWx0Lm1qcyc7XG5pbXBvcnQgZnJhZ21lbnQgZnJvbSAnLi9zaW1wbGUtbGlnaHRtYXAubWpzJztcbmltcG9ydCBzb3VyY2UgZnJvbSAnLi9zaW1wbGUtbGlnaHRtYXAyLm1qcyc7XG5cbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbmNvbnN0IF9TaW1wbGVMaWdodG1hcEZpbHRlciA9IGNsYXNzIF9TaW1wbGVMaWdodG1hcEZpbHRlciBleHRlbmRzIEZpbHRlciB7XG4gIC8qKiBAaWdub3JlICovXG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3NbMF0gPz8ge307XG4gICAgaWYgKG9wdGlvbnMgaW5zdGFuY2VvZiBUZXh0dXJlKSB7XG4gICAgICBkZXByZWNhdGlvbihcIjYuMC4wXCIsIFwiU2ltcGxlTGlnaHRtYXBGaWx0ZXIgY29uc3RydWN0b3IgcGFyYW1zIGFyZSBub3cgb3B0aW9ucyBvYmplY3QuIFNlZSBwYXJhbXM6IHsgbGlnaHRNYXAsIGNvbG9yLCBhbHBoYSB9XCIpO1xuICAgICAgb3B0aW9ucyA9IHsgbGlnaHRNYXA6IG9wdGlvbnMgfTtcbiAgICAgIGlmIChhcmdzWzFdICE9PSB2b2lkIDApXG4gICAgICAgIG9wdGlvbnMuY29sb3IgPSBhcmdzWzFdO1xuICAgICAgaWYgKGFyZ3NbMl0gIT09IHZvaWQgMClcbiAgICAgICAgb3B0aW9ucy5hbHBoYSA9IGFyZ3NbMl07XG4gICAgfVxuICAgIG9wdGlvbnMgPSB7IC4uLl9TaW1wbGVMaWdodG1hcEZpbHRlci5ERUZBVUxUX09QVElPTlMsIC4uLm9wdGlvbnMgfTtcbiAgICBpZiAoIW9wdGlvbnMubGlnaHRNYXApXG4gICAgICB0aHJvdyBFcnJvcihcIk5vIGxpZ2h0IG1hcCB0ZXh0dXJlIHNvdXJjZSB3YXMgcHJvdmlkZWQgdG8gU2ltcGxlTGlnaHRtYXBGaWx0ZXJcIik7XG4gICAgY29uc3QgZ3B1UHJvZ3JhbSA9IEdwdVByb2dyYW0uZnJvbSh7XG4gICAgICB2ZXJ0ZXg6IHtcbiAgICAgICAgc291cmNlOiB3Z3NsVmVydGV4LFxuICAgICAgICBlbnRyeVBvaW50OiBcIm1haW5WZXJ0ZXhcIlxuICAgICAgfSxcbiAgICAgIGZyYWdtZW50OiB7XG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgZW50cnlQb2ludDogXCJtYWluRnJhZ21lbnRcIlxuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGdsUHJvZ3JhbSA9IEdsUHJvZ3JhbS5mcm9tKHtcbiAgICAgIHZlcnRleCxcbiAgICAgIGZyYWdtZW50LFxuICAgICAgbmFtZTogXCJzaW1wbGUtbGlnaHRtYXAtZmlsdGVyXCJcbiAgICB9KTtcbiAgICBzdXBlcih7XG4gICAgICBncHVQcm9ncmFtLFxuICAgICAgZ2xQcm9ncmFtLFxuICAgICAgcmVzb3VyY2VzOiB7XG4gICAgICAgIHNpbXBsZUxpZ2h0bWFwVW5pZm9ybXM6IHtcbiAgICAgICAgICB1Q29sb3I6IHsgdmFsdWU6IG5ldyBGbG9hdDMyQXJyYXkoMyksIHR5cGU6IFwidmVjMzxmMzI+XCIgfSxcbiAgICAgICAgICB1QWxwaGE6IHsgdmFsdWU6IG9wdGlvbnMuYWxwaGEsIHR5cGU6IFwiZjMyXCIgfSxcbiAgICAgICAgICB1RGltZW5zaW9uczogeyB2YWx1ZTogbmV3IEZsb2F0MzJBcnJheSgyKSwgdHlwZTogXCJ2ZWMyPGYzMj5cIiB9XG4gICAgICAgIH0sXG4gICAgICAgIHVNYXBUZXh0dXJlOiBvcHRpb25zLmxpZ2h0TWFwLnNvdXJjZSxcbiAgICAgICAgdU1hcFNhbXBsZXI6IG9wdGlvbnMubGlnaHRNYXAuc291cmNlLnN0eWxlXG4gICAgICB9XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInVuaWZvcm1zXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfY29sb3JcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9saWdodE1hcFwiKTtcbiAgICB0aGlzLnVuaWZvcm1zID0gdGhpcy5yZXNvdXJjZXMuc2ltcGxlTGlnaHRtYXBVbmlmb3Jtcy51bmlmb3JtcztcbiAgICB0aGlzLl9jb2xvciA9IG5ldyBDb2xvcigpO1xuICAgIHRoaXMuY29sb3IgPSBvcHRpb25zLmNvbG9yID8/IDA7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogT3ZlcnJpZGUgZXhpc3RpbmcgYXBwbHkgbWV0aG9kIGluIGBGaWx0ZXJgXG4gICAqIEBvdmVycmlkZVxuICAgKiBAaWdub3JlXG4gICAqL1xuICBhcHBseShmaWx0ZXJNYW5hZ2VyLCBpbnB1dCwgb3V0cHV0LCBjbGVhck1vZGUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnVEaW1lbnNpb25zWzBdID0gaW5wdXQuZnJhbWUud2lkdGg7XG4gICAgdGhpcy51bmlmb3Jtcy51RGltZW5zaW9uc1sxXSA9IGlucHV0LmZyYW1lLmhlaWdodDtcbiAgICBmaWx0ZXJNYW5hZ2VyLmFwcGx5RmlsdGVyKHRoaXMsIGlucHV0LCBvdXRwdXQsIGNsZWFyTW9kZSk7XG4gIH1cbiAgLyoqIEEgc3ByaXRlIHdoZXJlIHlvdXIgbGlnaHRtYXAgaXMgcmVuZGVyZWQgKi9cbiAgZ2V0IGxpZ2h0TWFwKCkge1xuICAgIHJldHVybiB0aGlzLl9saWdodE1hcDtcbiAgfVxuICBzZXQgbGlnaHRNYXAodmFsdWUpIHtcbiAgICB0aGlzLl9saWdodE1hcCA9IHZhbHVlO1xuICAgIHRoaXMucmVzb3VyY2VzLnVNYXBUZXh0dXJlID0gdmFsdWUuc291cmNlO1xuICAgIHRoaXMucmVzb3VyY2VzLnVNYXBTYW1wbGVyID0gdmFsdWUuc291cmNlLnN0eWxlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgY29sb3IgdmFsdWUgb2YgdGhlIGFtYmllbnQgY29sb3JcbiAgICogQGV4YW1wbGUgWzEuMCwgMS4wLCAxLjBdID0gMHhmZmZmZmZcbiAgICogQGRlZmF1bHQgMHgwMDAwMDBcbiAgICovXG4gIGdldCBjb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5fY29sb3IudmFsdWU7XG4gIH1cbiAgc2V0IGNvbG9yKHZhbHVlKSB7XG4gICAgdGhpcy5fY29sb3Iuc2V0VmFsdWUodmFsdWUpO1xuICAgIGNvbnN0IFtyLCBnLCBiXSA9IHRoaXMuX2NvbG9yLnRvQXJyYXkoKTtcbiAgICB0aGlzLnVuaWZvcm1zLnVDb2xvclswXSA9IHI7XG4gICAgdGhpcy51bmlmb3Jtcy51Q29sb3JbMV0gPSBnO1xuICAgIHRoaXMudW5pZm9ybXMudUNvbG9yWzJdID0gYjtcbiAgfVxuICAvKipcbiAgICogQ29lZmZpY2llbnQgZm9yIGFscGhhIG11bHRpcGxpY2F0aW9uXG4gICAqIEBkZWZhdWx0IDFcbiAgICovXG4gIGdldCBhbHBoYSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy51QWxwaGE7XG4gIH1cbiAgc2V0IGFscGhhKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy51QWxwaGEgPSB2YWx1ZTtcbiAgfVxufTtcbi8qKiBEZWZhdWx0IHZhbHVlcyBmb3Igb3B0aW9ucy4gKi9cbl9fcHVibGljRmllbGQoX1NpbXBsZUxpZ2h0bWFwRmlsdGVyLCBcIkRFRkFVTFRfT1BUSU9OU1wiLCB7XG4gIGxpZ2h0TWFwOiBUZXh0dXJlLldISVRFLFxuICBjb2xvcjogMCxcbiAgYWxwaGE6IDFcbn0pO1xubGV0IFNpbXBsZUxpZ2h0bWFwRmlsdGVyID0gX1NpbXBsZUxpZ2h0bWFwRmlsdGVyO1xuXG5leHBvcnQgeyBTaW1wbGVMaWdodG1hcEZpbHRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2ltcGxlTGlnaHRtYXBGaWx0ZXIubWpzLm1hcFxuIiwidmFyIHNvdXJjZSA9IFwic3RydWN0IFNpbXBsZUxpZ2h0bWFwVW5pZm9ybXMge1xcbiAgdUNvbG9yOiB2ZWMzPGYzMj4sXFxuICB1QWxwaGE6IGYzMixcXG4gIHVEaW1lbnNpb25zOiB2ZWMyPGYzMj4sXFxufTtcXG5cXG5zdHJ1Y3QgR2xvYmFsRmlsdGVyVW5pZm9ybXMge1xcbiAgdUlucHV0U2l6ZTp2ZWM0PGYzMj4sXFxuICB1SW5wdXRQaXhlbDp2ZWM0PGYzMj4sXFxuICB1SW5wdXRDbGFtcDp2ZWM0PGYzMj4sXFxuICB1T3V0cHV0RnJhbWU6dmVjNDxmMzI+LFxcbiAgdUdsb2JhbEZyYW1lOnZlYzQ8ZjMyPixcXG4gIHVPdXRwdXRUZXh0dXJlOnZlYzQ8ZjMyPixcXG59O1xcblxcbkBncm91cCgwKSBAYmluZGluZygwKSB2YXI8dW5pZm9ybT4gZ2Z1OiBHbG9iYWxGaWx0ZXJVbmlmb3JtcztcXG5cXG5AZ3JvdXAoMCkgQGJpbmRpbmcoMSkgdmFyIHVUZXh0dXJlOiB0ZXh0dXJlXzJkPGYzMj47IFxcbkBncm91cCgwKSBAYmluZGluZygyKSB2YXIgdVNhbXBsZXI6IHNhbXBsZXI7XFxuQGdyb3VwKDEpIEBiaW5kaW5nKDApIHZhcjx1bmlmb3JtPiBzaW1wbGVMaWdodG1hcFVuaWZvcm1zIDogU2ltcGxlTGlnaHRtYXBVbmlmb3JtcztcXG5AZ3JvdXAoMSkgQGJpbmRpbmcoMSkgdmFyIHVNYXBUZXh0dXJlOiB0ZXh0dXJlXzJkPGYzMj47XFxuQGdyb3VwKDEpIEBiaW5kaW5nKDIpIHZhciB1TWFwU2FtcGxlcjogc2FtcGxlcjtcXG5cXG5AZnJhZ21lbnRcXG5mbiBtYWluRnJhZ21lbnQoXFxuICBAYnVpbHRpbihwb3NpdGlvbikgcG9zaXRpb246IHZlYzQ8ZjMyPixcXG4gIEBsb2NhdGlvbigwKSB1diA6IHZlYzI8ZjMyPixcXG4pIC0+IEBsb2NhdGlvbigwKSB2ZWM0PGYzMj4ge1xcbiAgbGV0IHVDb2xvciA9IHNpbXBsZUxpZ2h0bWFwVW5pZm9ybXMudUNvbG9yO1xcbiAgbGV0IHVBbHBoYSA9IHNpbXBsZUxpZ2h0bWFwVW5pZm9ybXMudUFscGhhO1xcbiAgbGV0IHVEaW1lbnNpb25zID0gc2ltcGxlTGlnaHRtYXBVbmlmb3Jtcy51RGltZW5zaW9ucztcXG5cXG4gIGxldCBkaWZmdXNlQ29sb3I6IHZlYzQ8ZjMyPiA9IHRleHR1cmVTYW1wbGUodVRleHR1cmUsIHVTYW1wbGVyLCB1dik7XFxuICBsZXQgbGlnaHRDb29yZDogdmVjMjxmMzI+ID0gKHV2ICogZ2Z1LnVJbnB1dFNpemUueHkpIC8gc2ltcGxlTGlnaHRtYXBVbmlmb3Jtcy51RGltZW5zaW9ucztcXG4gIGxldCBsaWdodDogdmVjNDxmMzI+ID0gdGV4dHVyZVNhbXBsZSh1TWFwVGV4dHVyZSwgdU1hcFNhbXBsZXIsIGxpZ2h0Q29vcmQpO1xcbiAgbGV0IGFtYmllbnQ6IHZlYzM8ZjMyPiA9IHVDb2xvciAqIHVBbHBoYTtcXG4gIGxldCBpbnRlbnNpdHk6IHZlYzM8ZjMyPiA9IGFtYmllbnQgKyBsaWdodC5yZ2I7XFxuICBsZXQgZmluYWxDb2xvcjogdmVjMzxmMzI+ID0gZGlmZnVzZUNvbG9yLnJnYiAqIGludGVuc2l0eTtcXG4gIHJldHVybiB2ZWM0PGYzMj4oZmluYWxDb2xvciwgZGlmZnVzZUNvbG9yLmEpO1xcbn1cIjtcblxuZXhwb3J0IHsgc291cmNlIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpbXBsZS1saWdodG1hcDIubWpzLm1hcFxuIiwidmFyIGZyYWdtZW50ID0gXCJpbiB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxub3V0IHZlYzQgZmluYWxDb2xvcjtcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG51bmlmb3JtIHZlYzIgdUJsdXI7XFxudW5pZm9ybSB2ZWMyIHVTdGFydDtcXG51bmlmb3JtIHZlYzIgdUVuZDtcXG51bmlmb3JtIHZlYzIgdURlbHRhO1xcbnVuaWZvcm0gdmVjMiB1RGltZW5zaW9ucztcXG5cXG5mbG9hdCByYW5kb20odmVjMyBzY2FsZSwgZmxvYXQgc2VlZClcXG57XFxuICAgIHJldHVybiBmcmFjdChzaW4oZG90KGdsX0ZyYWdDb29yZC54eXogKyBzZWVkLCBzY2FsZSkpICogNDM3NTguNTQ1MyArIHNlZWQpO1xcbn1cXG5cXG52b2lkIG1haW4odm9pZClcXG57XFxuICAgIHZlYzQgY29sb3IgPSB2ZWM0KDAuMCk7XFxuICAgIGZsb2F0IHRvdGFsID0gMC4wO1xcblxcbiAgICBmbG9hdCBibHVyID0gdUJsdXJbMF07XFxuICAgIGZsb2F0IGdyYWRpZW50Qmx1ciA9IHVCbHVyWzFdO1xcblxcbiAgICBmbG9hdCBvZmZzZXQgPSByYW5kb20odmVjMygxMi45ODk4LCA3OC4yMzMsIDE1MS43MTgyKSwgMC4wKTtcXG4gICAgdmVjMiBub3JtYWwgPSBub3JtYWxpemUodmVjMih1U3RhcnQueSAtIHVFbmQueSwgdUVuZC54IC0gdVN0YXJ0LngpKTtcXG4gICAgZmxvYXQgcmFkaXVzID0gc21vb3Roc3RlcCgwLjAsIDEuMCwgYWJzKGRvdCh2VGV4dHVyZUNvb3JkICogdURpbWVuc2lvbnMgLSB1U3RhcnQsIG5vcm1hbCkpIC8gZ3JhZGllbnRCbHVyKSAqIGJsdXI7XFxuXFxuICAgIGZvciAoZmxvYXQgdCA9IC0zMC4wOyB0IDw9IDMwLjA7IHQrKylcXG4gICAge1xcbiAgICAgICAgZmxvYXQgcGVyY2VudCA9ICh0ICsgb2Zmc2V0IC0gMC41KSAvIDMwLjA7XFxuICAgICAgICBmbG9hdCB3ZWlnaHQgPSAxLjAgLSBhYnMocGVyY2VudCk7XFxuICAgICAgICB2ZWM0IHNhbXBsZSA9IHRleHR1cmUodVRleHR1cmUsIHZUZXh0dXJlQ29vcmQgKyB1RGVsdGEgLyB1RGltZW5zaW9ucyAqIHBlcmNlbnQgKiByYWRpdXMpO1xcbiAgICAgICAgc2FtcGxlLnJnYiAqPSBzYW1wbGUuYTtcXG4gICAgICAgIGNvbG9yICs9IHNhbXBsZSAqIHdlaWdodDtcXG4gICAgICAgIHRvdGFsICs9IHdlaWdodDtcXG4gICAgfVxcblxcbiAgICBjb2xvciAvPSB0b3RhbDtcXG4gICAgY29sb3IucmdiIC89IGNvbG9yLmEgKyAwLjAwMDAxO1xcblxcbiAgICBmaW5hbENvbG9yID0gY29sb3I7XFxufVxcblwiO1xuXG5leHBvcnQgeyBmcmFnbWVudCBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aWx0LXNoaWZ0Mi5tanMubWFwXG4iLCJpbXBvcnQgeyBGaWx0ZXIsIFZpZXdTeXN0ZW0sIEdwdVByb2dyYW0sIEdsUHJvZ3JhbSB9IGZyb20gJ3BpeGkuanMnO1xuaW1wb3J0IHZlcnRleCBmcm9tICcuLi9kZWZhdWx0cy9kZWZhdWx0Mi5tanMnO1xuaW1wb3J0IHdnc2xWZXJ0ZXggZnJvbSAnLi4vZGVmYXVsdHMvZGVmYXVsdC5tanMnO1xuaW1wb3J0IGZyYWdtZW50IGZyb20gJy4vdGlsdC1zaGlmdDIubWpzJztcbmltcG9ydCBzb3VyY2UgZnJvbSAnLi90aWx0LXNoaWZ0Lm1qcyc7XG5cbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbmNvbnN0IF9UaWx0U2hpZnRBeGlzRmlsdGVyID0gY2xhc3MgX1RpbHRTaGlmdEF4aXNGaWx0ZXIgZXh0ZW5kcyBGaWx0ZXIge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBWaWV3U3lzdGVtLmRlZmF1bHRPcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICAuLi5fVGlsdFNoaWZ0QXhpc0ZpbHRlci5ERUZBVUxUX09QVElPTlMsXG4gICAgICAvKiogVGhlIHBvc2l0aW9uIHRvIHN0YXJ0IHRoZSBlZmZlY3QgYXQuICovXG4gICAgICBzdGFydDogeyB4OiAwLCB5OiBoZWlnaHQgLyAyIH0sXG4gICAgICAvKiogVGhlIHBvc2l0aW9uIHRvIGVuZCB0aGUgZWZmZWN0IGF0LiAqL1xuICAgICAgZW5kOiB7IHg6IHdpZHRoLCB5OiBoZWlnaHQgLyAyIH0sXG4gICAgICAuLi5vcHRpb25zXG4gICAgfTtcbiAgICBjb25zdCBncHVQcm9ncmFtID0gR3B1UHJvZ3JhbS5mcm9tKHtcbiAgICAgIHZlcnRleDoge1xuICAgICAgICBzb3VyY2U6IHdnc2xWZXJ0ZXgsXG4gICAgICAgIGVudHJ5UG9pbnQ6IFwibWFpblZlcnRleFwiXG4gICAgICB9LFxuICAgICAgZnJhZ21lbnQ6IHtcbiAgICAgICAgc291cmNlLFxuICAgICAgICBlbnRyeVBvaW50OiBcIm1haW5GcmFnbWVudFwiXG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgZ2xQcm9ncmFtID0gR2xQcm9ncmFtLmZyb20oe1xuICAgICAgdmVydGV4LFxuICAgICAgZnJhZ21lbnQsXG4gICAgICBuYW1lOiBcInRpbHQtc2hpZnQtYXhpcy1maWx0ZXJcIlxuICAgIH0pO1xuICAgIHN1cGVyKHtcbiAgICAgIGdwdVByb2dyYW0sXG4gICAgICBnbFByb2dyYW0sXG4gICAgICByZXNvdXJjZXM6IHtcbiAgICAgICAgdGlsdFNoaWZ0VW5pZm9ybXM6IHtcbiAgICAgICAgICB1Qmx1cjoge1xuICAgICAgICAgICAgdmFsdWU6IG5ldyBGbG9hdDMyQXJyYXkoW1xuICAgICAgICAgICAgICBvcHRpb25zLmJsdXIsXG4gICAgICAgICAgICAgIG9wdGlvbnMuZ3JhZGllbnRCbHVyXG4gICAgICAgICAgICBdKSxcbiAgICAgICAgICAgIHR5cGU6IFwidmVjMjxmMzI+XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIHVTdGFydDogeyB2YWx1ZTogb3B0aW9ucy5zdGFydCwgdHlwZTogXCJ2ZWMyPGYzMj5cIiB9LFxuICAgICAgICAgIHVFbmQ6IHsgdmFsdWU6IG9wdGlvbnMuZW5kLCB0eXBlOiBcInZlYzI8ZjMyPlwiIH0sXG4gICAgICAgICAgdURlbHRhOiB7IHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KFswLCAwXSksIHR5cGU6IFwidmVjMjxmMzI+XCIgfSxcbiAgICAgICAgICB1RGltZW5zaW9uczogeyB2YWx1ZTogbmV3IEZsb2F0MzJBcnJheShbd2lkdGgsIGhlaWdodF0pLCB0eXBlOiBcInZlYzI8ZjMyPlwiIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ1bmlmb3Jtc1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX3RpbHRBeGlzXCIpO1xuICAgIHRoaXMudW5pZm9ybXMgPSB0aGlzLnJlc291cmNlcy50aWx0U2hpZnRVbmlmb3Jtcy51bmlmb3JtcztcbiAgICB0aGlzLl90aWx0QXhpcyA9IG9wdGlvbnMuYXhpcztcbiAgfVxuICAvKipcbiAgICogVXBkYXRlIHRoZSBkaW1lbnNpb25zXG4gICAqIEBpZ25vcmVcbiAgKi9cbiAgdXBkYXRlRGltZW5zaW9ucyhpbnB1dCkge1xuICAgIGNvbnN0IHsgdURpbWVuc2lvbnMgfSA9IHRoaXMudW5pZm9ybXM7XG4gICAgdURpbWVuc2lvbnNbMF0gPSBpbnB1dC5mcmFtZS53aWR0aDtcbiAgICB1RGltZW5zaW9uc1sxXSA9IGlucHV0LmZyYW1lLmhlaWdodDtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgZmlsdGVyIGRlbHRhIHZhbHVlcy5cbiAgICogQGlnbm9yZVxuICAgKi9cbiAgdXBkYXRlRGVsdGEoKSB7XG4gICAgdGhpcy51bmlmb3Jtcy51RGVsdGFbMF0gPSAwO1xuICAgIHRoaXMudW5pZm9ybXMudURlbHRhWzFdID0gMDtcbiAgICBpZiAodGhpcy5fdGlsdEF4aXMgPT09IHZvaWQgMClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBlbmQgPSB0aGlzLnVuaWZvcm1zLnVFbmQ7XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLnVuaWZvcm1zLnVTdGFydDtcbiAgICBjb25zdCBkeCA9IGVuZC54IC0gc3RhcnQueDtcbiAgICBjb25zdCBkeSA9IGVuZC55IC0gc3RhcnQueTtcbiAgICBjb25zdCBkID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICBjb25zdCBpc1ZlcnQgPSB0aGlzLl90aWx0QXhpcyA9PT0gXCJ2ZXJ0aWNhbFwiO1xuICAgIHRoaXMudW5pZm9ybXMudURlbHRhWzBdID0gIWlzVmVydCA/IGR4IC8gZCA6IC1keSAvIGQ7XG4gICAgdGhpcy51bmlmb3Jtcy51RGVsdGFbMV0gPSAhaXNWZXJ0ID8gZHkgLyBkIDogZHggLyBkO1xuICB9XG59O1xuLyoqIERlZmF1bHQgdmFsdWVzIGZvciBvcHRpb25zLiAqL1xuX19wdWJsaWNGaWVsZChfVGlsdFNoaWZ0QXhpc0ZpbHRlciwgXCJERUZBVUxUX09QVElPTlNcIiwge1xuICAvKiogVGhlIHN0cmVuZ3RoIG9mIHRoZSBibHVyLiAqL1xuICBibHVyOiAxMDAsXG4gIC8qKiBUaGUgc3RyZW5ndGggb2YgdGhlIGJsdXIgZ3JhZGllbnQgKi9cbiAgZ3JhZGllbnRCbHVyOiA2MDBcbn0pO1xubGV0IFRpbHRTaGlmdEF4aXNGaWx0ZXIgPSBfVGlsdFNoaWZ0QXhpc0ZpbHRlcjtcblxuZXhwb3J0IHsgVGlsdFNoaWZ0QXhpc0ZpbHRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGlsdFNoaWZ0QXhpc0ZpbHRlci5tanMubWFwXG4iLCJ2YXIgc291cmNlID0gXCJzdHJ1Y3QgVGlsdFNoaWZ0VW5pZm9ybXMge1xcbiAgdUJsdXI6IHZlYzI8ZjMyPixcXG4gIHVTdGFydDogdmVjMjxmMzI+LFxcbiAgdUVuZDogdmVjMjxmMzI+LFxcbiAgdURlbHRhOiB2ZWMyPGYzMj4sXFxuICB1RGltZW5zaW9uczogdmVjMjxmMzI+LFxcbn07XFxuXFxuQGdyb3VwKDApIEBiaW5kaW5nKDEpIHZhciB1VGV4dHVyZTogdGV4dHVyZV8yZDxmMzI+OyBcXG5AZ3JvdXAoMCkgQGJpbmRpbmcoMikgdmFyIHVTYW1wbGVyOiBzYW1wbGVyO1xcbkBncm91cCgxKSBAYmluZGluZygwKSB2YXI8dW5pZm9ybT4gdGlsdFNoaWZ0VW5pZm9ybXMgOiBUaWx0U2hpZnRVbmlmb3JtcztcXG5cXG5AZnJhZ21lbnRcXG5mbiBtYWluRnJhZ21lbnQoXFxuICBAYnVpbHRpbihwb3NpdGlvbikgcG9zaXRpb246IHZlYzQ8ZjMyPixcXG4gIEBsb2NhdGlvbigwKSB1diA6IHZlYzI8ZjMyPlxcbikgLT4gQGxvY2F0aW9uKDApIHZlYzQ8ZjMyPiB7XFxuICBsZXQgdUJsdXIgPSB0aWx0U2hpZnRVbmlmb3Jtcy51Qmx1clswXTtcXG4gIGxldCB1Qmx1ckdyYWRpZW50ID0gdGlsdFNoaWZ0VW5pZm9ybXMudUJsdXJbMV07XFxuICBsZXQgdVN0YXJ0ID0gdGlsdFNoaWZ0VW5pZm9ybXMudVN0YXJ0O1xcbiAgbGV0IHVFbmQgPSB0aWx0U2hpZnRVbmlmb3Jtcy51RW5kO1xcbiAgbGV0IHVEZWx0YSA9IHRpbHRTaGlmdFVuaWZvcm1zLnVEZWx0YTtcXG4gIGxldCB1RGltZW5zaW9ucyA9IHRpbHRTaGlmdFVuaWZvcm1zLnVEaW1lbnNpb25zO1xcblxcbiAgdmFyIGNvbG9yOiB2ZWM0PGYzMj4gPSB2ZWM0PGYzMj4oMC4wKTtcXG4gIHZhciB0b3RhbDogZjMyID0gMC4wO1xcblxcbiAgbGV0IG9mZnNldDogZjMyID0gcmFuZG9tKHBvc2l0aW9uLCB2ZWMzPGYzMj4oMTIuOTg5OCwgNzguMjMzLCAxNTEuNzE4MiksIDAuMCk7XFxuICBsZXQgbm9ybWFsOiB2ZWMyPGYzMj4gPSBub3JtYWxpemUodmVjMjxmMzI+KHVTdGFydC55IC0gdUVuZC55LCB1RW5kLnggLSB1U3RhcnQueCkpO1xcbiAgbGV0IHJhZGl1czogZjMyID0gc21vb3Roc3RlcCgwLjAsIDEuMCwgYWJzKGRvdCh1diAqIHVEaW1lbnNpb25zIC0gdVN0YXJ0LCBub3JtYWwpKSAvIHVCbHVyR3JhZGllbnQpICogdUJsdXI7XFxuXFxuICBmb3IgKHZhciB0OiBmMzIgPSAtMzAuMDsgdCA8PSAzMC4wOyB0ICs9IDEuMClcXG4gIHtcXG4gICAgdmFyIHBlcmNlbnQ6IGYzMiA9ICh0ICsgb2Zmc2V0IC0gMC41KSAvIDMwLjA7XFxuICAgIHZhciB3ZWlnaHQ6IGYzMiA9IDEuMCAtIGFicyhwZXJjZW50KTtcXG4gICAgdmFyIHNhbXBsZTogdmVjNDxmMzI+ID0gdGV4dHVyZVNhbXBsZSh1VGV4dHVyZSwgdVNhbXBsZXIsIHV2ICsgdURlbHRhIC8gdURpbWVuc2lvbnMgKiBwZXJjZW50ICogcmFkaXVzKTtcXG4gICAgc2FtcGxlID0gdmVjNDxmMzI+KHNhbXBsZS54eXogKiBzYW1wbGUuYSwgc2FtcGxlLmEpOyAvLyBtdWx0aXBseSBzYW1wbGUucmdiIHdpdGggc2FtcGxlLmFcXG4gICAgY29sb3IgKz0gc2FtcGxlICogd2VpZ2h0O1xcbiAgICB0b3RhbCArPSB3ZWlnaHQ7XFxuICB9XFxuXFxuICBjb2xvciAvPSB0b3RhbDtcXG4gIGNvbG9yID0gdmVjNDxmMzI+KGNvbG9yLnh5eiAvIChjb2xvci5hICsgMC4wMDAwMSksIGNvbG9yLmEpOyAvLyBkaXZpZGUgY29sb3IucmdiIGJ5IGNvbG9yLmEgKyAwLjAwMDAxXFxuXFxuICByZXR1cm4gY29sb3I7XFxufVxcblxcblxcbmZuIHJhbmRvbShwb3NpdGlvbjogdmVjNDxmMzI+LCBzY2FsZTogdmVjMzxmMzI+LCBzZWVkOiBmMzIpIC0+IGYzMlxcbntcXG4gIHJldHVybiBmcmFjdChzaW4oZG90KHBvc2l0aW9uLnh5eiArIHNlZWQsIHNjYWxlKSkgKiA0Mzc1OC41NDUzICsgc2VlZCk7XFxufVwiO1xuXG5leHBvcnQgeyBzb3VyY2UgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGlsdC1zaGlmdC5tanMubWFwXG4iLCJpbXBvcnQgeyBUZXh0dXJlUG9vbCB9IGZyb20gJ3BpeGkuanMnO1xuaW1wb3J0IHsgVGlsdFNoaWZ0QXhpc0ZpbHRlciB9IGZyb20gJy4vVGlsdFNoaWZ0QXhpc0ZpbHRlci5tanMnO1xuXG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiB7XG4gIF9fZGVmTm9ybWFsUHJvcChvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5jbGFzcyBUaWx0U2hpZnRGaWx0ZXIgZXh0ZW5kcyBUaWx0U2hpZnRBeGlzRmlsdGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgdGhlIFRpbHRTaGlmdEZpbHRlciBjb25zdHJ1Y3Rvci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0geyAuLi5UaWx0U2hpZnRBeGlzRmlsdGVyLkRFRkFVTFRfT1BUSU9OUywgLi4ub3B0aW9ucyB9O1xuICAgIHN1cGVyKHsgLi4ub3B0aW9ucywgYXhpczogXCJob3Jpem9udGFsXCIgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl90aWx0U2hpZnRZRmlsdGVyXCIpO1xuICAgIHRoaXMuX3RpbHRTaGlmdFlGaWx0ZXIgPSBuZXcgVGlsdFNoaWZ0QXhpc0ZpbHRlcih7IC4uLm9wdGlvbnMsIGF4aXM6IFwidmVydGljYWxcIiB9KTtcbiAgICB0aGlzLnVwZGF0ZURlbHRhKCk7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogT3ZlcnJpZGUgZXhpc3RpbmcgYXBwbHkgbWV0aG9kIGluIGBGaWx0ZXJgXG4gICAqIEBvdmVycmlkZVxuICAgKiBAaWdub3JlXG4gICAqL1xuICBhcHBseShmaWx0ZXJNYW5hZ2VyLCBpbnB1dCwgb3V0cHV0LCBjbGVhck1vZGUpIHtcbiAgICBjb25zdCByZW5kZXJUYXJnZXQgPSBUZXh0dXJlUG9vbC5nZXRTYW1lU2l6ZVRleHR1cmUoaW5wdXQpO1xuICAgIHRoaXMudXBkYXRlRGltZW5zaW9ucyhpbnB1dCk7XG4gICAgdGhpcy5fdGlsdFNoaWZ0WUZpbHRlci51cGRhdGVEaW1lbnNpb25zKGlucHV0KTtcbiAgICBmaWx0ZXJNYW5hZ2VyLmFwcGx5RmlsdGVyKHRoaXMsIGlucHV0LCByZW5kZXJUYXJnZXQsIHRydWUpO1xuICAgIGZpbHRlck1hbmFnZXIuYXBwbHlGaWx0ZXIodGhpcy5fdGlsdFNoaWZ0WUZpbHRlciwgcmVuZGVyVGFyZ2V0LCBvdXRwdXQsIGNsZWFyTW9kZSk7XG4gICAgVGV4dHVyZVBvb2wucmV0dXJuVGV4dHVyZShyZW5kZXJUYXJnZXQpO1xuICB9XG4gIC8qKiBAaWdub3JlICovXG4gIHVwZGF0ZURlbHRhKCkge1xuICAgIHN1cGVyLnVwZGF0ZURlbHRhKCk7XG4gICAgdGhpcy5fdGlsdFNoaWZ0WUZpbHRlci51cGRhdGVEZWx0YSgpO1xuICB9XG4gIC8qKiBUaGUgc3RyZW5ndGggb2YgdGhlIGJsdXIuICovXG4gIGdldCBibHVyKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnVCbHVyWzBdO1xuICB9XG4gIHNldCBibHVyKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy51Qmx1clswXSA9IHRoaXMuX3RpbHRTaGlmdFlGaWx0ZXIudW5pZm9ybXMudUJsdXJbMF0gPSB2YWx1ZTtcbiAgfVxuICAvKiogVGhlIHN0cmVuZ3RoIG9mIHRoZSBncmFkaWVudCBibHVyLiAqL1xuICBnZXQgZ3JhZGllbnRCbHVyKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnVCbHVyWzFdO1xuICB9XG4gIHNldCBncmFkaWVudEJsdXIodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnVCbHVyWzFdID0gdGhpcy5fdGlsdFNoaWZ0WUZpbHRlci51bmlmb3Jtcy51Qmx1clsxXSA9IHZhbHVlO1xuICB9XG4gIC8qKiBUaGUgcG9zaXRpb24gdG8gc3RhcnQgdGhlIGVmZmVjdCBhdC4gKi9cbiAgZ2V0IHN0YXJ0KCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnVTdGFydDtcbiAgfVxuICBzZXQgc3RhcnQodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnVTdGFydCA9IHRoaXMuX3RpbHRTaGlmdFlGaWx0ZXIudW5pZm9ybXMudVN0YXJ0ID0gdmFsdWU7XG4gICAgdGhpcy51cGRhdGVEZWx0YSgpO1xuICB9XG4gIC8qKiBUaGUgcG9zaXRpb24gdG8gc3RhcnQgdGhlIGVmZmVjdCBhdCBvbiB0aGUgYHhgIGF4aXMuICovXG4gIGdldCBzdGFydFgoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhcnQueDtcbiAgfVxuICBzZXQgc3RhcnRYKHZhbHVlKSB7XG4gICAgdGhpcy5zdGFydC54ID0gdmFsdWU7XG4gICAgdGhpcy51cGRhdGVEZWx0YSgpO1xuICB9XG4gIC8qKiBUaGUgcG9zaXRpb24gdG8gc3RhcnQgdGhlIGVmZmVjdCBhdCBvbiB0aGUgYHhgIGF4aXMuICovXG4gIGdldCBzdGFydFkoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhcnQueTtcbiAgfVxuICBzZXQgc3RhcnRZKHZhbHVlKSB7XG4gICAgdGhpcy5zdGFydC55ID0gdmFsdWU7XG4gICAgdGhpcy51cGRhdGVEZWx0YSgpO1xuICB9XG4gIC8qKiBUaGUgcG9zaXRpb24gdG8gZW5kIHRoZSBlZmZlY3QgYXQuICovXG4gIGdldCBlbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMudUVuZDtcbiAgfVxuICBzZXQgZW5kKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy51RW5kID0gdGhpcy5fdGlsdFNoaWZ0WUZpbHRlci51bmlmb3Jtcy51RW5kID0gdmFsdWU7XG4gICAgdGhpcy51cGRhdGVEZWx0YSgpO1xuICB9XG4gIC8qKiBUaGUgcG9zaXRpb24gdG8gZW5kIHRoZSBlZmZlY3QgYXQgb24gdGhlIGB4YCBheGlzLiAqL1xuICBnZXQgZW5kWCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbmQueDtcbiAgfVxuICBzZXQgZW5kWCh2YWx1ZSkge1xuICAgIHRoaXMuZW5kLnggPSB2YWx1ZTtcbiAgICB0aGlzLnVwZGF0ZURlbHRhKCk7XG4gIH1cbiAgLyoqIFRoZSBwb3NpdGlvbiB0byBlbmQgdGhlIGVmZmVjdCBhdCBvbiB0aGUgYHlgIGF4aXMuICovXG4gIGdldCBlbmRZKCkge1xuICAgIHJldHVybiB0aGlzLmVuZC55O1xuICB9XG4gIHNldCBlbmRZKHZhbHVlKSB7XG4gICAgdGhpcy5lbmQueSA9IHZhbHVlO1xuICAgIHRoaXMudXBkYXRlRGVsdGEoKTtcbiAgfVxufVxuXG5leHBvcnQgeyBUaWx0U2hpZnRGaWx0ZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRpbHRTaGlmdEZpbHRlci5tanMubWFwXG4iLCJ2YXIgZnJhZ21lbnQgPSBcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5pbiB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxub3V0IHZlYzQgZmluYWxDb2xvcjtcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG51bmlmb3JtIHZlYzIgdVR3aXN0O1xcbnVuaWZvcm0gdmVjMiB1T2Zmc2V0O1xcbnVuaWZvcm0gdmVjNCB1SW5wdXRTaXplO1xcblxcbnZlYzIgbWFwQ29vcmQoIHZlYzIgY29vcmQgKVxcbntcXG4gICAgY29vcmQgKj0gdUlucHV0U2l6ZS54eTtcXG4gICAgY29vcmQgKz0gdUlucHV0U2l6ZS56dztcXG5cXG4gICAgcmV0dXJuIGNvb3JkO1xcbn1cXG5cXG52ZWMyIHVubWFwQ29vcmQoIHZlYzIgY29vcmQgKVxcbntcXG4gICAgY29vcmQgLT0gdUlucHV0U2l6ZS56dztcXG4gICAgY29vcmQgLz0gdUlucHV0U2l6ZS54eTtcXG5cXG4gICAgcmV0dXJuIGNvb3JkO1xcbn1cXG5cXG52ZWMyIHR3aXN0KHZlYzIgY29vcmQpXFxue1xcbiAgICBjb29yZCAtPSB1T2Zmc2V0O1xcblxcbiAgICBmbG9hdCBkaXN0ID0gbGVuZ3RoKGNvb3JkKTtcXG4gICAgZmxvYXQgdVJhZGl1cyA9IHVUd2lzdFswXTtcXG4gICAgZmxvYXQgdUFuZ2xlID0gdVR3aXN0WzFdO1xcblxcbiAgICBpZiAoZGlzdCA8IHVSYWRpdXMpXFxuICAgIHtcXG4gICAgICAgIGZsb2F0IHJhdGlvRGlzdCA9ICh1UmFkaXVzIC0gZGlzdCkgLyB1UmFkaXVzO1xcbiAgICAgICAgZmxvYXQgYW5nbGVNb2QgPSByYXRpb0Rpc3QgKiByYXRpb0Rpc3QgKiB1QW5nbGU7XFxuICAgICAgICBmbG9hdCBzID0gc2luKGFuZ2xlTW9kKTtcXG4gICAgICAgIGZsb2F0IGMgPSBjb3MoYW5nbGVNb2QpO1xcbiAgICAgICAgY29vcmQgPSB2ZWMyKGNvb3JkLnggKiBjIC0gY29vcmQueSAqIHMsIGNvb3JkLnggKiBzICsgY29vcmQueSAqIGMpO1xcbiAgICB9XFxuXFxuICAgIGNvb3JkICs9IHVPZmZzZXQ7XFxuXFxuICAgIHJldHVybiBjb29yZDtcXG59XFxuXFxudm9pZCBtYWluKHZvaWQpXFxue1xcbiAgICB2ZWMyIGNvb3JkID0gbWFwQ29vcmQodlRleHR1cmVDb29yZCk7XFxuICAgIGNvb3JkID0gdHdpc3QoY29vcmQpO1xcbiAgICBjb29yZCA9IHVubWFwQ29vcmQoY29vcmQpO1xcbiAgICBmaW5hbENvbG9yID0gdGV4dHVyZSh1VGV4dHVyZSwgY29vcmQpO1xcbn1cXG5cIjtcblxuZXhwb3J0IHsgZnJhZ21lbnQgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHdpc3QubWpzLm1hcFxuIiwiaW1wb3J0IHsgRmlsdGVyLCBHcHVQcm9ncmFtLCBHbFByb2dyYW0gfSBmcm9tICdwaXhpLmpzJztcbmltcG9ydCB2ZXJ0ZXggZnJvbSAnLi4vZGVmYXVsdHMvZGVmYXVsdDIubWpzJztcbmltcG9ydCB3Z3NsVmVydGV4IGZyb20gJy4uL2RlZmF1bHRzL2RlZmF1bHQubWpzJztcbmltcG9ydCBmcmFnbWVudCBmcm9tICcuL3R3aXN0Lm1qcyc7XG5pbXBvcnQgc291cmNlIGZyb20gJy4vdHdpc3QyLm1qcyc7XG5cbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbmNvbnN0IF9Ud2lzdEZpbHRlciA9IGNsYXNzIF9Ud2lzdEZpbHRlciBleHRlbmRzIEZpbHRlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIHRoZSBUd2lzdEZpbHRlciBjb25zdHJ1Y3Rvci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0geyAuLi5fVHdpc3RGaWx0ZXIuREVGQVVMVF9PUFRJT05TLCAuLi5vcHRpb25zIH07XG4gICAgY29uc3QgZ3B1UHJvZ3JhbSA9IEdwdVByb2dyYW0uZnJvbSh7XG4gICAgICB2ZXJ0ZXg6IHtcbiAgICAgICAgc291cmNlOiB3Z3NsVmVydGV4LFxuICAgICAgICBlbnRyeVBvaW50OiBcIm1haW5WZXJ0ZXhcIlxuICAgICAgfSxcbiAgICAgIGZyYWdtZW50OiB7XG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgZW50cnlQb2ludDogXCJtYWluRnJhZ21lbnRcIlxuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGdsUHJvZ3JhbSA9IEdsUHJvZ3JhbS5mcm9tKHtcbiAgICAgIHZlcnRleCxcbiAgICAgIGZyYWdtZW50LFxuICAgICAgbmFtZTogXCJ0d2lzdC1maWx0ZXJcIlxuICAgIH0pO1xuICAgIHN1cGVyKHtcbiAgICAgIGdwdVByb2dyYW0sXG4gICAgICBnbFByb2dyYW0sXG4gICAgICByZXNvdXJjZXM6IHtcbiAgICAgICAgdHdpc3RVbmlmb3Jtczoge1xuICAgICAgICAgIHVUd2lzdDoge1xuICAgICAgICAgICAgdmFsdWU6IFtvcHRpb25zLnJhZGl1cyA/PyAwLCBvcHRpb25zLmFuZ2xlID8/IDBdLFxuICAgICAgICAgICAgdHlwZTogXCJ2ZWMyPGYzMj5cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgdU9mZnNldDoge1xuICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnMub2Zmc2V0LFxuICAgICAgICAgICAgdHlwZTogXCJ2ZWMyPGYzMj5cIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidW5pZm9ybXNcIik7XG4gICAgdGhpcy51bmlmb3JtcyA9IHRoaXMucmVzb3VyY2VzLnR3aXN0VW5pZm9ybXMudW5pZm9ybXM7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSByYWRpdXMgb2YgdGhlIHR3aXN0XG4gICAqIEBkZWZhdWx0IDIwMFxuICAgKi9cbiAgZ2V0IHJhZGl1cygpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy51VHdpc3RbMF07XG4gIH1cbiAgc2V0IHJhZGl1cyh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMudVR3aXN0WzBdID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBhbmdsZSBvZiB0aGUgdHdpc3RcbiAgICogQGRlZmF1bHQgNFxuICAgKi9cbiAgZ2V0IGFuZ2xlKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnVUd2lzdFsxXTtcbiAgfVxuICBzZXQgYW5nbGUodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnVUd2lzdFsxXSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYHhgIG9mZnNldCBjb29yZGluYXRlIHRvIGNoYW5nZSB0aGUgcG9zaXRpb24gb2YgdGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlIG9mIGVmZmVjdFxuICAgKiBAZGVmYXVsdCAwXG4gICAqL1xuICBnZXQgb2Zmc2V0KCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnVPZmZzZXQ7XG4gIH1cbiAgc2V0IG9mZnNldCh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMudU9mZnNldCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYHhgIG9mZnNldCBjb29yZGluYXRlIHRvIGNoYW5nZSB0aGUgcG9zaXRpb24gb2YgdGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlIG9mIGVmZmVjdFxuICAgKiBAZGVmYXVsdCAwXG4gICAqL1xuICBnZXQgb2Zmc2V0WCgpIHtcbiAgICByZXR1cm4gdGhpcy5vZmZzZXQueDtcbiAgfVxuICBzZXQgb2Zmc2V0WCh2YWx1ZSkge1xuICAgIHRoaXMub2Zmc2V0LnggPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGB5YCBvZmZzZXQgY29vcmRpbmF0ZSB0byBjaGFuZ2UgdGhlIHBvc2l0aW9uIG9mIHRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZSBvZiBlZmZlY3RcbiAgICogQGRlZmF1bHQgMFxuICAgKi9cbiAgZ2V0IG9mZnNldFkoKSB7XG4gICAgcmV0dXJuIHRoaXMub2Zmc2V0Lnk7XG4gIH1cbiAgc2V0IG9mZnNldFkodmFsdWUpIHtcbiAgICB0aGlzLm9mZnNldC55ID0gdmFsdWU7XG4gIH1cbn07XG4vKiogRGVmYXVsdCB2YWx1ZXMgZm9yIG9wdGlvbnMuICovXG5fX3B1YmxpY0ZpZWxkKF9Ud2lzdEZpbHRlciwgXCJERUZBVUxUX09QVElPTlNcIiwge1xuICBwYWRkaW5nOiAyMCxcbiAgcmFkaXVzOiAyMDAsXG4gIGFuZ2xlOiA0LFxuICBvZmZzZXQ6IHsgeDogMCwgeTogMCB9XG59KTtcbmxldCBUd2lzdEZpbHRlciA9IF9Ud2lzdEZpbHRlcjtcblxuZXhwb3J0IHsgVHdpc3RGaWx0ZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVR3aXN0RmlsdGVyLm1qcy5tYXBcbiIsInZhciBzb3VyY2UgPSBcInN0cnVjdCBUd2lzdFVuaWZvcm1zIHtcXG4gIHVUd2lzdDp2ZWMyPGYzMj4sXFxuICB1T2Zmc2V0OnZlYzI8ZjMyPixcXG59O1xcblxcbnN0cnVjdCBHbG9iYWxGaWx0ZXJVbmlmb3JtcyB7XFxuICB1SW5wdXRTaXplOnZlYzQ8ZjMyPixcXG4gIHVJbnB1dFBpeGVsOnZlYzQ8ZjMyPixcXG4gIHVJbnB1dENsYW1wOnZlYzQ8ZjMyPixcXG4gIHVPdXRwdXRGcmFtZTp2ZWM0PGYzMj4sXFxuICB1R2xvYmFsRnJhbWU6dmVjNDxmMzI+LFxcbiAgdU91dHB1dFRleHR1cmU6dmVjNDxmMzI+LFxcbn07XFxuXFxuQGdyb3VwKDApIEBiaW5kaW5nKDApIHZhcjx1bmlmb3JtPiBnZnU6IEdsb2JhbEZpbHRlclVuaWZvcm1zO1xcblxcbkBncm91cCgwKSBAYmluZGluZygxKSB2YXIgdVRleHR1cmU6IHRleHR1cmVfMmQ8ZjMyPjsgXFxuQGdyb3VwKDApIEBiaW5kaW5nKDIpIHZhciB1U2FtcGxlcjogc2FtcGxlcjtcXG5AZ3JvdXAoMSkgQGJpbmRpbmcoMCkgdmFyPHVuaWZvcm0+IHR3aXN0VW5pZm9ybXMgOiBUd2lzdFVuaWZvcm1zO1xcblxcbkBmcmFnbWVudFxcbmZuIG1haW5GcmFnbWVudChcXG4gIEBsb2NhdGlvbigwKSB1djogdmVjMjxmMzI+LFxcbiAgQGJ1aWx0aW4ocG9zaXRpb24pIHBvc2l0aW9uOiB2ZWM0PGYzMj5cXG4pIC0+IEBsb2NhdGlvbigwKSB2ZWM0PGYzMj4ge1xcbiAgcmV0dXJuIHRleHR1cmVTYW1wbGUodVRleHR1cmUsIHVTYW1wbGVyLCB1bm1hcENvb3JkKHR3aXN0KG1hcENvb3JkKHV2KSkpKTtcXG59XFxuXFxuZm4gbWFwQ29vcmQoY29vcmQ6IHZlYzI8ZjMyPiApIC0+IHZlYzI8ZjMyPlxcbntcXG4gIHZhciBtYXBwZWRDb29yZDogdmVjMjxmMzI+ID0gY29vcmQ7XFxuICBtYXBwZWRDb29yZCAqPSBnZnUudUlucHV0U2l6ZS54eTtcXG4gIG1hcHBlZENvb3JkICs9IGdmdS51T3V0cHV0RnJhbWUueHk7XFxuICByZXR1cm4gbWFwcGVkQ29vcmQ7XFxufVxcblxcbmZuIHVubWFwQ29vcmQoY29vcmQ6IHZlYzI8ZjMyPiApIC0+IHZlYzI8ZjMyPlxcbntcXG4gIHZhciBtYXBwZWRDb29yZDogdmVjMjxmMzI+ID0gY29vcmQ7XFxuICBtYXBwZWRDb29yZCAtPSBnZnUudU91dHB1dEZyYW1lLnh5O1xcbiAgbWFwcGVkQ29vcmQgLz0gZ2Z1LnVJbnB1dFNpemUueHk7XFxuICByZXR1cm4gbWFwcGVkQ29vcmQ7XFxufVxcblxcbmZuIHR3aXN0KGNvb3JkOiB2ZWMyPGYzMj4pIC0+IHZlYzI8ZjMyPlxcbntcXG4gIHZhciB0d2lzdGVkQ29vcmQ6IHZlYzI8ZjMyPiA9IGNvb3JkO1xcbiAgbGV0IHVSYWRpdXMgPSB0d2lzdFVuaWZvcm1zLnVUd2lzdFswXTtcXG4gIGxldCB1QW5nbGUgPSB0d2lzdFVuaWZvcm1zLnVUd2lzdFsxXTtcXG4gIGxldCB1T2Zmc2V0ID0gdHdpc3RVbmlmb3Jtcy51T2Zmc2V0O1xcblxcbiAgdHdpc3RlZENvb3JkIC09IHVPZmZzZXQ7XFxuICBcXG4gIGxldCBkaXN0ID0gbGVuZ3RoKHR3aXN0ZWRDb29yZCk7XFxuXFxuICBpZiAoZGlzdCA8IHVSYWRpdXMpXFxuICB7XFxuICAgIGxldCByYXRpb0Rpc3Q6IGYzMiA9ICh1UmFkaXVzIC0gZGlzdCkgLyB1UmFkaXVzO1xcbiAgICBsZXQgYW5nbGVNb2Q6IGYzMiA9IHJhdGlvRGlzdCAqIHJhdGlvRGlzdCAqIHVBbmdsZTtcXG4gICAgbGV0IHM6IGYzMiA9IHNpbihhbmdsZU1vZCk7XFxuICAgIGxldCBjOiBmMzIgPSBjb3MoYW5nbGVNb2QpO1xcbiAgICB0d2lzdGVkQ29vcmQgPSB2ZWMyPGYzMj4odHdpc3RlZENvb3JkLnggKiBjIC0gdHdpc3RlZENvb3JkLnkgKiBzLCB0d2lzdGVkQ29vcmQueCAqIHMgKyB0d2lzdGVkQ29vcmQueSAqIGMpO1xcbiAgfVxcblxcbiAgdHdpc3RlZENvb3JkICs9IHVPZmZzZXQ7XFxuICByZXR1cm4gdHdpc3RlZENvb3JkO1xcbn1cXG5cIjtcblxuZXhwb3J0IHsgc291cmNlIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR3aXN0Mi5tanMubWFwXG4iLCJ2YXIgZnJhZ21lbnQgPSBcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5pbiB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxub3V0IHZlYzQgZmluYWxDb2xvcjtcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG51bmlmb3JtIGZsb2F0IHVTdHJlbmd0aDtcXG51bmlmb3JtIHZlYzIgdUNlbnRlcjtcXG51bmlmb3JtIHZlYzIgdVJhZGlpO1xcblxcbnVuaWZvcm0gdmVjNCB1SW5wdXRTaXplO1xcblxcbmNvbnN0IGZsb2F0IE1BWF9LRVJORUxfU0laRSA9ICR7TUFYX0tFUk5FTF9TSVpFfTtcXG5cXG4vLyBhdXRob3I6IGh0dHA6Ly9ieXRlYmxhY2tzbWl0aC5jb20vaW1wcm92ZW1lbnRzLXRvLXRoZS1jYW5vbmljYWwtb25lLWxpbmVyLWdsc2wtcmFuZC1mb3Itb3BlbmdsLWVzLTItMC9cXG5oaWdocCBmbG9hdCByYW5kKHZlYzIgY28sIGZsb2F0IHNlZWQpIHtcXG4gICAgY29uc3QgaGlnaHAgZmxvYXQgYSA9IDEyLjk4OTgsIGIgPSA3OC4yMzMsIGMgPSA0Mzc1OC41NDUzO1xcbiAgICBoaWdocCBmbG9hdCBkdCA9IGRvdChjbyArIHNlZWQsIHZlYzIoYSwgYikpLCBzbiA9IG1vZChkdCwgMy4xNDE1OSk7XFxuICAgIHJldHVybiBmcmFjdChzaW4oc24pICogYyArIHNlZWQpO1xcbn1cXG5cXG52b2lkIG1haW4oKSB7XFxuICAgIGZsb2F0IG1pbkdyYWRpZW50ID0gdVJhZGlpWzBdICogMC4zO1xcbiAgICBmbG9hdCBpbm5lclJhZGl1cyA9ICh1UmFkaWlbMF0gKyBtaW5HcmFkaWVudCAqIDAuNSkgLyB1SW5wdXRTaXplLng7XFxuXFxuICAgIGZsb2F0IGdyYWRpZW50ID0gdVJhZGlpWzFdICogMC4zO1xcbiAgICBmbG9hdCByYWRpdXMgPSAodVJhZGlpWzFdIC0gZ3JhZGllbnQgKiAwLjUpIC8gdUlucHV0U2l6ZS54O1xcblxcbiAgICBmbG9hdCBjb3VudExpbWl0ID0gTUFYX0tFUk5FTF9TSVpFO1xcblxcbiAgICB2ZWMyIGRpciA9IHZlYzIodUNlbnRlci54eSAvIHVJbnB1dFNpemUueHkgLSB2VGV4dHVyZUNvb3JkKTtcXG4gICAgZmxvYXQgZGlzdCA9IGxlbmd0aCh2ZWMyKGRpci54LCBkaXIueSAqIHVJbnB1dFNpemUueSAvIHVJbnB1dFNpemUueCkpO1xcblxcbiAgICBmbG9hdCBzdHJlbmd0aCA9IHVTdHJlbmd0aDtcXG5cXG4gICAgZmxvYXQgZGVsdGEgPSAwLjA7XFxuICAgIGZsb2F0IGdhcDtcXG4gICAgaWYgKGRpc3QgPCBpbm5lclJhZGl1cykge1xcbiAgICAgICAgZGVsdGEgPSBpbm5lclJhZGl1cyAtIGRpc3Q7XFxuICAgICAgICBnYXAgPSBtaW5HcmFkaWVudDtcXG4gICAgfSBlbHNlIGlmIChyYWRpdXMgPj0gMC4wICYmIGRpc3QgPiByYWRpdXMpIHsgLy8gcmFkaXVzIDwgMCBtZWFucyBpdCdzIGluZmluaXR5XFxuICAgICAgICBkZWx0YSA9IGRpc3QgLSByYWRpdXM7XFxuICAgICAgICBnYXAgPSBncmFkaWVudDtcXG4gICAgfVxcblxcbiAgICBpZiAoZGVsdGEgPiAwLjApIHtcXG4gICAgICAgIGZsb2F0IG5vcm1hbENvdW50ID0gZ2FwIC8gdUlucHV0U2l6ZS54O1xcbiAgICAgICAgZGVsdGEgPSAobm9ybWFsQ291bnQgLSBkZWx0YSkgLyBub3JtYWxDb3VudDtcXG4gICAgICAgIGNvdW50TGltaXQgKj0gZGVsdGE7XFxuICAgICAgICBzdHJlbmd0aCAqPSBkZWx0YTtcXG4gICAgICAgIGlmIChjb3VudExpbWl0IDwgMS4wKVxcbiAgICAgICAge1xcbiAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUodVRleHR1cmUsIHZUZXh0dXJlQ29vcmQpO1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG4gICAgfVxcblxcbiAgICAvLyByYW5kb21pemUgdGhlIGxvb2t1cCB2YWx1ZXMgdG8gaGlkZSB0aGUgZml4ZWQgbnVtYmVyIG9mIHNhbXBsZXNcXG4gICAgZmxvYXQgb2Zmc2V0ID0gcmFuZCh2VGV4dHVyZUNvb3JkLCAwLjApO1xcblxcbiAgICBmbG9hdCB0b3RhbCA9IDAuMDtcXG4gICAgdmVjNCBjb2xvciA9IHZlYzQoMC4wKTtcXG5cXG4gICAgZGlyICo9IHN0cmVuZ3RoO1xcblxcbiAgICBmb3IgKGZsb2F0IHQgPSAwLjA7IHQgPCBNQVhfS0VSTkVMX1NJWkU7IHQrKykge1xcbiAgICAgICAgZmxvYXQgcGVyY2VudCA9ICh0ICsgb2Zmc2V0KSAvIE1BWF9LRVJORUxfU0laRTtcXG4gICAgICAgIGZsb2F0IHdlaWdodCA9IDQuMCAqIChwZXJjZW50IC0gcGVyY2VudCAqIHBlcmNlbnQpO1xcbiAgICAgICAgdmVjMiBwID0gdlRleHR1cmVDb29yZCArIGRpciAqIHBlcmNlbnQ7XFxuICAgICAgICB2ZWM0IHNhbXBsZSA9IHRleHR1cmUodVRleHR1cmUsIHApO1xcblxcbiAgICAgICAgLy8gc3dpdGNoIHRvIHByZS1tdWx0aXBsaWVkIGFscGhhIHRvIGNvcnJlY3RseSBibHVyIHRyYW5zcGFyZW50IGltYWdlc1xcbiAgICAgICAgLy8gc2FtcGxlLnJnYiAqPSBzYW1wbGUuYTtcXG5cXG4gICAgICAgIGNvbG9yICs9IHNhbXBsZSAqIHdlaWdodDtcXG4gICAgICAgIHRvdGFsICs9IHdlaWdodDtcXG5cXG4gICAgICAgIGlmICh0ID4gY291bnRMaW1pdCl7XFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICB9XFxuICAgIH1cXG5cXG4gICAgY29sb3IgLz0gdG90YWw7XFxuICAgIC8vIHN3aXRjaCBiYWNrIGZyb20gcHJlLW11bHRpcGxpZWQgYWxwaGFcXG4gICAgLy8gY29sb3IucmdiIC89IGNvbG9yLmEgKyAwLjAwMDAxO1xcblxcbiAgICBnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG59XFxuXCI7XG5cbmV4cG9ydCB7IGZyYWdtZW50IGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXpvb20tYmx1ci5tanMubWFwXG4iLCJpbXBvcnQgeyBGaWx0ZXIsIEdwdVByb2dyYW0sIEdsUHJvZ3JhbSB9IGZyb20gJ3BpeGkuanMnO1xuaW1wb3J0IHZlcnRleCBmcm9tICcuLi9kZWZhdWx0cy9kZWZhdWx0Mi5tanMnO1xuaW1wb3J0IHdnc2xWZXJ0ZXggZnJvbSAnLi4vZGVmYXVsdHMvZGVmYXVsdC5tanMnO1xuaW1wb3J0IGZyYWdtZW50IGZyb20gJy4vem9vbS1ibHVyLm1qcyc7XG5pbXBvcnQgc291cmNlIGZyb20gJy4vem9vbS1ibHVyMi5tanMnO1xuXG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiB7XG4gIF9fZGVmTm9ybWFsUHJvcChvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5jb25zdCBfWm9vbUJsdXJGaWx0ZXIgPSBjbGFzcyBfWm9vbUJsdXJGaWx0ZXIgZXh0ZW5kcyBGaWx0ZXIge1xuICAvKipcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGZvciB0aGUgWm9vbUJsdXJGaWx0ZXIgY29uc3RydWN0b3IuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHsgLi4uX1pvb21CbHVyRmlsdGVyLkRFRkFVTFRfT1BUSU9OUywgLi4ub3B0aW9ucyB9O1xuICAgIGNvbnN0IGtlcm5lbFNpemUgPSBvcHRpb25zLm1heEtlcm5lbFNpemUgPz8gMzI7XG4gICAgY29uc3QgZ3B1UHJvZ3JhbSA9IEdwdVByb2dyYW0uZnJvbSh7XG4gICAgICB2ZXJ0ZXg6IHtcbiAgICAgICAgc291cmNlOiB3Z3NsVmVydGV4LFxuICAgICAgICBlbnRyeVBvaW50OiBcIm1haW5WZXJ0ZXhcIlxuICAgICAgfSxcbiAgICAgIGZyYWdtZW50OiB7XG4gICAgICAgIHNvdXJjZTogc291cmNlLnJlcGxhY2UoXCIke01BWF9LRVJORUxfU0laRX1cIiwga2VybmVsU2l6ZS50b0ZpeGVkKDEpKSxcbiAgICAgICAgZW50cnlQb2ludDogXCJtYWluRnJhZ21lbnRcIlxuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGdsUHJvZ3JhbSA9IEdsUHJvZ3JhbS5mcm9tKHtcbiAgICAgIHZlcnRleCxcbiAgICAgIGZyYWdtZW50OiBmcmFnbWVudC5yZXBsYWNlKFwiJHtNQVhfS0VSTkVMX1NJWkV9XCIsIGtlcm5lbFNpemUudG9GaXhlZCgxKSksXG4gICAgICBuYW1lOiBcInpvb20tYmx1ci1maWx0ZXJcIlxuICAgIH0pO1xuICAgIHN1cGVyKHtcbiAgICAgIGdwdVByb2dyYW0sXG4gICAgICBnbFByb2dyYW0sXG4gICAgICByZXNvdXJjZXM6IHtcbiAgICAgICAgem9vbUJsdXJVbmlmb3Jtczoge1xuICAgICAgICAgIHVTdHJlbmd0aDogeyB2YWx1ZTogb3B0aW9ucy5zdHJlbmd0aCwgdHlwZTogXCJmMzJcIiB9LFxuICAgICAgICAgIHVDZW50ZXI6IHsgdmFsdWU6IG9wdGlvbnMuY2VudGVyLCB0eXBlOiBcInZlYzI8ZjMyPlwiIH0sXG4gICAgICAgICAgdVJhZGlpOiB7IHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KDIpLCB0eXBlOiBcInZlYzI8ZjMyPlwiIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ1bmlmb3Jtc1wiKTtcbiAgICB0aGlzLnVuaWZvcm1zID0gdGhpcy5yZXNvdXJjZXMuem9vbUJsdXJVbmlmb3Jtcy51bmlmb3JtcztcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzdHJlbmd0aCBvZiB0aGUgem9vbSBibHVyIGVmZmVjdFxuICAgKiBAZGVmYXVsdCAwLjFcbiAgICovXG4gIGdldCBzdHJlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy51U3RyZW5ndGg7XG4gIH1cbiAgc2V0IHN0cmVuZ3RoKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy51U3RyZW5ndGggPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGNlbnRlciBvZiB0aGUgem9vbVxuICAgKiBAZGVmYXVsdCBbMCwwXVxuICAgKi9cbiAgZ2V0IGNlbnRlcigpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy51Q2VudGVyO1xuICB9XG4gIHNldCBjZW50ZXIodmFsdWUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHZhbHVlID0geyB4OiB2YWx1ZVswXSwgeTogdmFsdWVbMV0gfTtcbiAgICB9XG4gICAgdGhpcy51bmlmb3Jtcy51Q2VudGVyID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGNlbnRlciBvZiB0aGUgZWZmZWN0IGluIG5vcm1hbGl6ZWQgc2NyZWVuIGNvb3JkcyBvbiB0aGUgYHhgIGF4aXNcbiAgICogQGRlZmF1bHQgMFxuICAgKi9cbiAgZ2V0IGNlbnRlclgoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMudUNlbnRlci54O1xuICB9XG4gIHNldCBjZW50ZXJYKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy51Q2VudGVyLnggPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgY2VudGVyIG9mIHRoZSBlZmZlY3QgaW4gbm9ybWFsaXplZCBzY3JlZW4gY29vcmRzIG9uIHRoZSBgeWAgYXhpc1xuICAgKiBAZGVmYXVsdCAwXG4gICAqL1xuICBnZXQgY2VudGVyWSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy51Q2VudGVyLnk7XG4gIH1cbiAgc2V0IGNlbnRlclkodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnVDZW50ZXIueSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgaW5uZXIgcmFkaXVzIG9mIHpvb20uIFRoZSBwYXJ0IGluIGlubmVyIGNpcmNsZSB3b24ndCBhcHBseSB6b29tIGJsdXIgZWZmZWN0XG4gICAqIEBkZWZhdWx0IDBcbiAgICovXG4gIGdldCBpbm5lclJhZGl1cygpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy51UmFkaWlbMF07XG4gIH1cbiAgc2V0IGlubmVyUmFkaXVzKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy51UmFkaWlbMF0gPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogT3V0ZXIgcmFkaXVzIG9mIHRoZSBlZmZlY3QuIGxlc3MgdGhhbiBgMGAgZXF1YXRlcyB0byBpbmZpbml0eVxuICAgKiBAZGVmYXVsdCAtMVxuICAgKi9cbiAgZ2V0IHJhZGl1cygpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy51UmFkaWlbMV07XG4gIH1cbiAgc2V0IHJhZGl1cyh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMudVJhZGlpWzFdID0gdmFsdWUgPCAwIHx8IHZhbHVlID09PSBJbmZpbml0eSA/IC0xIDogdmFsdWU7XG4gIH1cbn07XG4vKiogRGVmYXVsdCB2YWx1ZXMgZm9yIG9wdGlvbnMuICovXG5fX3B1YmxpY0ZpZWxkKF9ab29tQmx1ckZpbHRlciwgXCJERUZBVUxUX09QVElPTlNcIiwge1xuICBzdHJlbmd0aDogMC4xLFxuICBjZW50ZXI6IHsgeDogMCwgeTogMCB9LFxuICBpbm5lclJhZGl1czogMCxcbiAgcmFkaXVzOiAtMSxcbiAgbWF4S2VybmVsU2l6ZTogMzJcbn0pO1xubGV0IFpvb21CbHVyRmlsdGVyID0gX1pvb21CbHVyRmlsdGVyO1xuXG5leHBvcnQgeyBab29tQmx1ckZpbHRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Wm9vbUJsdXJGaWx0ZXIubWpzLm1hcFxuIiwidmFyIHNvdXJjZSA9IFwic3RydWN0IFpvb21CbHVyVW5pZm9ybXMge1xcbiAgICB1U3RyZW5ndGg6ZjMyLFxcbiAgICB1Q2VudGVyOnZlYzI8ZjMyPixcXG4gICAgdVJhZGlpOnZlYzI8ZjMyPixcXG59O1xcblxcbnN0cnVjdCBHbG9iYWxGaWx0ZXJVbmlmb3JtcyB7XFxuICB1SW5wdXRTaXplOnZlYzQ8ZjMyPixcXG4gIHVJbnB1dFBpeGVsOnZlYzQ8ZjMyPixcXG4gIHVJbnB1dENsYW1wOnZlYzQ8ZjMyPixcXG4gIHVPdXRwdXRGcmFtZTp2ZWM0PGYzMj4sXFxuICB1R2xvYmFsRnJhbWU6dmVjNDxmMzI+LFxcbiAgdU91dHB1dFRleHR1cmU6dmVjNDxmMzI+LFxcbn07XFxuXFxuQGdyb3VwKDApIEBiaW5kaW5nKDApIHZhcjx1bmlmb3JtPiBnZnU6IEdsb2JhbEZpbHRlclVuaWZvcm1zO1xcblxcbkBncm91cCgwKSBAYmluZGluZygxKSB2YXIgdVRleHR1cmU6IHRleHR1cmVfMmQ8ZjMyPjsgXFxuQGdyb3VwKDApIEBiaW5kaW5nKDIpIHZhciB1U2FtcGxlcjogc2FtcGxlcjtcXG5AZ3JvdXAoMSkgQGJpbmRpbmcoMCkgdmFyPHVuaWZvcm0+IHpvb21CbHVyVW5pZm9ybXMgOiBab29tQmx1clVuaWZvcm1zO1xcblxcbkBmcmFnbWVudFxcbmZuIG1haW5GcmFnbWVudChcXG4gICAgQGJ1aWx0aW4ocG9zaXRpb24pIHBvc2l0aW9uOiB2ZWM0PGYzMj4sXFxuICAgIEBsb2NhdGlvbigwKSB1diA6IHZlYzI8ZjMyPlxcbikgLT4gQGxvY2F0aW9uKDApIHZlYzQ8ZjMyPiB7XFxuICBsZXQgdVN0cmVuZ3RoID0gem9vbUJsdXJVbmlmb3Jtcy51U3RyZW5ndGg7XFxuICBsZXQgdUNlbnRlciA9IHpvb21CbHVyVW5pZm9ybXMudUNlbnRlcjtcXG4gIGxldCB1UmFkaWkgPSB6b29tQmx1clVuaWZvcm1zLnVSYWRpaTtcXG5cXG4gIGxldCBtaW5HcmFkaWVudDogZjMyID0gdVJhZGlpWzBdICogMC4zO1xcbiAgbGV0IGlubmVyUmFkaXVzOiBmMzIgPSAodVJhZGlpWzBdICsgbWluR3JhZGllbnQgKiAwLjUpIC8gZ2Z1LnVJbnB1dFNpemUueDtcXG5cXG4gIGxldCBncmFkaWVudDogZjMyID0gdVJhZGlpWzFdICogMC4zO1xcbiAgbGV0IHJhZGl1czogZjMyID0gKHVSYWRpaVsxXSAtIGdyYWRpZW50ICogMC41KSAvIGdmdS51SW5wdXRTaXplLng7XFxuXFxuICBsZXQgTUFYX0tFUk5FTF9TSVpFOiBmMzIgPSAke01BWF9LRVJORUxfU0laRX07XFxuXFxuICB2YXIgY291bnRMaW1pdDogZjMyID0gTUFYX0tFUk5FTF9TSVpFO1xcblxcbiAgdmFyIGRpcjogdmVjMjxmMzI+ID0gdmVjMjxmMzI+KHVDZW50ZXIgLyBnZnUudUlucHV0U2l6ZS54eSAtIHV2KTtcXG4gIGxldCBkaXN0OiBmMzIgPSBsZW5ndGgodmVjMjxmMzI+KGRpci54LCBkaXIueSAqIGdmdS51SW5wdXRTaXplLnkgLyBnZnUudUlucHV0U2l6ZS54KSk7XFxuXFxuICB2YXIgc3RyZW5ndGg6IGYzMiA9IHVTdHJlbmd0aDtcXG5cXG4gIHZhciBkZWx0YTogZjMyID0gMC4wO1xcbiAgdmFyIGdhcDogZjMyO1xcblxcbiAgaWYgKGRpc3QgPCBpbm5lclJhZGl1cykge1xcbiAgICAgIGRlbHRhID0gaW5uZXJSYWRpdXMgLSBkaXN0O1xcbiAgICAgIGdhcCA9IG1pbkdyYWRpZW50O1xcbiAgfSBlbHNlIGlmIChyYWRpdXMgPj0gMC4wICYmIGRpc3QgPiByYWRpdXMpIHsgLy8gcmFkaXVzIDwgMCBtZWFucyBpdCdzIGluZmluaXR5XFxuICAgICAgZGVsdGEgPSBkaXN0IC0gcmFkaXVzO1xcbiAgICAgIGdhcCA9IGdyYWRpZW50O1xcbiAgfVxcblxcbiAgdmFyIHJldHVybkNvbG9yT25seTogYm9vbCA9IGZhbHNlO1xcblxcbiAgaWYgKGRlbHRhID4gMC4wKSB7XFxuICAgIGxldCBub3JtYWxDb3VudDogZjMyID0gZ2FwIC8gZ2Z1LnVJbnB1dFNpemUueDtcXG4gICAgZGVsdGEgPSAobm9ybWFsQ291bnQgLSBkZWx0YSkgLyBub3JtYWxDb3VudDtcXG4gICAgY291bnRMaW1pdCAqPSBkZWx0YTtcXG4gICAgc3RyZW5ndGggKj0gZGVsdGE7XFxuICAgIFxcbiAgICBpZiAoY291bnRMaW1pdCA8IDEuMClcXG4gICAge1xcbiAgICAgIHJldHVybkNvbG9yT25seSA9IHRydWU7O1xcbiAgICB9XFxuICB9XFxuXFxuICAvLyByYW5kb21pemUgdGhlIGxvb2t1cCB2YWx1ZXMgdG8gaGlkZSB0aGUgZml4ZWQgbnVtYmVyIG9mIHNhbXBsZXNcXG4gIGxldCBvZmZzZXQ6IGYzMiA9IHJhbmQodXYsIDAuMCk7XFxuXFxuICB2YXIgdG90YWw6IGYzMiA9IDAuMDtcXG4gIHZhciBjb2xvcjogdmVjNDxmMzI+ID0gdmVjNDxmMzI+KDAuKTtcXG5cXG4gIGRpciAqPSBzdHJlbmd0aDtcXG5cXG4gIGZvciAodmFyIHQgPSAwLjA7IHQgPCBNQVhfS0VSTkVMX1NJWkU7IHQgKz0gMS4wKSB7XFxuICAgIGxldCBwZXJjZW50OiBmMzIgPSAodCArIG9mZnNldCkgLyBNQVhfS0VSTkVMX1NJWkU7XFxuICAgIGxldCB3ZWlnaHQ6IGYzMiA9IDQuMCAqIChwZXJjZW50IC0gcGVyY2VudCAqIHBlcmNlbnQpO1xcbiAgICBsZXQgcDogdmVjMjxmMzI+ID0gdXYgKyBkaXIgKiBwZXJjZW50O1xcbiAgICBsZXQgc2FtcGxlOiB2ZWM0PGYzMj4gPSB0ZXh0dXJlU2FtcGxlKHVUZXh0dXJlLCB1U2FtcGxlciwgcCk7XFxuICAgIFxcbiAgICBpZiAodCA8IGNvdW50TGltaXQpXFxuICAgIHtcXG4gICAgICBjb2xvciArPSBzYW1wbGUgKiB3ZWlnaHQ7XFxuICAgICAgdG90YWwgKz0gd2VpZ2h0O1xcbiAgICB9XFxuICB9XFxuXFxuICBjb2xvciAvPSB0b3RhbDtcXG5cXG4gIHJldHVybiBzZWxlY3QoY29sb3IsIHRleHR1cmVTYW1wbGUodVRleHR1cmUsIHVTYW1wbGVyLCB1diksIHJldHVybkNvbG9yT25seSk7XFxufVxcblxcbmZuIG1vZHVsbyh4OiBmMzIsIHk6IGYzMikgLT4gZjMyXFxue1xcbiAgcmV0dXJuIHggLSB5ICogZmxvb3IoeC95KTtcXG59XFxuXFxuLy8gYXV0aG9yOiBodHRwOi8vYnl0ZWJsYWNrc21pdGguY29tL2ltcHJvdmVtZW50cy10by10aGUtY2Fub25pY2FsLW9uZS1saW5lci1nbHNsLXJhbmQtZm9yLW9wZW5nbC1lcy0yLTAvXFxuZm4gcmFuZChjbzogdmVjMjxmMzI+LCBzZWVkOiBmMzIpIC0+IGYzMlxcbntcXG4gIGxldCBhOiBmMzIgPSAxMi45ODk4O1xcbiAgbGV0IGI6IGYzMiA9IDc4LjIzMztcXG4gIGxldCBjOiBmMzIgPSA0Mzc1OC41NDUzO1xcbiAgbGV0IGR0OiBmMzIgPSBkb3QoY28gKyBzZWVkLCB2ZWMyPGYzMj4oYSwgYikpO1xcbiAgbGV0IHNuOiBmMzIgPSBtb2R1bG8oZHQsIDMuMTQxNTkpO1xcbiAgcmV0dXJuIGZyYWN0KHNpbihzbikgKiBjICsgc2VlZCk7XFxufVwiO1xuXG5leHBvcnQgeyBzb3VyY2UgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9em9vbS1ibHVyMi5tanMubWFwXG4iLCJpbXBvcnQgeyBGaWx0ZXIsIGRlcHJlY2F0aW9uLCBHcHVQcm9ncmFtLCBHbFByb2dyYW0sIFRleHR1cmVQb29sIH0gZnJvbSAncGl4aS5qcyc7XG5pbXBvcnQgdmVydGV4IGZyb20gJy4uL2RlZmF1bHRzL2RlZmF1bHQyLm1qcyc7XG5pbXBvcnQgd2dzbFZlcnRleCBmcm9tICcuLi9kZWZhdWx0cy9kZWZhdWx0Lm1qcyc7XG5pbXBvcnQgZnJhZ21lbnQgZnJvbSAnLi9rYXdhc2UtYmx1ci5tanMnO1xuaW1wb3J0IHNvdXJjZSBmcm9tICcuL2thd2FzZS1ibHVyMi5tanMnO1xuaW1wb3J0IGZyYWdtZW50Q2xhbXAgZnJvbSAnLi9rYXdhc2UtYmx1ci1jbGFtcC5tanMnO1xuaW1wb3J0IHNvdXJjZUNsYW1wIGZyb20gJy4va2F3YXNlLWJsdXItY2xhbXAyLm1qcyc7XG5cbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbmNvbnN0IF9LYXdhc2VCbHVyRmlsdGVyID0gY2xhc3MgX0thd2FzZUJsdXJGaWx0ZXIgZXh0ZW5kcyBGaWx0ZXIge1xuICAvKiogQGlnbm9yZSAqL1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmdzWzBdID8/IHt9O1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJudW1iZXJcIiB8fCBBcnJheS5pc0FycmF5KG9wdGlvbnMpKSB7XG4gICAgICBkZXByZWNhdGlvbihcIjYuMC4wXCIsIFwiS2F3YXNlQmx1ckZpbHRlciBjb25zdHJ1Y3RvciBwYXJhbXMgYXJlIG5vdyBvcHRpb25zIG9iamVjdC4gU2VlIHBhcmFtczogeyBzdHJlbmd0aCwgcXVhbGl0eSwgY2xhbXAsIHBpeGVsU2l6ZSB9XCIpO1xuICAgICAgb3B0aW9ucyA9IHsgc3RyZW5ndGg6IG9wdGlvbnMgfTtcbiAgICAgIGlmIChhcmdzWzFdICE9PSB2b2lkIDApXG4gICAgICAgIG9wdGlvbnMucXVhbGl0eSA9IGFyZ3NbMV07XG4gICAgICBpZiAoYXJnc1syXSAhPT0gdm9pZCAwKVxuICAgICAgICBvcHRpb25zLmNsYW1wID0gYXJnc1syXTtcbiAgICB9XG4gICAgb3B0aW9ucyA9IHsgLi4uX0thd2FzZUJsdXJGaWx0ZXIuREVGQVVMVF9PUFRJT05TLCAuLi5vcHRpb25zIH07XG4gICAgY29uc3QgZ3B1UHJvZ3JhbSA9IEdwdVByb2dyYW0uZnJvbSh7XG4gICAgICB2ZXJ0ZXg6IHtcbiAgICAgICAgc291cmNlOiB3Z3NsVmVydGV4LFxuICAgICAgICBlbnRyeVBvaW50OiBcIm1haW5WZXJ0ZXhcIlxuICAgICAgfSxcbiAgICAgIGZyYWdtZW50OiB7XG4gICAgICAgIHNvdXJjZTogb3B0aW9ucz8uY2xhbXAgPyBzb3VyY2VDbGFtcCA6IHNvdXJjZSxcbiAgICAgICAgZW50cnlQb2ludDogXCJtYWluRnJhZ21lbnRcIlxuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGdsUHJvZ3JhbSA9IEdsUHJvZ3JhbS5mcm9tKHtcbiAgICAgIHZlcnRleCxcbiAgICAgIGZyYWdtZW50OiBvcHRpb25zPy5jbGFtcCA/IGZyYWdtZW50Q2xhbXAgOiBmcmFnbWVudCxcbiAgICAgIG5hbWU6IFwia2F3YXNlLWJsdXItZmlsdGVyXCJcbiAgICB9KTtcbiAgICBzdXBlcih7XG4gICAgICBncHVQcm9ncmFtLFxuICAgICAgZ2xQcm9ncmFtLFxuICAgICAgcmVzb3VyY2VzOiB7XG4gICAgICAgIGthd2FzZUJsdXJVbmlmb3Jtczoge1xuICAgICAgICAgIHVPZmZzZXQ6IHsgdmFsdWU6IG5ldyBGbG9hdDMyQXJyYXkoMiksIHR5cGU6IFwidmVjMjxmMzI+XCIgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInVuaWZvcm1zXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfcGl4ZWxTaXplXCIsIHsgeDogMCwgeTogMCB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX2NsYW1wXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfa2VybmVsc1wiLCBbXSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9ibHVyXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfcXVhbGl0eVwiKTtcbiAgICB0aGlzLnVuaWZvcm1zID0gdGhpcy5yZXNvdXJjZXMua2F3YXNlQmx1clVuaWZvcm1zLnVuaWZvcm1zO1xuICAgIHRoaXMucGl4ZWxTaXplID0gb3B0aW9ucy5waXhlbFNpemUgPz8geyB4OiAxLCB5OiAxIH07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy5zdHJlbmd0aCkpIHtcbiAgICAgIHRoaXMua2VybmVscyA9IG9wdGlvbnMuc3RyZW5ndGg7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5zdHJlbmd0aCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgdGhpcy5fYmx1ciA9IG9wdGlvbnMuc3RyZW5ndGg7XG4gICAgICB0aGlzLnF1YWxpdHkgPSBvcHRpb25zLnF1YWxpdHkgPz8gMztcbiAgICB9XG4gICAgdGhpcy5fY2xhbXAgPSAhIW9wdGlvbnMuY2xhbXA7XG4gIH1cbiAgLyoqXG4gICAqIE92ZXJyaWRlIGV4aXN0aW5nIGFwcGx5IG1ldGhvZCBpbiBgRmlsdGVyYFxuICAgKiBAb3ZlcnJpZGVcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgYXBwbHkoZmlsdGVyTWFuYWdlciwgaW5wdXQsIG91dHB1dCwgY2xlYXJNb2RlKSB7XG4gICAgY29uc3QgdXZYID0gdGhpcy5waXhlbFNpemVYIC8gaW5wdXQuc291cmNlLndpZHRoO1xuICAgIGNvbnN0IHV2WSA9IHRoaXMucGl4ZWxTaXplWSAvIGlucHV0LnNvdXJjZS5oZWlnaHQ7XG4gICAgbGV0IG9mZnNldDtcbiAgICBpZiAodGhpcy5fcXVhbGl0eSA9PT0gMSB8fCB0aGlzLl9ibHVyID09PSAwKSB7XG4gICAgICBvZmZzZXQgPSB0aGlzLl9rZXJuZWxzWzBdICsgMC41O1xuICAgICAgdGhpcy51bmlmb3Jtcy51T2Zmc2V0WzBdID0gb2Zmc2V0ICogdXZYO1xuICAgICAgdGhpcy51bmlmb3Jtcy51T2Zmc2V0WzFdID0gb2Zmc2V0ICogdXZZO1xuICAgICAgZmlsdGVyTWFuYWdlci5hcHBseUZpbHRlcih0aGlzLCBpbnB1dCwgb3V0cHV0LCBjbGVhck1vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCByZW5kZXJUYXJnZXQgPSBUZXh0dXJlUG9vbC5nZXRTYW1lU2l6ZVRleHR1cmUoaW5wdXQpO1xuICAgICAgbGV0IHNvdXJjZTIgPSBpbnB1dDtcbiAgICAgIGxldCB0YXJnZXQgPSByZW5kZXJUYXJnZXQ7XG4gICAgICBsZXQgdG1wO1xuICAgICAgY29uc3QgbGFzdCA9IHRoaXMuX3F1YWxpdHkgLSAxO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsYXN0OyBpKyspIHtcbiAgICAgICAgb2Zmc2V0ID0gdGhpcy5fa2VybmVsc1tpXSArIDAuNTtcbiAgICAgICAgdGhpcy51bmlmb3Jtcy51T2Zmc2V0WzBdID0gb2Zmc2V0ICogdXZYO1xuICAgICAgICB0aGlzLnVuaWZvcm1zLnVPZmZzZXRbMV0gPSBvZmZzZXQgKiB1dlk7XG4gICAgICAgIGZpbHRlck1hbmFnZXIuYXBwbHlGaWx0ZXIodGhpcywgc291cmNlMiwgdGFyZ2V0LCB0cnVlKTtcbiAgICAgICAgdG1wID0gc291cmNlMjtcbiAgICAgICAgc291cmNlMiA9IHRhcmdldDtcbiAgICAgICAgdGFyZ2V0ID0gdG1wO1xuICAgICAgfVxuICAgICAgb2Zmc2V0ID0gdGhpcy5fa2VybmVsc1tsYXN0XSArIDAuNTtcbiAgICAgIHRoaXMudW5pZm9ybXMudU9mZnNldFswXSA9IG9mZnNldCAqIHV2WDtcbiAgICAgIHRoaXMudW5pZm9ybXMudU9mZnNldFsxXSA9IG9mZnNldCAqIHV2WTtcbiAgICAgIGZpbHRlck1hbmFnZXIuYXBwbHlGaWx0ZXIodGhpcywgc291cmNlMiwgb3V0cHV0LCBjbGVhck1vZGUpO1xuICAgICAgVGV4dHVyZVBvb2wucmV0dXJuVGV4dHVyZShyZW5kZXJUYXJnZXQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICAqIFRoZSBhbW91bnQgb2YgYmx1ciwgdmFsdWUgZ3JlYXRlciB0aGFuIGAwYC5cbiAgICAqIEBkZWZhdWx0IDRcbiAgICAqL1xuICBnZXQgc3RyZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JsdXI7XG4gIH1cbiAgc2V0IHN0cmVuZ3RoKHZhbHVlKSB7XG4gICAgdGhpcy5fYmx1ciA9IHZhbHVlO1xuICAgIHRoaXMuX2dlbmVyYXRlS2VybmVscygpO1xuICB9XG4gIC8qKlxuICAgICogVGhlIHF1YWxpdHkgb2YgdGhlIGZpbHRlciwgaW50ZWdlciBncmVhdGVyIHRoYW4gYDFgLlxuICAgICogQGRlZmF1bHQgM1xuICAgICovXG4gIGdldCBxdWFsaXR5KCkge1xuICAgIHJldHVybiB0aGlzLl9xdWFsaXR5O1xuICB9XG4gIHNldCBxdWFsaXR5KHZhbHVlKSB7XG4gICAgdGhpcy5fcXVhbGl0eSA9IE1hdGgubWF4KDEsIE1hdGgucm91bmQodmFsdWUpKTtcbiAgICB0aGlzLl9nZW5lcmF0ZUtlcm5lbHMoKTtcbiAgfVxuICAvKipcbiAgICAqIFRoZSBrZXJuZWwgc2l6ZSBvZiB0aGUgYmx1ciBmaWx0ZXIsIGZvciBhZHZhbmNlZCB1c2FnZVxuICAgICogQGRlZmF1bHQgWzBdXG4gICAgKi9cbiAgZ2V0IGtlcm5lbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2tlcm5lbHM7XG4gIH1cbiAgc2V0IGtlcm5lbHModmFsdWUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5fa2VybmVscyA9IHZhbHVlO1xuICAgICAgdGhpcy5fcXVhbGl0eSA9IHZhbHVlLmxlbmd0aDtcbiAgICAgIHRoaXMuX2JsdXIgPSBNYXRoLm1heCguLi52YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2tlcm5lbHMgPSBbMF07XG4gICAgICB0aGlzLl9xdWFsaXR5ID0gMTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAgKiBUaGUgc2l6ZSBvZiB0aGUgcGl4ZWxzLiBMYXJnZSBzaXplIGlzIGJsdXJyaWVyLiBGb3IgYWR2YW5jZWQgdXNhZ2UuXG4gICAgKiBAZGVmYXVsdCB7eDoxLHk6MX1cbiAgICAqL1xuICBnZXQgcGl4ZWxTaXplKCkge1xuICAgIHJldHVybiB0aGlzLl9waXhlbFNpemU7XG4gIH1cbiAgc2V0IHBpeGVsU2l6ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRoaXMucGl4ZWxTaXplWCA9IHRoaXMucGl4ZWxTaXplWSA9IHZhbHVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHRoaXMucGl4ZWxTaXplWCA9IHZhbHVlWzBdO1xuICAgICAgdGhpcy5waXhlbFNpemVZID0gdmFsdWVbMV07XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3BpeGVsU2l6ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgICogVGhlIHNpemUgb2YgdGhlIHBpeGVscyBvbiB0aGUgYHhgIGF4aXMuIExhcmdlIHNpemUgaXMgYmx1cnJpZXIuIEZvciBhZHZhbmNlZCB1c2FnZS5cbiAgICAqIEBkZWZhdWx0IDFcbiAgICAqL1xuICBnZXQgcGl4ZWxTaXplWCgpIHtcbiAgICByZXR1cm4gdGhpcy5waXhlbFNpemUueDtcbiAgfVxuICBzZXQgcGl4ZWxTaXplWCh2YWx1ZSkge1xuICAgIHRoaXMucGl4ZWxTaXplLnggPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICAqIFRoZSBzaXplIG9mIHRoZSBwaXhlbHMgb24gdGhlIGB5YCBheGlzLiBMYXJnZSBzaXplIGlzIGJsdXJyaWVyLiBGb3IgYWR2YW5jZWQgdXNhZ2UuXG4gICAgKiBAZGVmYXVsdCAxXG4gICAgKi9cbiAgZ2V0IHBpeGVsU2l6ZVkoKSB7XG4gICAgcmV0dXJuIHRoaXMucGl4ZWxTaXplLnk7XG4gIH1cbiAgc2V0IHBpeGVsU2l6ZVkodmFsdWUpIHtcbiAgICB0aGlzLnBpeGVsU2l6ZS55ID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAgKiBHZXQgdGhlIGlmIHRoZSBmaWx0ZXIgaXMgY2xhbXBlZFxuICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAqL1xuICBnZXQgY2xhbXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NsYW1wO1xuICB9XG4gIC8qKiBVcGRhdGUgcGFkZGluZyBiYXNlZCBvbiBrZXJuZWwgZGF0YSAqL1xuICBfdXBkYXRlUGFkZGluZygpIHtcbiAgICB0aGlzLnBhZGRpbmcgPSBNYXRoLmNlaWwodGhpcy5fa2VybmVscy5yZWR1Y2UoKGFjYywgdikgPT4gYWNjICsgdiArIDAuNSwgMCkpO1xuICB9XG4gIC8qKiBBdXRvIGdlbmVyYXRlIGtlcm5lbHMgYnkgYmx1ciAmIHF1YWxpdHkgKi9cbiAgX2dlbmVyYXRlS2VybmVscygpIHtcbiAgICBjb25zdCBibHVyID0gdGhpcy5fYmx1cjtcbiAgICBjb25zdCBxdWFsaXR5ID0gdGhpcy5fcXVhbGl0eTtcbiAgICBjb25zdCBrZXJuZWxzID0gW2JsdXJdO1xuICAgIGlmIChibHVyID4gMCkge1xuICAgICAgbGV0IGsgPSBibHVyO1xuICAgICAgY29uc3Qgc3RlcCA9IGJsdXIgLyBxdWFsaXR5O1xuICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBxdWFsaXR5OyBpKyspIHtcbiAgICAgICAgayAtPSBzdGVwO1xuICAgICAgICBrZXJuZWxzLnB1c2goayk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2tlcm5lbHMgPSBrZXJuZWxzO1xuICAgIHRoaXMuX3VwZGF0ZVBhZGRpbmcoKTtcbiAgfVxufTtcbi8qKiBEZWZhdWx0IHZhbHVlcyBmb3Igb3B0aW9ucy4gKi9cbl9fcHVibGljRmllbGQoX0thd2FzZUJsdXJGaWx0ZXIsIFwiREVGQVVMVF9PUFRJT05TXCIsIHtcbiAgc3RyZW5ndGg6IDQsXG4gIHF1YWxpdHk6IDMsXG4gIGNsYW1wOiBmYWxzZSxcbiAgcGl4ZWxTaXplOiB7IHg6IDEsIHk6IDEgfVxufSk7XG5sZXQgS2F3YXNlQmx1ckZpbHRlciA9IF9LYXdhc2VCbHVyRmlsdGVyO1xuXG5leHBvcnQgeyBLYXdhc2VCbHVyRmlsdGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1LYXdhc2VCbHVyRmlsdGVyLm1qcy5tYXBcbiIsInZhciBzb3VyY2VDbGFtcCA9IFwic3RydWN0IEthd2FzZUJsdXJVbmlmb3JtcyB7XFxuICB1T2Zmc2V0OnZlYzI8ZjMyPixcXG59O1xcblxcbnN0cnVjdCBHbG9iYWxGaWx0ZXJVbmlmb3JtcyB7XFxuICB1SW5wdXRTaXplOnZlYzQ8ZjMyPixcXG4gIHVJbnB1dFBpeGVsOnZlYzQ8ZjMyPixcXG4gIHVJbnB1dENsYW1wOnZlYzQ8ZjMyPixcXG4gIHVPdXRwdXRGcmFtZTp2ZWM0PGYzMj4sXFxuICB1R2xvYmFsRnJhbWU6dmVjNDxmMzI+LFxcbiAgdU91dHB1dFRleHR1cmU6dmVjNDxmMzI+LFxcbn07XFxuXFxuQGdyb3VwKDApIEBiaW5kaW5nKDApIHZhcjx1bmlmb3JtPiBnZnU6IEdsb2JhbEZpbHRlclVuaWZvcm1zO1xcblxcbkBncm91cCgwKSBAYmluZGluZygxKSB2YXIgdVRleHR1cmU6IHRleHR1cmVfMmQ8ZjMyPjsgXFxuQGdyb3VwKDApIEBiaW5kaW5nKDIpIHZhciB1U2FtcGxlcjogc2FtcGxlcjtcXG5AZ3JvdXAoMSkgQGJpbmRpbmcoMCkgdmFyPHVuaWZvcm0+IGthd2FzZUJsdXJVbmlmb3JtcyA6IEthd2FzZUJsdXJVbmlmb3JtcztcXG5cXG5AZnJhZ21lbnRcXG5mbiBtYWluRnJhZ21lbnQoXFxuICBAYnVpbHRpbihwb3NpdGlvbikgcG9zaXRpb246IHZlYzQ8ZjMyPixcXG4gIEBsb2NhdGlvbigwKSB1diA6IHZlYzI8ZjMyPlxcbikgLT4gQGxvY2F0aW9uKDApIHZlYzQ8ZjMyPiB7XFxuICBsZXQgdU9mZnNldCA9IGthd2FzZUJsdXJVbmlmb3Jtcy51T2Zmc2V0O1xcbiAgdmFyIGNvbG9yOiB2ZWM0PGYzMj4gPSB2ZWM0KDAuMCk7XFxuXFxuICAvLyBTYW1wbGUgdG9wIGxlZnQgcGl4ZWxcXG4gIGNvbG9yICs9IHRleHR1cmVTYW1wbGUodVRleHR1cmUsIHVTYW1wbGVyLCBjbGFtcCh2ZWMyPGYzMj4odXYueCAtIHVPZmZzZXQueCwgdXYueSArIHVPZmZzZXQueSksIGdmdS51SW5wdXRDbGFtcC54eSwgZ2Z1LnVJbnB1dENsYW1wLnp3KSk7XFxuICAvLyBTYW1wbGUgdG9wIHJpZ2h0IHBpeGVsXFxuICBjb2xvciArPSB0ZXh0dXJlU2FtcGxlKHVUZXh0dXJlLCB1U2FtcGxlciwgY2xhbXAodmVjMjxmMzI+KHV2LnggKyB1T2Zmc2V0LngsIHV2LnkgKyB1T2Zmc2V0LnkpLCBnZnUudUlucHV0Q2xhbXAueHksIGdmdS51SW5wdXRDbGFtcC56dykpO1xcbiAgLy8gU2FtcGxlIGJvdHRvbSByaWdodCBwaXhlbFxcbiAgY29sb3IgKz0gdGV4dHVyZVNhbXBsZSh1VGV4dHVyZSwgdVNhbXBsZXIsIGNsYW1wKHZlYzI8ZjMyPih1di54ICsgdU9mZnNldC54LCB1di55IC0gdU9mZnNldC55KSwgZ2Z1LnVJbnB1dENsYW1wLnh5LCBnZnUudUlucHV0Q2xhbXAuencpKTtcXG4gIC8vIFNhbXBsZSBib3R0b20gbGVmdCBwaXhlbFxcbiAgY29sb3IgKz0gdGV4dHVyZVNhbXBsZSh1VGV4dHVyZSwgdVNhbXBsZXIsIGNsYW1wKHZlYzI8ZjMyPih1di54IC0gdU9mZnNldC54LCB1di55IC0gdU9mZnNldC55KSwgZ2Z1LnVJbnB1dENsYW1wLnh5LCBnZnUudUlucHV0Q2xhbXAuencpKTtcXG4gIC8vIEF2ZXJhZ2VcXG4gIGNvbG9yICo9IDAuMjU7XFxuICAgIFxcbiAgcmV0dXJuIGNvbG9yO1xcbn1cIjtcblxuZXhwb3J0IHsgc291cmNlQ2xhbXAgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9a2F3YXNlLWJsdXItY2xhbXAyLm1qcy5tYXBcbiIsInZhciBzb3VyY2UgPSBcInN0cnVjdCBLYXdhc2VCbHVyVW5pZm9ybXMge1xcbiAgdU9mZnNldDp2ZWMyPGYzMj4sXFxufTtcXG5cXG5AZ3JvdXAoMCkgQGJpbmRpbmcoMSkgdmFyIHVUZXh0dXJlOiB0ZXh0dXJlXzJkPGYzMj47IFxcbkBncm91cCgwKSBAYmluZGluZygyKSB2YXIgdVNhbXBsZXI6IHNhbXBsZXI7XFxuQGdyb3VwKDEpIEBiaW5kaW5nKDApIHZhcjx1bmlmb3JtPiBrYXdhc2VCbHVyVW5pZm9ybXMgOiBLYXdhc2VCbHVyVW5pZm9ybXM7XFxuXFxuQGZyYWdtZW50XFxuZm4gbWFpbkZyYWdtZW50KFxcbiAgQGJ1aWx0aW4ocG9zaXRpb24pIHBvc2l0aW9uOiB2ZWM0PGYzMj4sXFxuICBAbG9jYXRpb24oMCkgdXYgOiB2ZWMyPGYzMj5cXG4pIC0+IEBsb2NhdGlvbigwKSB2ZWM0PGYzMj4ge1xcbiAgbGV0IHVPZmZzZXQgPSBrYXdhc2VCbHVyVW5pZm9ybXMudU9mZnNldDtcXG4gIHZhciBjb2xvcjogdmVjNDxmMzI+ID0gdmVjNDxmMzI+KDAuMCk7XFxuXFxuICAvLyBTYW1wbGUgdG9wIGxlZnQgcGl4ZWxcXG4gIGNvbG9yICs9IHRleHR1cmVTYW1wbGUodVRleHR1cmUsIHVTYW1wbGVyLCB2ZWMyPGYzMj4odXYueCAtIHVPZmZzZXQueCwgdXYueSArIHVPZmZzZXQueSkpO1xcbiAgLy8gU2FtcGxlIHRvcCByaWdodCBwaXhlbFxcbiAgY29sb3IgKz0gdGV4dHVyZVNhbXBsZSh1VGV4dHVyZSwgdVNhbXBsZXIsIHZlYzI8ZjMyPih1di54ICsgdU9mZnNldC54LCB1di55ICsgdU9mZnNldC55KSk7XFxuICAvLyBTYW1wbGUgYm90dG9tIHJpZ2h0IHBpeGVsXFxuICBjb2xvciArPSB0ZXh0dXJlU2FtcGxlKHVUZXh0dXJlLCB1U2FtcGxlciwgdmVjMjxmMzI+KHV2LnggKyB1T2Zmc2V0LngsIHV2LnkgLSB1T2Zmc2V0LnkpKTtcXG4gIC8vIFNhbXBsZSBib3R0b20gbGVmdCBwaXhlbFxcbiAgY29sb3IgKz0gdGV4dHVyZVNhbXBsZSh1VGV4dHVyZSwgdVNhbXBsZXIsIHZlYzI8ZjMyPih1di54IC0gdU9mZnNldC54LCB1di55IC0gdU9mZnNldC55KSk7XFxuICAvLyBBdmVyYWdlXFxuICBjb2xvciAqPSAwLjI1O1xcblxcbiAgcmV0dXJuIGNvbG9yO1xcbn1cIjtcblxuZXhwb3J0IHsgc291cmNlIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWthd2FzZS1ibHVyMi5tanMubWFwXG4iLCJ2YXIgZnJhZ21lbnRDbGFtcCA9IFwiXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbmluIHZlYzIgdlRleHR1cmVDb29yZDtcXG5vdXQgdmVjNCBmaW5hbENvbG9yO1xcblxcbnVuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbnVuaWZvcm0gdmVjMiB1T2Zmc2V0O1xcblxcbnVuaWZvcm0gdmVjNCB1SW5wdXRDbGFtcDtcXG5cXG52b2lkIG1haW4odm9pZClcXG57XFxuICAgIHZlYzQgY29sb3IgPSB2ZWM0KDAuMCk7XFxuXFxuICAgIC8vIFNhbXBsZSB0b3AgbGVmdCBwaXhlbFxcbiAgICBjb2xvciArPSB0ZXh0dXJlKHVUZXh0dXJlLCBjbGFtcCh2ZWMyKHZUZXh0dXJlQ29vcmQueCAtIHVPZmZzZXQueCwgdlRleHR1cmVDb29yZC55ICsgdU9mZnNldC55KSwgdUlucHV0Q2xhbXAueHksIHVJbnB1dENsYW1wLnp3KSk7XFxuXFxuICAgIC8vIFNhbXBsZSB0b3AgcmlnaHQgcGl4ZWxcXG4gICAgY29sb3IgKz0gdGV4dHVyZSh1VGV4dHVyZSwgY2xhbXAodmVjMih2VGV4dHVyZUNvb3JkLnggKyB1T2Zmc2V0LngsIHZUZXh0dXJlQ29vcmQueSArIHVPZmZzZXQueSksIHVJbnB1dENsYW1wLnh5LCB1SW5wdXRDbGFtcC56dykpO1xcblxcbiAgICAvLyBTYW1wbGUgYm90dG9tIHJpZ2h0IHBpeGVsXFxuICAgIGNvbG9yICs9IHRleHR1cmUodVRleHR1cmUsIGNsYW1wKHZlYzIodlRleHR1cmVDb29yZC54ICsgdU9mZnNldC54LCB2VGV4dHVyZUNvb3JkLnkgLSB1T2Zmc2V0LnkpLCB1SW5wdXRDbGFtcC54eSwgdUlucHV0Q2xhbXAuencpKTtcXG5cXG4gICAgLy8gU2FtcGxlIGJvdHRvbSBsZWZ0IHBpeGVsXFxuICAgIGNvbG9yICs9IHRleHR1cmUodVRleHR1cmUsIGNsYW1wKHZlYzIodlRleHR1cmVDb29yZC54IC0gdU9mZnNldC54LCB2VGV4dHVyZUNvb3JkLnkgLSB1T2Zmc2V0LnkpLCB1SW5wdXRDbGFtcC54eSwgdUlucHV0Q2xhbXAuencpKTtcXG5cXG4gICAgLy8gQXZlcmFnZVxcbiAgICBjb2xvciAqPSAwLjI1O1xcblxcbiAgICBmaW5hbENvbG9yID0gY29sb3I7XFxufVxcblwiO1xuXG5leHBvcnQgeyBmcmFnbWVudENsYW1wIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWthd2FzZS1ibHVyLWNsYW1wLm1qcy5tYXBcbiIsInZhciBmcmFnbWVudCA9IFwiXFxuaW4gdmVjMiB2VGV4dHVyZUNvb3JkO1xcbm91dCB2ZWM0IGZpbmFsQ29sb3I7XFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxudW5pZm9ybSB2ZWMyIHVPZmZzZXQ7XFxuXFxudm9pZCBtYWluKHZvaWQpXFxue1xcbiAgICB2ZWM0IGNvbG9yID0gdmVjNCgwLjApO1xcblxcbiAgICAvLyBTYW1wbGUgdG9wIGxlZnQgcGl4ZWxcXG4gICAgY29sb3IgKz0gdGV4dHVyZSh1VGV4dHVyZSwgdmVjMih2VGV4dHVyZUNvb3JkLnggLSB1T2Zmc2V0LngsIHZUZXh0dXJlQ29vcmQueSArIHVPZmZzZXQueSkpO1xcblxcbiAgICAvLyBTYW1wbGUgdG9wIHJpZ2h0IHBpeGVsXFxuICAgIGNvbG9yICs9IHRleHR1cmUodVRleHR1cmUsIHZlYzIodlRleHR1cmVDb29yZC54ICsgdU9mZnNldC54LCB2VGV4dHVyZUNvb3JkLnkgKyB1T2Zmc2V0LnkpKTtcXG5cXG4gICAgLy8gU2FtcGxlIGJvdHRvbSByaWdodCBwaXhlbFxcbiAgICBjb2xvciArPSB0ZXh0dXJlKHVUZXh0dXJlLCB2ZWMyKHZUZXh0dXJlQ29vcmQueCArIHVPZmZzZXQueCwgdlRleHR1cmVDb29yZC55IC0gdU9mZnNldC55KSk7XFxuXFxuICAgIC8vIFNhbXBsZSBib3R0b20gbGVmdCBwaXhlbFxcbiAgICBjb2xvciArPSB0ZXh0dXJlKHVUZXh0dXJlLCB2ZWMyKHZUZXh0dXJlQ29vcmQueCAtIHVPZmZzZXQueCwgdlRleHR1cmVDb29yZC55IC0gdU9mZnNldC55KSk7XFxuXFxuICAgIC8vIEF2ZXJhZ2VcXG4gICAgY29sb3IgKj0gMC4yNTtcXG5cXG4gICAgZmluYWxDb2xvciA9IGNvbG9yO1xcbn1cIjtcblxuZXhwb3J0IHsgZnJhZ21lbnQgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9a2F3YXNlLWJsdXIubWpzLm1hcFxuIl0sIm5hbWVzIjpbIl9fZGVmUHJvcCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiX19wdWJsaWNGaWVsZCIsIm9iaiIsImtleSIsInZhbHVlIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX19kZWZOb3JtYWxQcm9wIiwiX01vdGlvbkJsdXJGaWx0ZXIiLCJjb25zdHJ1Y3RvciIsImFyZ3MiLCJvcHRpb25zIiwiQXJyYXkiLCJpc0FycmF5IiwidmVsb2NpdHkiLCJ4IiwieSIsImtlcm5lbFNpemUiLCJvZmZzZXQiLCJERUZBVUxUX09QVElPTlMiLCJzdXBlciIsImdwdVByb2dyYW0iLCJmcm9tIiwidmVydGV4Iiwic291cmNlIiwiZW50cnlQb2ludCIsImZyYWdtZW50IiwiZ2xQcm9ncmFtIiwibmFtZSIsInJlc291cmNlcyIsIm1vdGlvbkJsdXJVbmlmb3JtcyIsInVWZWxvY2l0eSIsInR5cGUiLCJ1S2VybmVsU2l6ZSIsIk1hdGgiLCJ0cnVuYyIsInVPZmZzZXQiLCJ0aGlzIiwidW5pZm9ybXMiLCJhc3NpZ24iLCJfdXBkYXRlRGlydHkiLCJ2ZWxvY2l0eVgiLCJ2ZWxvY2l0eVkiLCJfa2VybmVsU2l6ZSIsInBhZGRpbmciLCJtYXgiLCJhYnMiLCJfTXVsdGlDb2xvclJlcGxhY2VGaWx0ZXIiLCJyZXBsYWNlbWVudHMiLCJ0b2xlcmFuY2UiLCJtYXhDb2xvcnMiLCJsZW5ndGgiLCJyZXBsYWNlIiwidG9GaXhlZCIsIm11bHRpQ29sb3JSZXBsYWNlVW5pZm9ybXMiLCJ1T3JpZ2luYWxDb2xvcnMiLCJGbG9hdDMyQXJyYXkiLCJzaXplIiwidVRhcmdldENvbG9ycyIsInVUb2xlcmFuY2UiLCJfbWF4Q29sb3JzIiwib3JpZ2luYWxzIiwidGFyZ2V0cyIsImNvbG9yQ291bnQiLCJjb2xvciIsIkVycm9yIiwiciIsImciLCJiIiwiaSIsInBhaXIiLCJzZXRWYWx1ZSIsInRvQXJyYXkiLCJfcmVwbGFjZW1lbnRzIiwicmVmcmVzaCIsImVwc2lsb24iLCJfT2xkRmlsbUZpbHRlciIsIm9sZEZpbG1Vbmlmb3JtcyIsInVTZXBpYSIsInNlcGlhIiwidU5vaXNlIiwidVNjcmF0Y2giLCJ1VmlnbmV0dGluZyIsInVTZWVkIiwic2VlZCIsInVEaW1lbnNpb25zIiwiYXBwbHkiLCJmaWx0ZXJNYW5hZ2VyIiwiaW5wdXQiLCJvdXRwdXQiLCJjbGVhck1vZGUiLCJmcmFtZSIsIndpZHRoIiwiaGVpZ2h0IiwiYXBwbHlGaWx0ZXIiLCJub2lzZSIsIm5vaXNlU2l6ZSIsInNjcmF0Y2giLCJzY3JhdGNoRGVuc2l0eSIsInNjcmF0Y2hXaWR0aCIsInZpZ25ldHRpbmciLCJ2aWduZXR0aW5nQWxwaGEiLCJ2aWduZXR0aW5nQmx1ciIsIl9PdXRsaW5lRmlsdGVyIiwidGhpY2tuZXNzIiwicXVhbGl0eSIsImFscGhhIiwia25vY2tvdXQiLCJnZXRBbmdsZVN0ZXAiLCJvdXRsaW5lVW5pZm9ybXMiLCJ1VGhpY2tuZXNzIiwidUNvbG9yIiwidUFscGhhIiwidUFuZ2xlU3RlcCIsInVLbm9ja291dCIsIl9jb2xvciIsInBhcnNlRmxvYXQiLCJQSSIsIk1BWF9TQU1QTEVTIiwiTUlOX1NBTVBMRVMiLCJfdGhpY2tuZXNzIiwiX3F1YWxpdHkiLCJfUmFkaWFsQmx1ckZpbHRlciIsImFuZ2xlIiwiY2VudGVyIiwicmFkaXVzIiwicmFkaWFsQmx1clVuaWZvcm1zIiwidVJhZGlhbiIsInVDZW50ZXIiLCJ1UmFkaXVzIiwiX3VwZGF0ZUtlcm5lbFNpemUiLCJfYW5nbGUiLCJjZW50ZXJYIiwiY2VudGVyWSIsIkluZmluaXR5IiwiX1JlZmxlY3Rpb25GaWx0ZXIiLCJyZWZsZWN0aW9uVW5pZm9ybXMiLCJ1TWlycm9yIiwibWlycm9yIiwidUJvdW5kYXJ5IiwiYm91bmRhcnkiLCJ1QW1wbGl0dWRlIiwiYW1wbGl0dWRlIiwidVdhdmVsZW5ndGgiLCJ3YXZlTGVuZ3RoIiwidVRpbWUiLCJ0aW1lIiwiYW1wbGl0dWRlU3RhcnQiLCJhbXBsaXR1ZGVFbmQiLCJ3YXZlbGVuZ3RoU3RhcnQiLCJ3YXZlbGVuZ3RoRW5kIiwiYWxwaGFTdGFydCIsImFscGhhRW5kIiwiX1JHQlNwbGl0RmlsdGVyIiwicmVkIiwiZ3JlZW4iLCJibHVlIiwicmdiU3BsaXRVbmlmb3JtcyIsInVSZWQiLCJ1R3JlZW4iLCJ1Qmx1ZSIsInJlZFgiLCJyZWRZIiwiZ3JlZW5YIiwiZ3JlZW5ZIiwiYmx1ZVgiLCJibHVlWSIsIl9TaG9ja3dhdmVGaWx0ZXIiLCJzaG9ja3dhdmVVbmlmb3JtcyIsInVTcGVlZCIsInNwZWVkIiwidVdhdmUiLCJ3YXZlbGVuZ3RoIiwiYnJpZ2h0bmVzcyIsIl9TaW1wbGVMaWdodG1hcEZpbHRlciIsImxpZ2h0TWFwIiwic2ltcGxlTGlnaHRtYXBVbmlmb3JtcyIsInVNYXBUZXh0dXJlIiwidU1hcFNhbXBsZXIiLCJzdHlsZSIsIl9saWdodE1hcCIsIldISVRFIiwiX1RpbHRTaGlmdEF4aXNGaWx0ZXIiLCJkZWZhdWx0T3B0aW9ucyIsInN0YXJ0IiwiZW5kIiwidGlsdFNoaWZ0VW5pZm9ybXMiLCJ1Qmx1ciIsImJsdXIiLCJncmFkaWVudEJsdXIiLCJ1U3RhcnQiLCJ1RW5kIiwidURlbHRhIiwiX3RpbHRBeGlzIiwiYXhpcyIsInVwZGF0ZURpbWVuc2lvbnMiLCJ1cGRhdGVEZWx0YSIsImR4IiwiZHkiLCJkIiwic3FydCIsImlzVmVydCIsIl9Ud2lzdEZpbHRlciIsInR3aXN0VW5pZm9ybXMiLCJ1VHdpc3QiLCJvZmZzZXRYIiwib2Zmc2V0WSIsIl9ab29tQmx1ckZpbHRlciIsIm1heEtlcm5lbFNpemUiLCJ6b29tQmx1clVuaWZvcm1zIiwidVN0cmVuZ3RoIiwic3RyZW5ndGgiLCJ1UmFkaWkiLCJpbm5lclJhZGl1cyIsIl9LYXdhc2VCbHVyRmlsdGVyIiwiY2xhbXAiLCJrYXdhc2VCbHVyVW5pZm9ybXMiLCJwaXhlbFNpemUiLCJrZXJuZWxzIiwiX2JsdXIiLCJfY2xhbXAiLCJ1dlgiLCJwaXhlbFNpemVYIiwidXZZIiwicGl4ZWxTaXplWSIsIl9rZXJuZWxzIiwicmVuZGVyVGFyZ2V0IiwiZ2V0U2FtZVNpemVUZXh0dXJlIiwidG1wIiwic291cmNlMiIsInRhcmdldCIsImxhc3QiLCJyZXR1cm5UZXh0dXJlIiwiX2dlbmVyYXRlS2VybmVscyIsInJvdW5kIiwiX3BpeGVsU2l6ZSIsIl91cGRhdGVQYWRkaW5nIiwiY2VpbCIsInJlZHVjZSIsImFjYyIsInYiLCJrIiwic3RlcCIsInB1c2giLCJLYXdhc2VCbHVyRmlsdGVyIl0sInNvdXJjZVJvb3QiOiIifQ==