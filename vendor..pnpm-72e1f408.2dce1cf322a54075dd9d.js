(self.webpackChunkpixijs_game=self.webpackChunkpixijs_game||[]).push([[640],{9738:(e,n,t)=>{"use strict";t.d(n,{A:()=>y});var r=/iPhone/i,o=/iPod/i,i=/iPad/i,u=/\biOS-universal(?:.+)Mac\b/i,s=/\bAndroid(?:.+)Mobile\b/i,l=/Android/i,a=/(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i,c=/Silk/i,f=/Windows Phone/i,m=/\bWindows(?:.+)ARM\b/i,p=/BlackBerry/i,g=/BB10/i,v=/Opera Mini/i,d=/\b(CriOS|Chrome)(?:.+)Mobile/i,h=/Mobile(?:.+)Firefox\b/i,x=function(e){return void 0!==e&&"MacIntel"===e.platform&&"number"==typeof e.maxTouchPoints&&e.maxTouchPoints>1&&"undefined"==typeof MSStream};function y(e){var n={userAgent:"",platform:"",maxTouchPoints:0};e||"undefined"==typeof navigator?"string"==typeof e?n.userAgent=e:e&&e.userAgent&&(n={userAgent:e.userAgent,platform:e.platform,maxTouchPoints:e.maxTouchPoints||0}):n={userAgent:navigator.userAgent,platform:navigator.platform,maxTouchPoints:navigator.maxTouchPoints||0};var t=n.userAgent,y=t.split("[FBAN");void 0!==y[1]&&(t=y[0]),void 0!==(y=t.split("Twitter"))[1]&&(t=y[0]);var S=function(e){return function(n){return n.test(e)}}(t),b={apple:{phone:S(r)&&!S(f),ipod:S(o),tablet:!S(r)&&(S(i)||x(n))&&!S(f),universal:S(u),device:(S(r)||S(o)||S(i)||S(u)||x(n))&&!S(f)},amazon:{phone:S(a),tablet:!S(a)&&S(c),device:S(a)||S(c)},android:{phone:!S(f)&&S(a)||!S(f)&&S(s),tablet:!S(f)&&!S(a)&&!S(s)&&(S(c)||S(l)),device:!S(f)&&(S(a)||S(c)||S(s)||S(l))||S(/\bokhttp\b/i)},windows:{phone:S(f),tablet:S(m),device:S(f)||S(m)},other:{blackberry:S(p),blackberry10:S(g),opera:S(v),firefox:S(h),chrome:S(d),device:S(p)||S(g)||S(v)||S(h)||S(d)},any:!1,phone:!1,tablet:!1};return b.any=b.apple.device||b.android.device||b.windows.device||b.other.device,b.phone=b.apple.phone||b.android.phone||b.windows.phone,b.tablet=b.apple.tablet||b.android.tablet||b.windows.tablet,b}},3736:e=>{e.exports=function(e){var o=[];return e.replace(t,(function(e,t,i){var u=t.toLowerCase();for(i=function(e){var n=e.match(r);return n?n.map(Number):[]}(i),"m"==u&&i.length>2&&(o.push([t].concat(i.splice(0,2))),u="l",t="m"==t?"l":"L");;){if(i.length==n[u])return i.unshift(t),o.push(i);if(i.length<n[u])throw new Error("malformed path data");o.push([t].concat(i.splice(0,n[u])))}})),o};var n={a:7,c:6,h:1,l:2,m:2,q:4,s:4,t:2,v:1,z:0},t=/([astvzqmhlc])([^astvzqmhlc]*)/gi;var r=/-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/gi},700:(e,n,t)=>{"use strict";var r=t(3423),o=t(4742),i=t(9096),u=Object.defineProperty,s=(e,n,t)=>(((e,n,t)=>{n in e?u(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t})(e,"symbol"!=typeof n?n+"":n,t),t);const l=class e extends r.dJT{constructor(n){n={...e.DEFAULT_OPTIONS,...n};super({gpuProgram:r.BrD.from({vertex:{source:i.A,entryPoint:"mainVertex"},fragment:{source:"struct AdjustmentUniforms {\n  uGamma: f32,\n  uContrast: f32,\n  uSaturation: f32,\n  uBrightness: f32,\n  uColor: vec4<f32>,\n};\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> adjustmentUniforms : AdjustmentUniforms;\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @builtin(position) position: vec4<f32>\n) -> @location(0) vec4<f32> {\n  var sample = textureSample(uTexture, uSampler, uv);\n  let color = adjustmentUniforms.uColor;\n\n  if (sample.a > 0.0) \n  {\n    sample = vec4<f32>(sample.rgb / sample.a, sample.a);\n    var rgb: vec3<f32> = pow(sample.rgb, vec3<f32>(1. / adjustmentUniforms.uGamma));\n    rgb = mix(vec3<f32>(.5), mix(vec3<f32>(dot(vec3<f32>(.2125, .7154, .0721), rgb)), rgb, adjustmentUniforms.uSaturation), adjustmentUniforms.uContrast);\n    rgb.r *= color.r;\n    rgb.g *= color.g;\n    rgb.b *= color.b;\n    sample = vec4<f32>(rgb.rgb * adjustmentUniforms.uBrightness, sample.a);\n    sample = vec4<f32>(sample.rgb * sample.a, sample.a);\n  }\n\n  return sample * color.a;\n}",entryPoint:"mainFragment"}}),glProgram:r.M2g.from({vertex:o.A,fragment:"in vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform float uGamma;\nuniform float uContrast;\nuniform float uSaturation;\nuniform float uBrightness;\nuniform vec4 uColor;\n\nvoid main()\n{\n    vec4 c = texture(uTexture, vTextureCoord);\n\n    if (c.a > 0.0) {\n        c.rgb /= c.a;\n\n        vec3 rgb = pow(c.rgb, vec3(1. / uGamma));\n        rgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb)), rgb, uSaturation), uContrast);\n        rgb.r *= uColor.r;\n        rgb.g *= uColor.g;\n        rgb.b *= uColor.b;\n        c.rgb = rgb * uBrightness;\n\n        c.rgb *= c.a;\n    }\n\n    finalColor = c * uColor.a;\n}\n",name:"adjustment-filter"}),resources:{adjustmentUniforms:{uGamma:{value:n.gamma,type:"f32"},uContrast:{value:n.contrast,type:"f32"},uSaturation:{value:n.saturation,type:"f32"},uBrightness:{value:n.brightness,type:"f32"},uColor:{value:[n.red,n.green,n.blue,n.alpha],type:"vec4<f32>"}}}}),s(this,"uniforms"),this.uniforms=this.resources.adjustmentUniforms.uniforms}get gamma(){return this.uniforms.uGamma}set gamma(e){this.uniforms.uGamma=e}get contrast(){return this.uniforms.uContrast}set contrast(e){this.uniforms.uContrast=e}get saturation(){return this.uniforms.uSaturation}set saturation(e){this.uniforms.uSaturation=e}get brightness(){return this.uniforms.uBrightness}set brightness(e){this.uniforms.uBrightness=e}get red(){return this.uniforms.uColor[0]}set red(e){this.uniforms.uColor[0]=e}get green(){return this.uniforms.uColor[1]}set green(e){this.uniforms.uColor[1]=e}get blue(){return this.uniforms.uColor[2]}set blue(e){this.uniforms.uColor[2]=e}get alpha(){return this.uniforms.uColor[3]}set alpha(e){this.uniforms.uColor[3]=e}};s(l,"DEFAULT_OPTIONS",{gamma:1,contrast:1,saturation:1,brightness:1,red:1,green:1,blue:1,alpha:1})},8593:(e,n,t)=>{"use strict";var r=t(3423),o=t(4742),i=t(9096),u=t(386),s=Object.defineProperty,l=(e,n,t)=>(((e,n,t)=>{n in e?s(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t})(e,"symbol"!=typeof n?n+"":n,t),t);const a=class e extends r.dJT{constructor(n){n={...e.DEFAULT_OPTIONS,...n};super({gpuProgram:r.BrD.from({vertex:{source:i.A,entryPoint:"mainVertex"},fragment:{source:"struct ExtractBrightnessUniforms {\n  uThreshold: f32,\n};\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> extractBrightnessUniforms : ExtractBrightnessUniforms;\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  let color: vec4<f32> = textureSample(uTexture, uSampler, uv);\n\n  // A simple & fast algorithm for getting brightness.\n  // It's inaccurate, but good enough for this feature.\n  let max: f32 = max(max(color.r, color.g), color.b);\n  let min: f32 = min(min(color.r, color.g), color.b);\n  let brightness: f32 = (max + min) * 0.5;\n\n  return select(vec4<f32>(0.), color, brightness > extractBrightnessUniforms.uThreshold);\n}\n",entryPoint:"mainFragment"}}),glProgram:r.M2g.from({vertex:o.A,fragment:"\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform float uThreshold;\n\nvoid main() {\n    vec4 color = texture(uTexture, vTextureCoord);\n\n    // A simple & fast algorithm for getting brightness.\n    // It's inaccuracy , but good enought for this feature.\n    float _max = max(max(color.r, color.g), color.b);\n    float _min = min(min(color.r, color.g), color.b);\n    float brightness = (_max + _min) * 0.5;\n\n    if(brightness > uThreshold) {\n        finalColor = color;\n    } else {\n        finalColor = vec4(0.0, 0.0, 0.0, 0.0);\n    }\n}\n",name:"extract-brightness-filter"}),resources:{extractBrightnessUniforms:{uThreshold:{value:n.threshold,type:"f32"}}}}),l(this,"uniforms"),this.uniforms=this.resources.extractBrightnessUniforms.uniforms}get threshold(){return this.uniforms.uThreshold}set threshold(e){this.uniforms.uThreshold=e}};l(a,"DEFAULT_OPTIONS",{threshold:.5});let c=a;var f=Object.defineProperty,m=(e,n,t)=>(((e,n,t)=>{n in e?f(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t})(e,"symbol"!=typeof n?n+"":n,t),t);const p=class e extends r.dJT{constructor(n){n={...e.DEFAULT_OPTIONS,...n};super({gpuProgram:r.BrD.from({vertex:{source:i.A,entryPoint:"mainVertex"},fragment:{source:"struct AdvancedBloomUniforms {\n  uBloomScale: f32,\n  uBrightness: f32,\n};\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> advancedBloomUniforms : AdvancedBloomUniforms;\n@group(1) @binding(1) var uMapTexture: texture_2d<f32>;\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  var color = textureSample(uTexture, uSampler, uv);\n  color = vec4<f32>(color.rgb * advancedBloomUniforms.uBrightness, color.a);\n\n  var bloomColor = vec4<f32>(textureSample(uMapTexture, uSampler, uv).rgb, 0.0);\n  bloomColor = vec4<f32>(bloomColor.rgb * advancedBloomUniforms.uBloomScale, bloomColor.a);\n  \n  return color + bloomColor;\n}\n",entryPoint:"mainFragment"}}),glProgram:r.M2g.from({vertex:o.A,fragment:"in vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform sampler2D uMapTexture;\nuniform float uBloomScale;\nuniform float uBrightness;\n\nvoid main() {\n    vec4 color = texture(uTexture, vTextureCoord);\n    color.rgb *= uBrightness;\n    vec4 bloomColor = vec4(texture(uMapTexture, vTextureCoord).rgb, 0.0);\n    bloomColor.rgb *= uBloomScale;\n    finalColor = color + bloomColor;\n}\n",name:"advanced-bloom-filter"}),resources:{advancedBloomUniforms:{uBloomScale:{value:n.bloomScale,type:"f32"},uBrightness:{value:n.brightness,type:"f32"}},uMapTexture:r.gPd.WHITE}}),m(this,"uniforms"),m(this,"bloomScale",1),m(this,"brightness",1),m(this,"_extractFilter"),m(this,"_blurFilter"),this.uniforms=this.resources.advancedBloomUniforms.uniforms,this._extractFilter=new c({threshold:n.threshold}),this._blurFilter=new u.Q({strength:n.kernels??n.blur,quality:n.kernels?void 0:n.quality}),Object.assign(this,n)}apply(e,n,t,o){const i=r.Wny.getSameSizeTexture(n);this._extractFilter.apply(e,n,i,!0);const u=r.Wny.getSameSizeTexture(n);this._blurFilter.apply(e,i,u,!0),this.uniforms.uBloomScale=this.bloomScale,this.uniforms.uBrightness=this.brightness,this.resources.uMapTexture=u.source,e.applyFilter(this,n,t,o),r.Wny.returnTexture(u),r.Wny.returnTexture(i)}get threshold(){return this._extractFilter.threshold}set threshold(e){this._extractFilter.threshold=e}get kernels(){return this._blurFilter.kernels}set kernels(e){this._blurFilter.kernels=e}get blur(){return this._blurFilter.strength}set blur(e){this._blurFilter.strength=e}get quality(){return this._blurFilter.quality}set quality(e){this._blurFilter.quality=e}get pixelSize(){return this._blurFilter.pixelSize}set pixelSize(e){"number"==typeof e&&(e={x:e,y:e}),Array.isArray(e)&&(e={x:e[0],y:e[1]}),this._blurFilter.pixelSize=e}get pixelSizeX(){return this._blurFilter.pixelSizeX}set pixelSizeX(e){this._blurFilter.pixelSizeX=e}get pixelSizeY(){return this._blurFilter.pixelSizeY}set pixelSizeY(e){this._blurFilter.pixelSizeY=e}};m(p,"DEFAULT_OPTIONS",{threshold:.5,bloomScale:1,brightness:1,blur:8,quality:4,pixelSize:{x:1,y:1}})},5369:(e,n,t)=>{"use strict";var r=t(3423),o=t(4742),i=t(9096),u=Object.defineProperty,s=(e,n,t)=>(((e,n,t)=>{n in e?u(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t})(e,"symbol"!=typeof n?n+"":n,t),t);const l=class e extends r.dJT{constructor(...n){let t=n[0]??{};"number"==typeof t&&((0,r.t66)("6.0.0","AsciiFilter constructor params are now options object. See params: { size, color, replaceColor }"),t={size:t});const u=t?.color&&!1!==t.replaceColor;t={...e.DEFAULT_OPTIONS,...t};super({gpuProgram:r.BrD.from({vertex:{source:i.A,entryPoint:"mainVertex"},fragment:{source:"struct AsciiUniforms {\n    uSize: f32,\n    uColor: vec3<f32>,\n    uReplaceColor: f32,\n};\n\nstruct GlobalFilterUniforms {\n    uInputSize:vec4<f32>,\n    uInputPixel:vec4<f32>,\n    uInputClamp:vec4<f32>,\n    uOutputFrame:vec4<f32>,\n    uGlobalFrame:vec4<f32>,\n    uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> asciiUniforms : AsciiUniforms;\n\n@fragment\nfn mainFragment(\n    @location(0) uv: vec2<f32>,\n    @builtin(position) position: vec4<f32>\n) -> @location(0) vec4<f32> {\n    let pixelSize: f32 = asciiUniforms.uSize;\n    let coord: vec2<f32> = mapCoord(uv);\n\n    // get the rounded color..\n    var pixCoord: vec2<f32> = pixelate(coord, vec2<f32>(pixelSize));\n    pixCoord = unmapCoord(pixCoord);\n\n    var color = textureSample(uTexture, uSampler, pixCoord);\n\n    // determine the character to use\n    let gray: f32 = 0.3 * color.r + 0.59 * color.g + 0.11 * color.b;\n    \n    var n: f32 = 65536.0; // .\n    if (gray > 0.2) {\n        n = 65600.0;    // :\n    }\n    if (gray > 0.3) {\n        n = 332772.0;   // *\n    }\n    if (gray > 0.4) {\n        n = 15255086.0; // o\n    }\n    if (gray > 0.5) {\n        n = 23385164.0; // &\n    }\n    if (gray > 0.6) {\n        n = 15252014.0; // 8\n    }\n    if (gray > 0.7) {\n        n = 13199452.0; // @\n    }\n    if (gray > 0.8) {\n        n = 11512810.0; // #\n    }\n\n    // get the mod..\n    let modd: vec2<f32> = getMod(coord, vec2<f32>(pixelSize));\n    return select(color, vec4<f32>(asciiUniforms.uColor, 1.), asciiUniforms.uReplaceColor > 0.5) * character(n, vec2<f32>(-1.0) + modd * 2.0);\n}\n\nfn pixelate(coord: vec2<f32>, size: vec2<f32>) -> vec2<f32>\n{\n    return floor( coord / size ) * size;\n}\n\nfn getMod(coord: vec2<f32>, size: vec2<f32>) -> vec2<f32>\n{\n    return moduloVec2( coord , size) / size;\n}\n\nfn character(n: f32, p: vec2<f32>) -> f32\n{\n    var q: vec2<f32> = floor(p*vec2<f32>(4.0, 4.0) + 2.5);\n\n    if (clamp(q.x, 0.0, 4.0) == q.x)\n    {\n        if (clamp(q.y, 0.0, 4.0) == q.y)\n        {\n        if (i32(modulo(n/exp2(q.x + 5.0*q.y), 2.0)) == 1)\n        {\n            return 1.0;\n        }\n        }\n    }\n\n    return 0.0;\n}\n\nfn modulo(x: f32, y: f32) -> f32\n{\n  return x - y * floor(x/y);\n}\n\nfn moduloVec2(x: vec2<f32>, y: vec2<f32>) -> vec2<f32>\n{\n  return x - y * floor(x/y);\n}\n\nfn mapCoord(coord: vec2<f32> ) -> vec2<f32>\n{\n    var mappedCoord: vec2<f32> = coord;\n    mappedCoord *= gfu.uInputSize.xy;\n    mappedCoord += gfu.uOutputFrame.xy;\n    return mappedCoord;\n}\n\nfn unmapCoord(coord: vec2<f32> ) -> vec2<f32>\n{\n    var mappedCoord: vec2<f32> = coord;\n    mappedCoord -= gfu.uOutputFrame.xy;\n    mappedCoord /= gfu.uInputSize.xy;\n    return mappedCoord;\n}",entryPoint:"mainFragment"}}),glProgram:r.M2g.from({vertex:o.A,fragment:"precision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform float uSize;\nuniform vec3 uColor;\nuniform float uReplaceColor;\n\nuniform vec4 uInputSize;\n\nvec2 mapCoord( vec2 coord )\n{\n    coord *= uInputSize.xy;\n    coord += uInputSize.zw;\n\n    return coord;\n}\n\nvec2 unmapCoord( vec2 coord )\n{\n    coord -= uInputSize.zw;\n    coord /= uInputSize.xy;\n\n    return coord;\n}\n\nvec2 pixelate(vec2 coord, vec2 size)\n{\n    return floor(coord / size) * size;\n}\n\nvec2 getMod(vec2 coord, vec2 size)\n{\n    return mod(coord, size) / size;\n}\n\nfloat character(float n, vec2 p)\n{\n    p = floor(p*vec2(4.0, 4.0) + 2.5);\n\n    if (clamp(p.x, 0.0, 4.0) == p.x)\n    {\n        if (clamp(p.y, 0.0, 4.0) == p.y)\n        {\n            if (int(mod(n/exp2(p.x + 5.0*p.y), 2.0)) == 1) return 1.0;\n        }\n    }\n    return 0.0;\n}\n\nvoid main()\n{\n    vec2 coord = mapCoord(vTextureCoord);\n\n    // get the grid position\n    vec2 pixCoord = pixelate(coord, vec2(uSize));\n    pixCoord = unmapCoord(pixCoord);\n\n    // sample the color at grid position\n    vec4 color = texture(uTexture, pixCoord);\n\n    // brightness of the color as it's perceived by the human eye\n    float gray = 0.3 * color.r + 0.59 * color.g + 0.11 * color.b;\n\n    // determine the character to use\n    float n =  65536.0;             // .\n    if (gray > 0.2) n = 65600.0;    // :\n    if (gray > 0.3) n = 332772.0;   // *\n    if (gray > 0.4) n = 15255086.0; // o\n    if (gray > 0.5) n = 23385164.0; // &\n    if (gray > 0.6) n = 15252014.0; // 8\n    if (gray > 0.7) n = 13199452.0; // @\n    if (gray > 0.8) n = 11512810.0; // #\n\n    // get the mod..\n    vec2 modd = getMod(coord, vec2(uSize));\n\n    finalColor = (uReplaceColor > 0.5 ? vec4(uColor, 1.) : color) * character( n, vec2(-1.0) + modd * 2.0);\n}\n",name:"ascii-filter"}),resources:{asciiUniforms:{uSize:{value:t.size,type:"f32"},uColor:{value:new Float32Array(3),type:"vec3<f32>"},uReplaceColor:{value:Number(u),type:"f32"}}}}),s(this,"uniforms"),s(this,"_color"),this.uniforms=this.resources.asciiUniforms.uniforms,this._color=new r.Q1f,this.color=t.color??16777215}get size(){return this.uniforms.uSize}set size(e){this.uniforms.uSize=e}get color(){return this._color.value}set color(e){this._color.setValue(e);const[n,t,r]=this._color.toArray();this.uniforms.uColor[0]=n,this.uniforms.uColor[1]=t,this.uniforms.uColor[2]=r}get replaceColor(){return this.uniforms.uReplaceColor>.5}set replaceColor(e){this.uniforms.uReplaceColor=e?1:0}};s(l,"DEFAULT_OPTIONS",{size:8,color:16777215,replaceColor:!1})},573:(e,n,t)=>{"use strict";var r=t(3423);t(4742),t(9096),Object.defineProperty;r.eV2},8464:(e,n,t)=>{"use strict";var r=t(3423),o=t(4742),i=t(9096),u=Object.defineProperty,s=(e,n,t)=>(((e,n,t)=>{n in e?u(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t})(e,"symbol"!=typeof n?n+"":n,t),t);const l=class e extends r.dJT{constructor(n){n={...e.DEFAULT_OPTIONS,...n};super({gpuProgram:r.BrD.from({vertex:{source:i.A,entryPoint:"mainVertex"},fragment:{source:"struct BevelUniforms {\n  uLightColor: vec3<f32>,\n  uLightAlpha: f32,\n  uShadowColor: vec3<f32>,\n  uShadowAlpha: f32,\n  uTransform: vec2<f32>,\n};\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> bevelUniforms : BevelUniforms;\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  let transform = vec2<f32>(1.0 / gfu.uInputSize.xy) * vec2<f32>(bevelUniforms.uTransform.x, bevelUniforms.uTransform.y);\n  var color: vec4<f32> = textureSample(uTexture, uSampler, uv);\n  let lightSample: f32 = textureSample(uTexture, uSampler, uv - transform).a;\n  let shadowSample: f32 = textureSample(uTexture, uSampler, uv + transform).a;\n\n  let light = vec4<f32>(bevelUniforms.uLightColor, bevelUniforms.uLightAlpha);\n  let shadow = vec4<f32>(bevelUniforms.uShadowColor, bevelUniforms.uShadowAlpha);\n\n  color = vec4<f32>(mix(color.rgb, light.rgb, clamp((color.a - lightSample) * light.a, 0.0, 1.0)), color.a);\n  color = vec4<f32>(mix(color.rgb, shadow.rgb, clamp((color.a - shadowSample) * shadow.a, 0.0, 1.0)), color.a);\n  \n  return vec4<f32>(color.rgb * color.a, color.a);\n}",entryPoint:"mainFragment"}}),glProgram:r.M2g.from({vertex:o.A,fragment:"precision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform vec2 uTransform;\nuniform vec3 uLightColor;\nuniform float uLightAlpha;\nuniform vec3 uShadowColor;\nuniform float uShadowAlpha;\n\nuniform vec4 uInputSize;\n\nvoid main(void) {\n    vec2 transform = vec2(1.0 / uInputSize) * vec2(uTransform.x, uTransform.y);\n    vec4 color = texture(uTexture, vTextureCoord);\n    float light = texture(uTexture, vTextureCoord - transform).a;\n    float shadow = texture(uTexture, vTextureCoord + transform).a;\n\n    color.rgb = mix(color.rgb, uLightColor, clamp((color.a - light) * uLightAlpha, 0.0, 1.0));\n    color.rgb = mix(color.rgb, uShadowColor, clamp((color.a - shadow) * uShadowAlpha, 0.0, 1.0));\n    finalColor = vec4(color.rgb * color.a, color.a);\n}\n",name:"bevel-filter"}),resources:{bevelUniforms:{uLightColor:{value:new Float32Array(3),type:"vec3<f32>"},uLightAlpha:{value:n.lightAlpha,type:"f32"},uShadowColor:{value:new Float32Array(3),type:"vec3<f32>"},uShadowAlpha:{value:n.shadowAlpha,type:"f32"},uTransform:{value:new Float32Array(2),type:"vec2<f32>"}}},padding:1}),s(this,"uniforms"),s(this,"_thickness"),s(this,"_rotation"),s(this,"_lightColor"),s(this,"_shadowColor"),this.uniforms=this.resources.bevelUniforms.uniforms,this._lightColor=new r.Q1f,this._shadowColor=new r.Q1f,this.lightColor=n.lightColor??16777215,this.shadowColor=n.shadowColor??0,Object.assign(this,n)}get rotation(){return this._rotation/r.Tde}set rotation(e){this._rotation=e*r.Tde,this._updateTransform()}get thickness(){return this._thickness}set thickness(e){this._thickness=e,this._updateTransform()}get lightColor(){return this._lightColor.value}set lightColor(e){this._lightColor.setValue(e);const[n,t,r]=this._lightColor.toArray();this.uniforms.uLightColor[0]=n,this.uniforms.uLightColor[1]=t,this.uniforms.uLightColor[2]=r}get lightAlpha(){return this.uniforms.uLightAlpha}set lightAlpha(e){this.uniforms.uLightAlpha=e}get shadowColor(){return this._shadowColor.value}set shadowColor(e){this._shadowColor.setValue(e);const[n,t,r]=this._shadowColor.toArray();this.uniforms.uShadowColor[0]=n,this.uniforms.uShadowColor[1]=t,this.uniforms.uShadowColor[2]=r}get shadowAlpha(){return this.uniforms.uShadowAlpha}set shadowAlpha(e){this.uniforms.uShadowAlpha=e}_updateTransform(){this.uniforms.uTransform[0]=this.thickness*Math.cos(this._rotation),this.uniforms.uTransform[1]=this.thickness*Math.sin(this._rotation)}};s(l,"DEFAULT_OPTIONS",{rotation:45,thickness:2,lightColor:16777215,lightAlpha:.7,shadowColor:0,shadowAlpha:.7})},2407:(e,n,t)=>{"use strict";var r=t(3423),o=Object.defineProperty,i=(e,n,t)=>(((e,n,t)=>{n in e?o(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t})(e,"symbol"!=typeof n?n+"":n,t),t);const u=class e extends r.ZYG{constructor(...n){let t=n[0]??{};if("number"==typeof t||Array.isArray(t)||"x"in t&&"y"in t){(0,r.t66)("6.0.0","BloomFilter constructor params are now options object. See params: { strength, quality, resolution, kernelSize }");let e=t;Array.isArray(e)&&(e={x:e[0],y:e[1]}),t={strength:e},void 0!==n[1]&&(t.quality=n[1]),void 0!==n[2]&&(t.resolution=n[2]),void 0!==n[3]&&(t.kernelSize=n[3])}t={...e.DEFAULT_OPTIONS,...t},super(),i(this,"_blurXFilter"),i(this,"_blurYFilter"),i(this,"_strength"),this._strength={x:2,y:2},t.strength&&("number"==typeof t.strength?(this._strength.x=t.strength,this._strength.y=t.strength):(this._strength.x=t.strength.x,this._strength.y=t.strength.y)),this._blurXFilter=new r.Hii({...t,horizontal:!0,strength:this.strengthX}),this._blurYFilter=new r.Hii({...t,horizontal:!1,strength:this.strengthY}),this._blurYFilter.blendMode="screen",Object.assign(this,t)}apply(e,n,t,o){const i=r.Wny.getSameSizeTexture(n);e.applyFilter(this,n,t,o),this._blurXFilter.apply(e,n,i,!0),this._blurYFilter.apply(e,i,t,!1),r.Wny.returnTexture(i)}get strength(){return this._strength}set strength(e){this._strength="number"==typeof e?{x:e,y:e}:e,this._updateStrength()}get strengthX(){return this.strength.x}set strengthX(e){this.strength.x=e,this._updateStrength()}get strengthY(){return this.strength.y}set strengthY(e){this.strength.y=e,this._updateStrength()}_updateStrength(){this._blurXFilter.blur=this.strengthX,this._blurYFilter.blur=this.strengthY}get blur(){return(0,r.t66)("6.0.0","BloomFilter.blur is deprecated, please use BloomFilter.strength instead"),this.strengthX}set blur(e){(0,r.t66)("6.0.0","BloomFilter.blur is deprecated, please use BloomFilter.strength instead"),this.strength=e}get blurX(){return(0,r.t66)("6.0.0","BloomFilter.blurX is deprecated, please use BloomFilter.strengthX instead"),this.strengthX}set blurX(e){(0,r.t66)("6.0.0","BloomFilter.blurX is deprecated, please use BloomFilter.strengthX instead"),this.strengthX=e}get blurY(){return(0,r.t66)("6.0.0","BloomFilter.blurY is deprecated, please use BloomFilter.strengthY instead"),this.strengthY}set blurY(e){(0,r.t66)("6.0.0","BloomFilter.blurY is deprecated, please use BloomFilter.strengthY instead"),this.strengthY=e}};i(u,"DEFAULT_OPTIONS",{strength:{x:2,y:2},quality:4,resolution:1,kernelSize:5})},9089:(e,n,t)=>{"use strict";var r=t(3423),o=t(4742),i=t(9096),u=Object.defineProperty,s=(e,n,t)=>(((e,n,t)=>{n in e?u(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t})(e,"symbol"!=typeof n?n+"":n,t),t);const l=class e extends r.dJT{constructor(n){n={...e.DEFAULT_OPTIONS,...n};super({gpuProgram:r.BrD.from({vertex:{source:i.A,entryPoint:"mainVertex"},fragment:{source:"struct BulgePinchUniforms {\n  uDimensions: vec2<f32>,\n  uCenter: vec2<f32>,\n  uRadius: f32,\n  uStrength: f32,\n};\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> bulgePinchUniforms : BulgePinchUniforms;\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  let dimensions: vec2<f32> = bulgePinchUniforms.uDimensions;\n  let center: vec2<f32> = bulgePinchUniforms.uCenter;\n  let radius: f32 = bulgePinchUniforms.uRadius;\n  let strength: f32 = bulgePinchUniforms.uStrength;\n  var coord: vec2<f32> = (uv * gfu.uInputSize.xy) - center * dimensions.xy;\n\n  let distance: f32 = length(coord);\n\n  if (distance < radius) {\n      let percent: f32 = distance / radius;\n      if (strength > 0.0) {\n          coord *= mix(1.0, smoothstep(0.0, radius / distance, percent), strength * 0.75);\n      } else {\n          coord *= mix(1.0, pow(percent, 1.0 + strength * 0.75) * radius / distance, 1.0 - percent);\n      }\n  }\n    coord += (center * dimensions.xy);\n    coord /= gfu.uInputSize.xy;\n\n    let clampedCoord: vec2<f32> = clamp(coord, gfu.uInputClamp.xy, gfu.uInputClamp.zw);\n    var color: vec4<f32> = textureSample(uTexture, uSampler, clampedCoord);\n    if (coord.x != clampedCoord.x && coord.y != clampedCoord.y) {\n        color *= max(0.0, 1.0 - length(coord - clampedCoord));\n    }\n\n    return color;\n}\n\nfn compareVec2(x: vec2<f32>, y: vec2<f32>) -> bool\n{\n  if (x.x == y.x && x.y == y.y)\n  {\n    return true;\n  }\n\n  return false;\n}",entryPoint:"mainFragment"}}),glProgram:r.M2g.from({vertex:o.A,fragment:"precision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform vec2 uDimensions;\nuniform vec2 uCenter;\nuniform float uRadius;\nuniform float uStrength;\n\nuniform vec4 uInputSize;\nuniform vec4 uInputClamp;\n\nvoid main()\n{\n    vec2 coord = vTextureCoord * uInputSize.xy;\n    coord -= uCenter * uDimensions.xy;\n    float distance = length(coord);\n\n    if (distance < uRadius) {\n        float percent = distance / uRadius;\n        if (uStrength > 0.0) {\n            coord *= mix(1.0, smoothstep(0.0, uRadius / distance, percent), uStrength * 0.75);\n        } else {\n            coord *= mix(1.0, pow(percent, 1.0 + uStrength * 0.75) * uRadius / distance, 1.0 - percent);\n        }\n    }\n\n    coord += uCenter * uDimensions.xy;\n    coord /= uInputSize.xy;\n    vec2 clampedCoord = clamp(coord, uInputClamp.xy, uInputClamp.zw);\n    vec4 color = texture(uTexture, clampedCoord);\n\n    if (coord != clampedCoord) {\n        color *= max(0.0, 1.0 - length(coord - clampedCoord));\n    }\n\n    finalColor = color;\n}\n",name:"bulge-pinch-filter"}),resources:{bulgePinchUniforms:{uDimensions:{value:[0,0],type:"vec2<f32>"},uCenter:{value:n.center,type:"vec2<f32>"},uRadius:{value:n.radius,type:"f32"},uStrength:{value:n.strength,type:"f32"}}}}),s(this,"uniforms"),this.uniforms=this.resources.bulgePinchUniforms.uniforms,Object.assign(this,n)}apply(e,n,t,r){this.uniforms.uDimensions[0]=n.frame.width,this.uniforms.uDimensions[1]=n.frame.height,e.applyFilter(this,n,t,r)}get center(){return this.uniforms.uCenter}set center(e){"number"==typeof e&&(e={x:e,y:e}),Array.isArray(e)&&(e={x:e[0],y:e[1]}),this.uniforms.uCenter=e}get centerX(){return this.uniforms.uCenter.x}set centerX(e){this.uniforms.uCenter.x=e}get centerY(){return this.uniforms.uCenter.y}set centerY(e){this.uniforms.uCenter.y=e}get radius(){return this.uniforms.uRadius}set radius(e){this.uniforms.uRadius=e}get strength(){return this.uniforms.uStrength}set strength(e){this.uniforms.uStrength=e}};s(l,"DEFAULT_OPTIONS",{center:{x:.5,y:.5},radius:100,strength:1})},6993:(e,n,t)=>{"use strict";var r=t(3423),o="struct BaseUniforms {\n  uOptions: vec4<f32>,\n  uCounts: vec2<f32>,\n};\n\nstruct StopsUniforms {\n  uColors: array<vec3<f32>, MAX_STOPS>,\n  uStops: array<vec4<f32>, MAX_STOPS>,\n};\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> baseUniforms : BaseUniforms;\n@group(1) @binding(1) var<uniform> stopsUniforms : StopsUniforms;\n\nstruct VSOutput {\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>,\n  @location(1) coord : vec2<f32>\n};\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\nfn filterCoord( vTextureCoord:vec2<f32> ) -> vec2<f32>\n{\n    return vTextureCoord * gfu.uInputSize.xy / gfu.uOutputFrame.zw;\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \n}\n\nfn getSize() -> vec2<f32>\n{\n  return gfu.uGlobalFrame.zw;\n}\n  \n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n  let vTextureCoord: vec2<f32> = filterTextureCoord(aPosition);\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   vTextureCoord,\n   filterCoord(vTextureCoord),\n  );\n}\n\nstruct ColorStop {\n  offset: f32,\n  color: vec3<f32>,\n  alpha: f32,\n};\n\nfn rotate2d(angle: f32) -> mat2x2<f32>{\n  return mat2x2(cos(angle), -sin(angle),\n  sin(angle), cos(angle));\n}\n\nfn projectLinearPosition(pos: vec2<f32>, angle: f32) -> f32 {\n  var center: vec2<f32> = vec2<f32>(0.5);\n  var result: vec2<f32> = pos - center;\n  result = rotate2d(angle) * result;\n  result = result + center;\n  return clamp(result.x, 0.0, 1.0);\n}\n\nfn projectRadialPosition(pos: vec2<f32>) -> f32 {\n  var r: f32 = distance(pos, vec2<f32>(0.5));\n  return clamp(2.0 * r, 0.0, 1.0);\n}\n\nfn projectAnglePosition(pos: vec2<f32>, angle: f32) -> f32 {\n  var center: vec2<f32> = pos - vec2<f32>(0.5, 0.5);\n  var polarAngle: f32 = atan2(-center.y, center.x);\n  return ((polarAngle + angle) % PI_2) / PI_2;\n}\n\nfn projectPosition(pos: vec2<f32>, gradientType: i32, angle: f32) -> f32 {\n  if (gradientType == TYPE_LINEAR) {\n      return projectLinearPosition(pos, angle);\n  } else if (gradientType == TYPE_RADIAL) {\n      return projectRadialPosition(pos);\n  } else if (gradientType == TYPE_CONIC) {\n      return projectAnglePosition(pos, angle);\n  }\n\n  return pos.y;\n}\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>,\n  @location(1) coord : vec2<f32>\n) -> @location(0) vec4<f32> {\n  let uType: i32 = i32(baseUniforms.uOptions[0]);\n  let uAngle: f32 = baseUniforms.uOptions[1];\n  let uAlpha: f32 = baseUniforms.uOptions[2];\n  let uReplace: f32 = baseUniforms.uOptions[3];\n\n  let uNumStops: i32 = i32(baseUniforms.uCounts[0]);\n  let uMaxColors: f32 = baseUniforms.uCounts[1];\n\n  // current/original color\n  var currentColor: vec4<f32> = textureSample(uTexture, uSampler, uv);\n\n  // skip calculations if gradient alpha is 0\n  if (uAlpha == 0.0) { return currentColor; }\n\n  // project position\n  var y: f32 = projectPosition(coord, uType, radians(uAngle));\n\n  // check gradient bounds\n  var offsetMin: f32 = stopsUniforms.uStops[0][0];\n  var offsetMax: f32 = 0.0;\n\n  let numStops: i32 = uNumStops;\n\n  for (var i: i32 = 0; i < MAX_STOPS; i = i + 1) {\n      if (i == numStops - 1) { // last index\n          offsetMax = stopsUniforms.uStops[i][0];\n      }\n  }\n\n  if (y  < offsetMin || y > offsetMax) { return currentColor; }\n\n  // limit colors\n  if (uMaxColors > 0.0) {\n      var stepSize: f32 = 1.0 / uMaxColors;\n      var stepNumber: f32 = floor(y / stepSize);\n      y = stepSize * (stepNumber + 0.5); // offset by 0.5 to use color from middle of segment\n  }\n\n  // find color stops\n  var stopFrom: ColorStop;\n  var stopTo: ColorStop;\n\n  for (var i: i32 = 0; i < MAX_STOPS; i = i + 1) {\n      if (y >= stopsUniforms.uStops[i][0]) {\n          stopFrom = ColorStop(stopsUniforms.uStops[i][0], stopsUniforms.uColors[i], stopsUniforms.uStops[i][1]);\n          stopTo = ColorStop(stopsUniforms.uStops[i + 1][0], stopsUniforms.uColors[i + 1], stopsUniforms.uStops[i + 1][1]);\n      }\n\n      if (i == numStops - 1) { // last index\n          break;\n      }\n  }\n\n  // mix colors from stops\n  var colorFrom: vec4<f32> = vec4<f32>(stopFrom.color * stopFrom.alpha, stopFrom.alpha);\n  var colorTo: vec4<f32> = vec4<f32>(stopTo.color * stopTo.alpha, stopTo.alpha);\n\n  var segmentHeight: f32 = stopTo.offset - stopFrom.offset;\n  var relativePos: f32 = y - stopFrom.offset; // position from 0 to [segmentHeight]\n  var relativePercent: f32 = relativePos / segmentHeight; // position in percent between [from.offset] and [to.offset].\n\n  var gradientAlpha: f32 = uAlpha * currentColor.a;\n  var gradientColor: vec4<f32> = mix(colorFrom, colorTo, relativePercent) * gradientAlpha;\n\n  if (uReplace < 0.5) {\n      // mix resulting color with current color\n      return gradientColor + currentColor * (1.0 - gradientColor.a);\n  } else {\n      // replace with gradient color\n      return gradientColor;\n  }\n}\n\nconst PI: f32 = 3.14159265358979323846264;\nconst PI_2: f32 = PI * 2.0;\n\nconst TYPE_LINEAR: i32 = 0;\nconst TYPE_RADIAL: i32 = 1;\nconst TYPE_CONIC: i32 = 2;\nconst MAX_STOPS: i32 = 32;",i=t(2995),u=Object.defineProperty,s=(e,n,t)=>(((e,n,t)=>{n in e?u(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t})(e,"symbol"!=typeof n?n+"":n,t),t);const l=class e extends r.dJT{constructor(n){if(!(n=n&&"css"in n?{...(0,i.Xo)(n.css||""),alpha:n.alpha??e.defaults.alpha,maxColors:n.maxColors??e.defaults.maxColors}:{...e.defaults,...n}).stops||n.stops.length<2)throw new Error("ColorGradientFilter requires at least 2 color stops.");super({gpuProgram:r.BrD.from({vertex:{source:o,entryPoint:"mainVertex"},fragment:{source:o,entryPoint:"mainFragment"}}),glProgram:r.M2g.from({vertex:"in vec2 aPosition;\nout vec2 vTextureCoord;\nout vec2 vFilterCoord;\n\nuniform vec4 uInputSize;\nuniform vec4 uOutputFrame;\nuniform vec4 uOutputTexture;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\n    \n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n    vFilterCoord = vTextureCoord * uInputSize.xy / uOutputFrame.zw;\n}\n",fragment:"precision highp float;\nin vec2 vTextureCoord;\nin vec2 vFilterCoord;\nout vec4 finalColor;\n\nconst int TYPE_LINEAR = 0;\nconst int TYPE_RADIAL = 1;\nconst int TYPE_CONIC = 2;\nconst int MAX_STOPS = 32;\n\nuniform sampler2D uTexture;\nuniform vec4 uOptions;\nuniform vec2 uCounts;\nuniform vec3 uColors[MAX_STOPS];\nuniform vec4 uStops[MAX_STOPS];\n\nconst float PI = 3.1415926538;\nconst float PI_2 = PI*2.;\n\nstruct ColorStop {\n    float offset;\n    vec3 color;\n    float alpha;\n};\n\nmat2 rotate2d(float angle){\n    return mat2(cos(angle), -sin(angle),\n    sin(angle), cos(angle));\n}\n\nfloat projectLinearPosition(vec2 pos, float angle){\n    vec2 center = vec2(0.5);\n    vec2 result = pos - center;\n    result = rotate2d(angle) * result;\n    result = result + center;\n    return clamp(result.x, 0., 1.);\n}\n\nfloat projectRadialPosition(vec2 pos) {\n    float r = distance(pos, vec2(0.5));\n    return clamp(2.*r, 0., 1.);\n}\n\nfloat projectAnglePosition(vec2 pos, float angle) {\n    vec2 center = pos - vec2(0.5);\n    float polarAngle=atan(-center.y, center.x);\n    return mod(polarAngle + angle, PI_2) / PI_2;\n}\n\nfloat projectPosition(vec2 pos, int type, float angle) {\n    if (type == TYPE_LINEAR) {\n        return projectLinearPosition(pos, angle);\n    } else if (type == TYPE_RADIAL) {\n        return projectRadialPosition(pos);\n    } else if (type == TYPE_CONIC) {\n        return projectAnglePosition(pos, angle);\n    }\n\n    return pos.y;\n}\n\nvoid main(void) {\n    int uType = int(uOptions[0]);\n    float uAngle = uOptions[1];\n    float uAlpha = uOptions[2];\n    float uReplace = uOptions[3];\n\n    int uNumStops = int(uCounts[0]);\n    float uMaxColors = uCounts[1];\n\n    // current/original color\n    vec4 currentColor = texture(uTexture, vTextureCoord);\n\n    // skip calculations if gradient alpha is 0\n    if (0.0 == uAlpha) {\n        finalColor = currentColor;\n        return;\n    }\n\n    // project position\n    float y = projectPosition(vFilterCoord, int(uType), radians(uAngle));\n\n    // check gradient bounds\n    float offsetMin = uStops[0][0];\n    float offsetMax = 0.0;\n\n    int numStops = int(uNumStops);\n\n    for (int i = 0; i < MAX_STOPS; i++) {\n        if (i == numStops-1){ // last index\n            offsetMax = uStops[i][0];\n        }\n    }\n\n    if (y  < offsetMin || y > offsetMax) {\n        finalColor = currentColor;\n        return;\n    }\n\n    // limit colors\n    if (uMaxColors > 0.) {\n        float stepSize = 1./uMaxColors;\n        float stepNumber = float(floor(y/stepSize));\n        y = stepSize * (stepNumber + 0.5);// offset by 0.5 to use color from middle of segment\n    }\n\n    // find color stops\n    ColorStop from;\n    ColorStop to;\n\n    for (int i = 0; i < MAX_STOPS; i++) {\n        if (y >= uStops[i][0]) {\n            from = ColorStop(uStops[i][0], uColors[i], uStops[i][1]);\n            to = ColorStop(uStops[i+1][0], uColors[i+1], uStops[i+1][1]);\n        }\n\n        if (i == numStops-1){ // last index\n            break;\n        }\n    }\n\n    // mix colors from stops\n    vec4 colorFrom = vec4(from.color * from.alpha, from.alpha);\n    vec4 colorTo = vec4(to.color * to.alpha, to.alpha);\n\n    float segmentHeight = to.offset - from.offset;\n    float relativePos = y - from.offset;// position from 0 to [segmentHeight]\n    float relativePercent = relativePos / segmentHeight;// position in percent between [from.offset] and [to.offset].\n\n    float gradientAlpha = uAlpha * currentColor.a;\n    vec4 gradientColor = mix(colorFrom, colorTo, relativePercent) * gradientAlpha;\n\n    if (uReplace < 0.5) {\n        // mix resulting color with current color\n        finalColor = gradientColor + currentColor*(1.-gradientColor.a);\n    } else {\n        // replace with gradient color\n        finalColor = gradientColor;\n    }\n}\n",name:"color-gradient-filter"}),resources:{baseUniforms:{uOptions:{value:[n.type,n.angle??90,n.alpha,n.replace?1:0],type:"vec4<f32>"},uCounts:{value:[n.stops.length,n.maxColors],type:"vec2<f32>"}},stopsUniforms:{uColors:{value:new Float32Array(96),type:"vec3<f32>",size:32},uStops:{value:new Float32Array(128),type:"vec4<f32>",size:32}}}}),s(this,"baseUniforms"),s(this,"stopsUniforms"),s(this,"_stops",[]),this.baseUniforms=this.resources.baseUniforms.uniforms,this.stopsUniforms=this.resources.stopsUniforms.uniforms,Object.assign(this,n)}get stops(){return this._stops}set stops(e){const n=function(e){return[...e].sort(((e,n)=>e.offset-n.offset))}(e),t=new r.Q1f;let o,i,u;for(let e=0;e<n.length;e++){t.setValue(n[e].color);const r=3*e;[o,i,u]=t.toArray(),this.stopsUniforms.uColors[r]=o,this.stopsUniforms.uColors[r+1]=i,this.stopsUniforms.uColors[r+2]=u,this.stopsUniforms.uStops[4*e]=n[e].offset,this.stopsUniforms.uStops[4*e+1]=n[e].alpha}this.baseUniforms.uCounts[0]=n.length,this._stops=n}get type(){return this.baseUniforms.uOptions[0]}set type(e){this.baseUniforms.uOptions[0]=e}get angle(){return this.baseUniforms.uOptions[1]+90}set angle(e){this.baseUniforms.uOptions[1]=e-90}get alpha(){return this.baseUniforms.uOptions[2]}set alpha(e){this.baseUniforms.uOptions[2]=e}get maxColors(){return this.baseUniforms.uCounts[1]}set maxColors(e){this.baseUniforms.uCounts[1]=e}get replace(){return this.baseUniforms.uOptions[3]>.5}set replace(e){this.baseUniforms.uOptions[3]=e?1:0}};s(l,"LINEAR",0),s(l,"RADIAL",1),s(l,"CONIC",2),s(l,"defaults",{type:l.LINEAR,stops:[{offset:0,color:16711680,alpha:1},{offset:1,color:255,alpha:1}],alpha:1,angle:90,maxColors:0,replace:!1})},2995:(e,n,t)=>{"use strict";var r,o;t.d(n,{Xo:()=>s}),(o=o||{}).stringify=(r={"visit_linear-gradient":function(e){return r.visit_gradient(e)},"visit_repeating-linear-gradient":function(e){return r.visit_gradient(e)},"visit_radial-gradient":function(e){return r.visit_gradient(e)},"visit_repeating-radial-gradient":function(e){return r.visit_gradient(e)},visit_gradient:function(e){var n=r.visit(e.orientation);return n&&(n+=", "),e.type+"("+n+r.visit(e.colorStops)+")"},visit_shape:function(e){var n=e.value,t=r.visit(e.at),o=r.visit(e.style);return o&&(n+=" "+o),t&&(n+=" at "+t),n},"visit_default-radial":function(e){var n="",t=r.visit(e.at);return t&&(n+=t),n},"visit_extent-keyword":function(e){var n=e.value,t=r.visit(e.at);return t&&(n+=" at "+t),n},"visit_position-keyword":function(e){return e.value},visit_position:function(e){return r.visit(e.value.x)+" "+r.visit(e.value.y)},"visit_%":function(e){return e.value+"%"},visit_em:function(e){return e.value+"em"},visit_px:function(e){return e.value+"px"},visit_literal:function(e){return r.visit_color(e.value,e)},visit_hex:function(e){return r.visit_color("#"+e.value,e)},visit_rgb:function(e){return r.visit_color("rgb("+e.value.join(", ")+")",e)},visit_rgba:function(e){return r.visit_color("rgba("+e.value.join(", ")+")",e)},visit_color:function(e,n){var t=e,o=r.visit(n.length);return o&&(t+=" "+o),t},visit_angular:function(e){return e.value+"deg"},visit_directional:function(e){return"to "+e.value},visit_array:function(e){var n="",t=e.length;return e.forEach((function(e,o){n+=r.visit(e),o<t-1&&(n+=", ")})),n},visit:function(e){if(!e)return"";if(e instanceof Array)return r.visit_array(e,"");if(e.type){var n=r["visit_"+e.type];if(n)return n(e);throw Error("Missing visitor visit_"+e.type)}throw Error("Invalid node.")}},function(e){return r.visit(e)}),(o=o||{}).parse=function(){var e=/^(\-(webkit|o|ms|moz)\-)?(linear\-gradient)/i,n=/^(\-(webkit|o|ms|moz)\-)?(repeating\-linear\-gradient)/i,t=/^(\-(webkit|o|ms|moz)\-)?(radial\-gradient)/i,r=/^(\-(webkit|o|ms|moz)\-)?(repeating\-radial\-gradient)/i,o=/^to (left (top|bottom)|right (top|bottom)|left|right|top|bottom)/i,i=/^(closest\-side|closest\-corner|farthest\-side|farthest\-corner|contain|cover)/,u=/^(left|center|right|top|bottom)/i,s=/^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))px/,l=/^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))\%/,a=/^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))em/,c=/^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))deg/,f=/^\(/,m=/^\)/,p=/^,/,g=/^\#([0-9a-fA-F]+)/,v=/^([a-zA-Z]+)/,d=/^rgb/i,h=/^rgba/i,x=/^(([0-9]*\.[0-9]+)|([0-9]+\.?))/,y="";function S(e){var n=new Error(y+": "+e);throw n.source=y,n}function b(){var e=U(C);return y.length>0&&S("Invalid input not EOF"),e}function C(){return T("linear-gradient",e,P)||T("repeating-linear-gradient",n,P)||T("radial-gradient",t,_)||T("repeating-radial-gradient",r,_)}function T(e,n,t){return z(n,(function(n){var r=t();return r&&(G(p)||S("Missing comma before color stops")),{type:e,orientation:r,colorStops:U(I)}}))}function z(e,n){var t=G(e);if(t){G(f)||S("Missing (");var r=n(t);return G(m)||S("Missing )"),r}}function P(){return L("directional",o,1)||L("angular",c,1)}function _(){var e,n,t=A();return t&&((e=[]).push(t),n=y,G(p)&&((t=A())?e.push(t):y=n)),e}function A(){var e=function(){var e=L("shape",/^(circle)/i,0);e&&(e.style=R()||w());return e}()||function(){var e=L("shape",/^(ellipse)/i,0);e&&(e.style=D()||w());return e}();if(e)e.at=O();else{var n=w();if(n){e=n;var t=O();t&&(e.at=t)}else{var r=F();r&&(e={type:"default-radial",at:r})}}return e}function w(){return L("extent-keyword",i,1)}function O(){if(L("position",/^at/,0)){var e=F();return e||S("Missing positioning value"),e}}function F(){var e={x:D(),y:D()};if(e.x||e.y)return{type:"position",value:e}}function U(e){var n=e(),t=[];if(n)for(t.push(n);G(p);)(n=e())?t.push(n):S("One extra comma");return t}function I(){var e=L("hex",g,1)||z(h,(function(){return{type:"rgba",value:U(M)}}))||z(d,(function(){return{type:"rgb",value:U(M)}}))||L("literal",v,0);return e||S("Expected color definition"),e.length=D(),e}function M(){return G(x)[1]}function D(){return L("%",l,1)||L("position-keyword",u,1)||R()}function R(){return L("px",s,1)||L("em",a,1)}function L(e,n,t){var r=G(n);if(r)return{type:e,value:r[t]}}function G(e){var n,t;return(t=/^[\n\r\t\s]+/.exec(y))&&B(t[0].length),(n=e.exec(y))&&B(n[0].length),n}function B(e){y=y.substr(e)}return function(e){return y=e.toString(),b()}}();var i=o.parse;o.stringify;var u=t(3423);function s(e){const n=i(function(e){let n=e.replace(/\s{2,}/gu," ");return n=n.replace(/;/g,""),n=n.replace(/ ,/g,","),n=n.replace(/\( /g,"("),n=n.replace(/ \)/g,")"),n.trim()}(e));if(0===n.length)throw new Error("Invalid CSS gradient.");if(1!==n.length)throw new Error("Unsupported CSS gradient (multiple gradients is not supported).");const t=n[0];return{type:function(e){const n={"linear-gradient":0,"radial-gradient":1};if(!(e in n))throw new Error(`Unsupported gradient type "${e}"`);return n[e]}(t.type),stops:function(e){const n=function(e){const n=[],t=-1;for(let r=0;r<e.length;r++){const o=e[r];let i=t;"literal"===o.type&&o.length&&"type"in o.length&&"%"===o.length.type&&"value"in o.length&&(i=parseFloat(o.length.value)/100),n.push(i)}const r=e=>{for(let r=e;r<n.length;r++)if(n[r]!==t)return{indexDelta:r-e,offset:n[r]};return{indexDelta:n.length-1-e,offset:1}};let o=0;for(let e=0;e<n.length;e++){const i=n[e];if(i!==t)o=i;else if(0===e)n[e]=0;else if(e+1===n.length)n[e]=1;else{const t=r(e),i=(t.offset-o)/(1+t.indexDelta);for(let r=0;r<=t.indexDelta;r++)n[e+r]=o+(r+1)*i;e+=t.indexDelta,o=n[e]}}return n.map(a)}(e),t=[],r=new u.Q1f;for(let o=0;o<e.length;o++){const i=l(e[o]),u=r.setValue(i).toArray();t.push({offset:n[o],color:u.slice(0,3),alpha:u[3]})}return t}(t.colorStops),angle:function(e){if(void 0===e)return 0;if("type"in e&&"value"in e)switch(e.type){case"angular":return parseFloat(e.value);case"directional":return function(e){const n={left:270,top:0,bottom:180,right:90,"left top":315,"top left":315,"left bottom":225,"bottom left":225,"right top":45,"top right":45,"right bottom":135,"bottom right":135};if(!(e in n))throw new Error(`Unsupported directional value "${e}"`);return n[e]}(e.value)}return 0}(t.orientation)}}function l(e){switch(e.type){case"hex":return`#${e.value}`;case"literal":return e.value;default:return`${e.type}(${e.value.join(",")})`}}function a(e){return e.toString().length>6?parseFloat(e.toString().substring(0,6)):e}},8761:(e,n,t)=>{"use strict";var r=t(3423),o=t(4742),i=t(9096),u=Object.defineProperty,s=(e,n,t)=>(((e,n,t)=>{n in e?u(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t})(e,"symbol"!=typeof n?n+"":n,t),t);const l=class e extends r.dJT{constructor(...n){let t=n[0]??{};if((t instanceof r.gPd||t instanceof r.v9C)&&((0,r.t66)("6.0.0","ColorMapFilter constructor params are now options object. See params: { colorMap, nearest, mix }"),t={colorMap:t},void 0!==n[1]&&(t.nearest=n[1]),void 0!==n[2]&&(t.mix=n[2])),t={...e.DEFAULT_OPTIONS,...t},!t.colorMap)throw Error("No color map texture source was provided to ColorMapFilter");super({gpuProgram:r.BrD.from({vertex:{source:i.A,entryPoint:"mainVertex"},fragment:{source:"struct ColorMapUniforms {\n  uMix: f32,\n  uSize: f32,\n  uSliceSize: f32,\n  uSlicePixelSize: f32,\n  uSliceInnerSize: f32,\n};\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> colorMapUniforms : ColorMapUniforms;\n@group(1) @binding(1) var uMapTexture: texture_2d<f32>;\n@group(1) @binding(2) var uMapSampler: sampler;\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  var color:vec4<f32> = textureSample(uTexture, uSampler, uv);\n\n  var adjusted: vec4<f32>;\n\n  var altColor: vec4<f32> = vec4<f32>(color.rgb / color.a, color.a);\n  let innerWidth: f32 = colorMapUniforms.uSize - 1.0;\n  let zSlice0: f32 = min(floor(color.b * innerWidth), innerWidth);\n  let zSlice1: f32 = min(zSlice0 + 1.0, innerWidth);\n  let xOffset: f32 = colorMapUniforms.uSlicePixelSize * 0.5 + color.r * colorMapUniforms.uSliceInnerSize;\n  let s0: f32 = xOffset + (zSlice0 * colorMapUniforms.uSliceSize);\n  let s1: f32 = xOffset + (zSlice1 * colorMapUniforms.uSliceSize);\n  let yOffset: f32 = colorMapUniforms.uSliceSize * 0.5 + color.g * (1.0 - colorMapUniforms.uSliceSize);\n  let slice0Color: vec4<f32> = textureSample(uMapTexture, uMapSampler, vec2(s0,yOffset));\n  let slice1Color: vec4<f32> = textureSample(uMapTexture, uMapSampler, vec2(s1,yOffset));\n  let zOffset: f32 = fract(color.b * innerWidth);\n  adjusted = mix(slice0Color, slice1Color, zOffset);\n  altColor = vec4<f32>(color.rgb * color.a, color.a);\n\n  let realColor: vec4<f32> = select(color, altColor, color.a > 0.0);\n\n  return vec4<f32>(mix(realColor, adjusted, colorMapUniforms.uMix).rgb, realColor.a);\n}",entryPoint:"mainFragment"}}),glProgram:r.M2g.from({vertex:o.A,fragment:"in vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform sampler2D uMapTexture;\nuniform float uMix;\nuniform float uSize;\nuniform float uSliceSize;\nuniform float uSlicePixelSize;\nuniform float uSliceInnerSize;\n\nvoid main() {\n    vec4 color = texture(uTexture, vTextureCoord.xy);\n    vec4 adjusted;\n\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n        float innerWidth = uSize - 1.0;\n        float zSlice0 = min(floor(color.b * innerWidth), innerWidth);\n        float zSlice1 = min(zSlice0 + 1.0, innerWidth);\n        float xOffset = uSlicePixelSize * 0.5 + color.r * uSliceInnerSize;\n        float s0 = xOffset + (zSlice0 * uSliceSize);\n        float s1 = xOffset + (zSlice1 * uSliceSize);\n        float yOffset = uSliceSize * 0.5 + color.g * (1.0 - uSliceSize);\n        vec4 slice0Color = texture(uMapTexture, vec2(s0,yOffset));\n        vec4 slice1Color = texture(uMapTexture, vec2(s1,yOffset));\n        float zOffset = fract(color.b * innerWidth);\n        adjusted = mix(slice0Color, slice1Color, zOffset);\n\n        color.rgb *= color.a;\n    }\n\n    finalColor = vec4(mix(color, adjusted, uMix).rgb, color.a);\n\n}",name:"color-map-filter"}),resources:{colorMapUniforms:{uMix:{value:t.mix,type:"f32"},uSize:{value:0,type:"f32"},uSliceSize:{value:0,type:"f32"},uSlicePixelSize:{value:0,type:"f32"},uSliceInnerSize:{value:0,type:"f32"}},uMapTexture:t.colorMap.source,uMapSampler:t.colorMap.source.style}}),s(this,"uniforms"),s(this,"_size",0),s(this,"_sliceSize",0),s(this,"_slicePixelSize",0),s(this,"_sliceInnerSize",0),s(this,"_nearest",!1),s(this,"_scaleMode","linear"),s(this,"_colorMap"),this.uniforms=this.resources.colorMapUniforms.uniforms,Object.assign(this,t)}get mix(){return this.uniforms.uMix}set mix(e){this.uniforms.uMix=e}get colorSize(){return this._size}get colorMap(){return this._colorMap}set colorMap(e){if(!e||e===this.colorMap)return;const n=e instanceof r.gPd?e.source:e;n.style.scaleMode=this._scaleMode,n.autoGenerateMipmaps=!1,this._size=n.height,this._sliceSize=1/this._size,this._slicePixelSize=this._sliceSize/this._size,this._sliceInnerSize=this._slicePixelSize*(this._size-1),this.uniforms.uSize=this._size,this.uniforms.uSliceSize=this._sliceSize,this.uniforms.uSlicePixelSize=this._slicePixelSize,this.uniforms.uSliceInnerSize=this._sliceInnerSize,this.resources.uMapTexture=n,this._colorMap=e}get nearest(){return this._nearest}set nearest(e){this._nearest=e,this._scaleMode=e?"nearest":"linear";const n=this._colorMap;n&&n.source&&(n.source.scaleMode=this._scaleMode,n.source.autoGenerateMipmaps=!1,n.source.style.update(),n.source.update())}updateColorMap(){const e=this._colorMap;e?.source&&(e.source.update(),this.colorMap=e)}destroy(){this._colorMap?.destroy(),super.destroy()}};s(l,"DEFAULT_OPTIONS",{colorMap:r.gPd.WHITE,nearest:!1,mix:1})},4362:(e,n,t)=>{"use strict";var r=t(3423),o=t(4742),i=t(9096),u=Object.defineProperty,s=(e,n,t)=>(((e,n,t)=>{n in e?u(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t})(e,"symbol"!=typeof n?n+"":n,t),t);const l=class e extends r.dJT{constructor(...n){let t=n[0]??{};("number"==typeof t||Array.isArray(t)||t instanceof Float32Array)&&((0,r.t66)("6.0.0","ColorOverlayFilter constructor params are now options object. See params: { color, alpha }"),t={color:t},void 0!==n[1]&&(t.alpha=n[1])),t={...e.DEFAULT_OPTIONS,...t};super({gpuProgram:r.BrD.from({vertex:{source:i.A,entryPoint:"mainVertex"},fragment:{source:"struct ColorOverlayUniforms {\n    uColor: vec3<f32>,\n    uAlpha: f32,\n};\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> colorOverlayUniforms : ColorOverlayUniforms;\n\n@fragment\nfn mainFragment(\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n    let c = textureSample(uTexture, uSampler, uv);\n    return vec4<f32>(mix(c.rgb, colorOverlayUniforms.uColor.rgb, c.a * colorOverlayUniforms.uAlpha), c.a);\n}\n",entryPoint:"mainFragment"}}),glProgram:r.M2g.from({vertex:o.A,fragment:"in vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform vec3 uColor;\nuniform float uAlpha;\n\nvoid main(void) {\n    vec4 c = texture(uTexture, vTextureCoord);\n    finalColor = vec4(mix(c.rgb, uColor.rgb, c.a * uAlpha), c.a);\n}\n",name:"color-overlay-filter"}),resources:{colorOverlayUniforms:{uColor:{value:new Float32Array(3),type:"vec3<f32>"},uAlpha:{value:t.alpha,type:"f32"}}}}),s(this,"uniforms"),s(this,"_color"),this.uniforms=this.resources.colorOverlayUniforms.uniforms,this._color=new r.Q1f,this.color=t.color??0}get color(){return this._color.value}set color(e){this._color.setValue(e);const[n,t,r]=this._color.toArray();this.uniforms.uColor[0]=n,this.uniforms.uColor[1]=t,this.uniforms.uColor[2]=r}get alpha(){return this.uniforms.uAlpha}set alpha(e){this.uniforms.uAlpha=e}};s(l,"DEFAULT_OPTIONS",{color:0,alpha:1})},9577:(e,n,t)=>{"use strict";var r=t(3423),o=t(4742),i=t(9096),u=Object.defineProperty,s=(e,n,t)=>(((e,n,t)=>{n in e?u(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t})(e,"symbol"!=typeof n?n+"":n,t),t);const l=class e extends r.dJT{constructor(...n){let t=n[0]??{};("number"==typeof t||Array.isArray(t)||t instanceof Float32Array)&&((0,r.t66)("6.0.0","ColorReplaceFilter constructor params are now options object. See params: { originalColor, targetColor, tolerance }"),t={originalColor:t},void 0!==n[1]&&(t.targetColor=n[1]),void 0!==n[2]&&(t.tolerance=n[2])),t={...e.DEFAULT_OPTIONS,...t};super({gpuProgram:r.BrD.from({vertex:{source:i.A,entryPoint:"mainVertex"},fragment:{source:"struct ColorReplaceUniforms {\n  uOriginalColor: vec3<f32>,\n  uTargetColor: vec3<f32>,\n  uTolerance: f32,\n};\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> colorReplaceUniforms : ColorReplaceUniforms;\n\n@fragment\nfn mainFragment(\n   @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  let sample: vec4<f32> = textureSample(uTexture, uSampler, uv);\n\n  let colorDiff: vec3<f32> = colorReplaceUniforms.uOriginalColor - (sample.rgb / max(sample.a, 0.0000000001));\n  let colorDistance: f32 = length(colorDiff);\n  let doReplace: f32 = step(colorDistance, colorReplaceUniforms.uTolerance);\n\n  return vec4<f32>(mix(sample.rgb, (colorReplaceUniforms.uTargetColor + colorDiff) * sample.a, doReplace), sample.a);\n}",entryPoint:"mainFragment"}}),glProgram:r.M2g.from({vertex:o.A,fragment:"in vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform vec3 uOriginalColor;\nuniform vec3 uTargetColor;\nuniform float uTolerance;\n\nvoid main(void) {\n    vec4 c = texture(uTexture, vTextureCoord);\n    vec3 colorDiff = uOriginalColor - (c.rgb / max(c.a, 0.0000000001));\n    float colorDistance = length(colorDiff);\n    float doReplace = step(colorDistance, uTolerance);\n    finalColor = vec4(mix(c.rgb, (uTargetColor + colorDiff) * c.a, doReplace), c.a);\n}\n",name:"color-replace-filter"}),resources:{colorReplaceUniforms:{uOriginalColor:{value:new Float32Array(3),type:"vec3<f32>"},uTargetColor:{value:new Float32Array(3),type:"vec3<f32>"},uTolerance:{value:t.tolerance,type:"f32"}}}}),s(this,"uniforms"),s(this,"_originalColor"),s(this,"_targetColor"),this.uniforms=this.resources.colorReplaceUniforms.uniforms,this._originalColor=new r.Q1f,this._targetColor=new r.Q1f,this.originalColor=t.originalColor??16711680,this.targetColor=t.targetColor??0,Object.assign(this,t)}get originalColor(){return this._originalColor.value}set originalColor(e){this._originalColor.setValue(e);const[n,t,r]=this._originalColor.toArray();this.uniforms.uOriginalColor[0]=n,this.uniforms.uOriginalColor[1]=t,this.uniforms.uOriginalColor[2]=r}get targetColor(){return this._targetColor.value}set targetColor(e){this._targetColor.setValue(e);const[n,t,r]=this._targetColor.toArray();this.uniforms.uTargetColor[0]=n,this.uniforms.uTargetColor[1]=t,this.uniforms.uTargetColor[2]=r}get tolerance(){return this.uniforms.uTolerance}set tolerance(e){this.uniforms.uTolerance=e}set newColor(e){(0,r.t66)("6.0.0","ColorReplaceFilter.newColor is deprecated, please use ColorReplaceFilter.targetColor instead"),this.targetColor=e}get newColor(){return(0,r.t66)("6.0.0","ColorReplaceFilter.newColor is deprecated, please use ColorReplaceFilter.targetColor instead"),this.targetColor}set epsilon(e){(0,r.t66)("6.0.0","ColorReplaceFilter.epsilon is deprecated, please use ColorReplaceFilter.tolerance instead"),this.tolerance=e}get epsilon(){return(0,r.t66)("6.0.0","ColorReplaceFilter.epsilon is deprecated, please use ColorReplaceFilter.tolerance instead"),this.tolerance}};s(l,"DEFAULT_OPTIONS",{originalColor:16711680,targetColor:0,tolerance:.4})},858:(e,n,t)=>{"use strict";var r=t(3423),o=t(4742),i=t(9096),u=Object.defineProperty,s=(e,n,t)=>(((e,n,t)=>{n in e?u(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t})(e,"symbol"!=typeof n?n+"":n,t),t);const l=class e extends r.dJT{constructor(...n){let t=n[0]??{};Array.isArray(t)&&((0,r.t66)("6.0.0","ConvolutionFilter constructor params are now options object. See params: { matrix, width, height }"),t={matrix:t},void 0!==n[1]&&(t.width=n[1]),void 0!==n[2]&&(t.height=n[2])),t={...e.DEFAULT_OPTIONS,...t};const u=t.width??200,l=t.height??200;super({gpuProgram:r.BrD.from({vertex:{source:i.A,entryPoint:"mainVertex"},fragment:{source:"struct ConvolutionUniforms {\n    uMatrix: mat3x3<f32>,\n    uTexelSize: vec2<f32>,\n};\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> convolutionUniforms : ConvolutionUniforms;\n\n@fragment\nfn mainFragment(\n    @location(0) uv: vec2<f32>,\n    @builtin(position) position: vec4<f32>\n) -> @location(0) vec4<f32> {\n    let texelSize = convolutionUniforms.uTexelSize;\n    let matrix = convolutionUniforms.uMatrix;\n\n    let c11: vec4<f32> = textureSample(uTexture, uSampler, uv - texelSize); // top left\n    let c12: vec4<f32> = textureSample(uTexture, uSampler, vec2<f32>(uv.x, uv.y - texelSize.y)); // top center\n    let c13: vec4<f32> = textureSample(uTexture, uSampler, vec2<f32>(uv.x + texelSize.x, uv.y - texelSize.y)); // top right\n\n    let c21: vec4<f32> = textureSample(uTexture, uSampler, vec2<f32>(uv.x - texelSize.x, uv.y)); // mid left\n    let c22: vec4<f32> = textureSample(uTexture, uSampler, uv); // mid center\n    let c23: vec4<f32> = textureSample(uTexture, uSampler, vec2<f32>(uv.x + texelSize.x, uv.y)); // mid right\n\n    let c31: vec4<f32> = textureSample(uTexture, uSampler, vec2<f32>(uv.x - texelSize.x, uv.y + texelSize.y)); // bottom left\n    let c32: vec4<f32> = textureSample(uTexture, uSampler, vec2<f32>(uv.x, uv.y + texelSize.y)); // bottom center\n    let c33: vec4<f32> = textureSample(uTexture, uSampler, uv + texelSize); // bottom right\n\n    var finalColor: vec4<f32> = vec4<f32>(\n        c11 * matrix[0][0] + c12 * matrix[0][1] + c13 * matrix[0][2] +\n        c21 * matrix[1][0] + c22 * matrix[1][1] + c23 * matrix[1][2] +\n        c31 * matrix[2][0] + c32 * matrix[2][1] + c33 * matrix[2][2]\n    );\n\n    finalColor.a = c22.a;\n\n    return finalColor;\n}",entryPoint:"mainFragment"}}),glProgram:r.M2g.from({vertex:o.A,fragment:"in vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform vec2 uTexelSize;\nuniform mat3 uMatrix;\n\nvoid main(void)\n{\n    vec4 c11 = texture(uTexture, vTextureCoord - uTexelSize); // top left\n    vec4 c12 = texture(uTexture, vec2(vTextureCoord.x, vTextureCoord.y - uTexelSize.y)); // top center\n    vec4 c13 = texture(uTexture, vec2(vTextureCoord.x + uTexelSize.x, vTextureCoord.y - uTexelSize.y)); // top right\n\n    vec4 c21 = texture(uTexture, vec2(vTextureCoord.x - uTexelSize.x, vTextureCoord.y)); // mid left\n    vec4 c22 = texture(uTexture, vTextureCoord); // mid center\n    vec4 c23 = texture(uTexture, vec2(vTextureCoord.x + uTexelSize.x, vTextureCoord.y)); // mid right\n\n    vec4 c31 = texture(uTexture, vec2(vTextureCoord.x - uTexelSize.x, vTextureCoord.y + uTexelSize.y)); // bottom left\n    vec4 c32 = texture(uTexture, vec2(vTextureCoord.x, vTextureCoord.y + uTexelSize.y)); // bottom center\n    vec4 c33 = texture(uTexture, vTextureCoord + uTexelSize); // bottom right\n\n    finalColor =\n        c11 * uMatrix[0][0] + c12 * uMatrix[0][1] + c13 * uMatrix[0][2] +\n        c21 * uMatrix[1][0] + c22 * uMatrix[1][1] + c23 * uMatrix[1][2] +\n        c31 * uMatrix[2][0] + c32 * uMatrix[2][1] + c33 * uMatrix[2][2];\n\n    finalColor.a = c22.a;\n}",name:"convolution-filter"}),resources:{convolutionUniforms:{uMatrix:{value:t.matrix,type:"mat3x3<f32>"},uTexelSize:{value:{x:1/u,y:1/l},type:"vec2<f32>"}}}}),s(this,"uniforms"),this.uniforms=this.resources.convolutionUniforms.uniforms,this.width=u,this.height=l}get matrix(){return this.uniforms.uMatrix}set matrix(e){e.forEach(((e,n)=>{this.uniforms.uMatrix[n]=e}))}get width(){return 1/this.uniforms.uTexelSize.x}set width(e){this.uniforms.uTexelSize.x=1/e}get height(){return 1/this.uniforms.uTexelSize.y}set height(e){this.uniforms.uTexelSize.y=1/e}};s(l,"DEFAULT_OPTIONS",{matrix:new Float32Array(9),width:200,height:200})},406:(e,n,t)=>{"use strict";var r=t(3423);t(4742),t(9096);r.dJT},3740:(e,n,t)=>{"use strict";var r=t(3423),o=t(4742),i=t(9096),u=Object.defineProperty,s=(e,n,t)=>(((e,n,t)=>{n in e?u(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t})(e,"symbol"!=typeof n?n+"":n,t),t);const l=class e extends r.dJT{constructor(n){n={...e.DEFAULT_OPTIONS,...n};super({gpuProgram:r.BrD.from({vertex:{source:i.A,entryPoint:"mainVertex"},fragment:{source:"struct CRTUniforms {\n    uLine: vec4<f32>,\n    uNoise: vec2<f32>,\n    uVignette: vec3<f32>,\n    uSeed: f32,\n    uTime: f32,\n    uDimensions: vec2<f32>,\n};\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> crtUniforms : CRTUniforms;\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n    \n  var color: vec4<f32> = textureSample(uTexture, uSampler, uv);\n  let coord: vec2<f32> = uv * gfu.uInputSize.xy / crtUniforms.uDimensions;\n\n  let uNoise = crtUniforms.uNoise;\n\n  if (uNoise[0] > 0.0 && uNoise[1] > 0.0)\n  {\n    color += vec4<f32>(vec3<f32>(noise(uv)), color.a);\n  }\n\n  if (crtUniforms.uVignette[0] > 0.)\n  {\n    color *= vec4<f32>(vec3<f32>(vignette(color.rgb, coord)), color.a);\n  }\n\n  if (crtUniforms.uLine[1] > 0.0)\n  {\n    color = vec4<f32>(vec3<f32>(interlaceLines(color.rgb, uv)), color.a);  \n  }\n\n  return color;\n}\n\nconst SQRT_2: f32 = 1.414213;\n\nfn modulo(x: f32, y: f32) -> f32\n{\n  return x - y * floor(x/y);\n}\n\nfn rand(co: vec2<f32>) -> f32\n{\n  return fract(sin(dot(co, vec2<f32>(12.9898, 78.233))) * 43758.5453);\n}\n\nfn vignette(co: vec3<f32>, coord: vec2<f32>) -> f32\n{\n  let uVignette = crtUniforms.uVignette;\n  let uDimensions = crtUniforms.uDimensions;\n  \n  let outter: f32 = SQRT_2 - uVignette[0] * SQRT_2;\n  var dir: vec2<f32> = vec2<f32>(0.5) - coord;\n  dir.y *= uDimensions.y / uDimensions.x;\n  let darker: f32 = clamp((outter - length(dir) * SQRT_2) / ( 0.00001 + uVignette[2] * SQRT_2), 0.0, 1.0);\n  return darker + (1.0 - darker) * (1.0 - uVignette[1]);\n}\n\nfn noise(coord: vec2<f32>) -> f32\n{\n  let uNoise = crtUniforms.uNoise;\n  let uSeed = crtUniforms.uSeed;\n\n  var pixelCoord: vec2<f32> = coord * gfu.uInputSize.xy;\n  pixelCoord.x = floor(pixelCoord.x / uNoise[1]);\n  pixelCoord.y = floor(pixelCoord.y / uNoise[1]);\n  return (rand(pixelCoord * uNoise[1] * uSeed) - 0.5) * uNoise[0];\n}\n\nfn interlaceLines(co: vec3<f32>, coord: vec2<f32>) -> vec3<f32>\n{\n  var color = co;\n\n  let uDimensions = crtUniforms.uDimensions;\n\n  let curvature: f32 = crtUniforms.uLine[0];\n  let lineWidth: f32 = crtUniforms.uLine[1];\n  let lineContrast: f32 = crtUniforms.uLine[2];\n  let verticalLine: f32 = crtUniforms.uLine[3];\n\n  let dir: vec2<f32> = vec2<f32>(coord * gfu.uInputSize.xy / uDimensions - 0.5);\n\n  let _c: f32 = select(1., curvature, curvature > 0.);\n  let k: f32 = select(1., (length(dir * dir) * 0.25 * _c * _c + 0.935 * _c), curvature > 0.);\n  let uv: vec2<f32> = dir * k;\n  let v: f32 = select(uv.y * uDimensions.y, uv.x * uDimensions.x, verticalLine > 0.5) * min(1.0, 2.0 / lineWidth ) / _c;\n  let j: f32 = 1. + cos(v * 1.2 - crtUniforms.uTime) * 0.5 * lineContrast;\n  color *= j;\n\n  let segment: f32 = select(modulo((dir.y + .5) * uDimensions.y, 4.), modulo((dir.x + .5) * uDimensions.x, 4.), verticalLine > 0.5);\n  color *= 0.99 + ceil(segment) * 0.015;\n\n  return color;\n}",entryPoint:"mainFragment"}}),glProgram:r.M2g.from({vertex:o.A,fragment:"precision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform vec4 uLine;\nuniform vec2 uNoise;\nuniform vec3 uVignette;\nuniform float uSeed;\nuniform float uTime;\nuniform vec2 uDimensions;\n\nuniform vec4 uInputSize;\n\nconst float SQRT_2 = 1.414213;\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat vignette(vec3 co, vec2 coord)\n{\n    float outter = SQRT_2 - uVignette[0] * SQRT_2;\n    vec2 dir = vec2(0.5) - coord;\n    dir.y *= uDimensions.y / uDimensions.x;\n    float darker = clamp((outter - length(dir) * SQRT_2) / ( 0.00001 + uVignette[2] * SQRT_2), 0.0, 1.0);\n    return darker + (1.0 - darker) * (1.0 - uVignette[1]);\n}\n\nfloat noise(vec2 coord)\n{\n    vec2 pixelCoord = coord * uInputSize.xy;\n    pixelCoord.x = floor(pixelCoord.x / uNoise[1]);\n    pixelCoord.y = floor(pixelCoord.y / uNoise[1]);\n    return (rand(pixelCoord * uNoise[1] * uSeed) - 0.5) * uNoise[0];\n}\n\nvec3 interlaceLines(vec3 co, vec2 coord)\n{\n    vec3 color = co;\n\n    float curvature = uLine[0];\n    float lineWidth = uLine[1];\n    float lineContrast = uLine[2];\n    float verticalLine = uLine[3];\n\n    vec2 dir = vec2(coord * uInputSize.xy / uDimensions - 0.5);\n\n    float _c = curvature > 0. ? curvature : 1.;\n    float k = curvature > 0. ? (length(dir * dir) * 0.25 * _c * _c + 0.935 * _c) : 1.;\n    vec2 uv = dir * k;\n    float v = verticalLine > 0.5 ? uv.x * uDimensions.x : uv.y * uDimensions.y;\n    v *= min(1.0, 2.0 / lineWidth ) / _c;\n    float j = 1. + cos(v * 1.2 - uTime) * 0.5 * lineContrast;\n    color *= j;\n\n    float segment = verticalLine > 0.5 ? mod((dir.x + .5) * uDimensions.x, 4.) : mod((dir.y + .5) * uDimensions.y, 4.);\n    color *= 0.99 + ceil(segment) * 0.015;\n\n    return color;\n}\n\nvoid main(void)\n{\n    finalColor = texture(uTexture, vTextureCoord);\n    vec2 coord = vTextureCoord * uInputSize.xy / uDimensions;\n\n    if (uNoise[0] > 0.0 && uNoise[1] > 0.0)\n    {\n        float n = noise(vTextureCoord);\n        finalColor += vec4(n, n, n, finalColor.a);\n    }\n\n    if (uVignette[0] > 0.)\n    {\n        float v = vignette(finalColor.rgb, coord);\n        finalColor *= vec4(v, v, v, finalColor.a);\n    }\n\n    if (uLine[1] > 0.0)\n    {\n        finalColor = vec4(interlaceLines(finalColor.rgb, vTextureCoord), finalColor.a);  \n    }\n}\n",name:"crt-filter"}),resources:{crtUniforms:{uLine:{value:new Float32Array(4),type:"vec4<f32>"},uNoise:{value:new Float32Array(2),type:"vec2<f32>"},uVignette:{value:new Float32Array(3),type:"vec3<f32>"},uSeed:{value:n.seed,type:"f32"},uTime:{value:n.time,type:"f32"},uDimensions:{value:new Float32Array(2),type:"vec2<f32>"}}}}),s(this,"uniforms"),s(this,"seed"),s(this,"time"),this.uniforms=this.resources.crtUniforms.uniforms,Object.assign(this,n)}apply(e,n,t,r){this.uniforms.uDimensions[0]=n.frame.width,this.uniforms.uDimensions[1]=n.frame.height,this.uniforms.uSeed=this.seed,this.uniforms.uTime=this.time,e.applyFilter(this,n,t,r)}get curvature(){return this.uniforms.uLine[0]}set curvature(e){this.uniforms.uLine[0]=e}get lineWidth(){return this.uniforms.uLine[1]}set lineWidth(e){this.uniforms.uLine[1]=e}get lineContrast(){return this.uniforms.uLine[2]}set lineContrast(e){this.uniforms.uLine[2]=e}get verticalLine(){return this.uniforms.uLine[3]>.5}set verticalLine(e){this.uniforms.uLine[3]=e?1:0}get noise(){return this.uniforms.uNoise[0]}set noise(e){this.uniforms.uNoise[0]=e}get noiseSize(){return this.uniforms.uNoise[1]}set noiseSize(e){this.uniforms.uNoise[1]=e}get vignetting(){return this.uniforms.uVignette[0]}set vignetting(e){this.uniforms.uVignette[0]=e}get vignettingAlpha(){return this.uniforms.uVignette[1]}set vignettingAlpha(e){this.uniforms.uVignette[1]=e}get vignettingBlur(){return this.uniforms.uVignette[2]}set vignettingBlur(e){this.uniforms.uVignette[2]=e}};s(l,"DEFAULT_OPTIONS",{curvature:1,lineWidth:1,lineContrast:.25,verticalLine:!1,noise:0,noiseSize:1,vignetting:.3,vignettingAlpha:1,vignettingBlur:.3,time:0,seed:0})},9096:(e,n,t)=>{"use strict";t.d(n,{A:()=>r});var r="struct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>\n  };\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \n}\n\nfn getSize() -> vec2<f32>\n{\n  return gfu.uGlobalFrame.zw;\n}\n  \n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition)\n  );\n}"},4742:(e,n,t)=>{"use strict";t.d(n,{A:()=>r});var r="in vec2 aPosition;\nout vec2 vTextureCoord;\n\nuniform vec4 uInputSize;\nuniform vec4 uOutputFrame;\nuniform vec4 uOutputTexture;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\n    \n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n"},6900:(e,n,t)=>{"use strict";var r=t(3423),o=t(4742),i=t(9096),u=Object.defineProperty;const s=class e extends r.dJT{constructor(...n){let t=n[0]??{};"number"==typeof t&&((0,r.t66)("6.0.0","DotFilter constructor params are now options object. See params: { scale, angle, grayscale }"),t={scale:t},void 0!==n[1]&&(t.angle=n[1]),void 0!==n[2]&&(t.grayscale=n[2])),t={...e.DEFAULT_OPTIONS,...t};const u={uScale:{value:t.scale,type:"f32"},uAngle:{value:t.angle,type:"f32"},uGrayScale:{value:t.grayscale?1:0,type:"f32"}};super({gpuProgram:r.BrD.from({vertex:{source:i.A,entryPoint:"mainVertex"},fragment:{source:"struct DotUniforms {\n  uScale:f32,\n  uAngle:f32,\n  uGrayScale:f32,\n};\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> dotUniforms : DotUniforms;\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @builtin(position) position: vec4<f32>\n) -> @location(0) vec4<f32> {\n  let color: vec4<f32> = textureSample(uTexture, uSampler, uv);\n  let gray: vec3<f32> = vec3<f32>(dot(color.rgb, vec3<f32>(0.299, 0.587, 0.114)));\n  // dotUniforms.uGrayScale == 1 doesn't ever pass so it is converted to a float and compared to 0.5 instead \n  let finalColor: vec3<f32> = select(color.rgb, gray, f32(dotUniforms.uGrayScale) >= 0.5);\n\n  return vec4<f32>(finalColor * 10.0 - 5.0 + pattern(uv), color.a);\n}\n\nfn pattern(uv: vec2<f32>) -> f32\n{\n  let s: f32 = sin(dotUniforms.uAngle);\n  let c: f32 = cos(dotUniforms.uAngle);\n  \n  let tex: vec2<f32> = uv * gfu.uInputSize.xy;\n  \n  let p: vec2<f32> = vec2<f32>(\n      c * tex.x - s * tex.y,\n      s * tex.x + c * tex.y\n  ) * dotUniforms.uScale;\n\n  return (sin(p.x) * sin(p.y)) * 4.0;\n}",entryPoint:"mainFragment"}}),glProgram:r.M2g.from({vertex:o.A,fragment:"precision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform float uAngle;\nuniform float uScale;\nuniform bool uGrayScale;\n\nuniform vec4 uInputSize;\n\nfloat pattern()\n{\n    float s = sin(uAngle), c = cos(uAngle);\n    vec2 tex = vTextureCoord * uInputSize.xy;\n    vec2 point = vec2(\n        c * tex.x - s * tex.y,\n        s * tex.x + c * tex.y\n    ) * uScale;\n    return (sin(point.x) * sin(point.y)) * 4.0;\n    }\n\n    void main()\n    {\n    vec4 color = texture(uTexture, vTextureCoord);\n    vec3 colorRGB = vec3(color);\n\n    if (uGrayScale)\n    {\n        colorRGB = vec3(color.r + color.g + color.b) / 3.0;\n    }\n\n    finalColor = vec4(colorRGB * 10.0 - 5.0 + pattern(), color.a);\n}\n",name:"dot-filter"}),resources:{dotUniforms:u}})}get scale(){return this.resources.dotUniforms.uniforms.uScale}set scale(e){this.resources.dotUniforms.uniforms.uScale=e}get angle(){return this.resources.dotUniforms.uniforms.uAngle}set angle(e){this.resources.dotUniforms.uniforms.uAngle=e}get grayscale(){return 1===this.resources.dotUniforms.uniforms.uGrayScale}set grayscale(e){this.resources.dotUniforms.uniforms.uGrayScale=e?1:0}};var l;((e,n,t)=>{n in e?u(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t})(s,"symbol"!=typeof(l="DEFAULT_OPTIONS")?l+"":l,{scale:1,angle:5,grayscale:!0})},6635:(e,n,t)=>{"use strict";t.d(n,{G:()=>c});var r=t(3423),o=t(4742),i=t(9096),u=t(386),s=Object.defineProperty,l=(e,n,t)=>(((e,n,t)=>{n in e?s(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t})(e,"symbol"!=typeof n?n+"":n,t),t);const a=class e extends r.dJT{constructor(n){n={...e.DEFAULT_OPTIONS,...n};super({gpuProgram:r.BrD.from({vertex:{source:i.A,entryPoint:"mainVertex"},fragment:{source:"struct DropShadowUniforms {\n  uAlpha: f32,\n  uColor: vec3<f32>,\n  uOffset: vec2<f32>,\n};\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> dropShadowUniforms : DropShadowUniforms;\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  var color: vec4<f32> = textureSample(uTexture, uSampler, uv - dropShadowUniforms.uOffset * gfu.uInputSize.zw);\n\n  // Premultiply alpha\n  color = vec4<f32>(vec3<f32>(dropShadowUniforms.uColor.rgb * color.a), color.a);\n  // alpha user alpha\n  color *= dropShadowUniforms.uAlpha;\n\n  return color;\n}",entryPoint:"mainFragment"}}),glProgram:r.M2g.from({vertex:o.A,fragment:"precision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform float uAlpha;\nuniform vec3 uColor;\nuniform vec2 uOffset;\n\nuniform vec4 uInputSize;\n\nvoid main(void){\n    vec4 sample = texture(uTexture, vTextureCoord - uOffset * uInputSize.zw);\n\n    // Premultiply alpha\n    sample.rgb = uColor.rgb * sample.a;\n\n    // alpha user alpha\n    sample *= uAlpha;\n\n    finalColor = sample;\n}",name:"drop-shadow-filter"}),resources:{dropShadowUniforms:{uAlpha:{value:n.alpha,type:"f32"},uColor:{value:new Float32Array(3),type:"vec3<f32>"},uOffset:{value:n.offset,type:"vec2<f32>"}}},resolution:n.resolution}),l(this,"uniforms"),l(this,"shadowOnly",!1),l(this,"_color"),l(this,"_blurFilter"),l(this,"_basePass"),this.uniforms=this.resources.dropShadowUniforms.uniforms,this._color=new r.Q1f,this.color=n.color??0,this._blurFilter=new u.Q({strength:n.kernels??n.blur,quality:n.kernels?void 0:n.quality}),this._basePass=new r.dJT({gpuProgram:r.BrD.from({vertex:{source:i.A,entryPoint:"mainVertex"},fragment:{source:"\n                    @group(0) @binding(1) var uTexture: texture_2d<f32>; \n                    @group(0) @binding(2) var uSampler: sampler;\n                    @fragment\n                    fn mainFragment(\n                        @builtin(position) position: vec4<f32>,\n                        @location(0) uv : vec2<f32>\n                    ) -> @location(0) vec4<f32> {\n                        return textureSample(uTexture, uSampler, uv);\n                    }\n                    ",entryPoint:"mainFragment"}}),glProgram:r.M2g.from({vertex:o.A,fragment:"\n                in vec2 vTextureCoord;\n                out vec4 finalColor;\n                uniform sampler2D uTexture;\n\n                void main(void){\n                    finalColor = texture(uTexture, vTextureCoord);\n                }\n                ",name:"drop-shadow-filter"}),resources:{}}),Object.assign(this,n)}apply(e,n,t,o){const i=r.Wny.getSameSizeTexture(n);e.applyFilter(this,n,i,!0),this._blurFilter.apply(e,i,t,o),this.shadowOnly||e.applyFilter(this._basePass,n,t,!1),r.Wny.returnTexture(i)}get offset(){return this.uniforms.uOffset}set offset(e){this.uniforms.uOffset=e,this._updatePadding()}get offsetX(){return this.offset.x}set offsetX(e){this.offset.x=e,this._updatePadding()}get offsetY(){return this.offset.y}set offsetY(e){this.offset.y=e,this._updatePadding()}get color(){return this._color.value}set color(e){this._color.setValue(e);const[n,t,r]=this._color.toArray();this.uniforms.uColor[0]=n,this.uniforms.uColor[1]=t,this.uniforms.uColor[2]=r}get alpha(){return this.uniforms.uAlpha}set alpha(e){this.uniforms.uAlpha=e}get blur(){return this._blurFilter.strength}set blur(e){this._blurFilter.strength=e,this._updatePadding()}get quality(){return this._blurFilter.quality}set quality(e){this._blurFilter.quality=e,this._updatePadding()}get kernels(){return this._blurFilter.kernels}set kernels(e){this._blurFilter.kernels=e}get pixelSize(){return this._blurFilter.pixelSize}set pixelSize(e){"number"==typeof e&&(e={x:e,y:e}),Array.isArray(e)&&(e={x:e[0],y:e[1]}),this._blurFilter.pixelSize=e}get pixelSizeX(){return this._blurFilter.pixelSizeX}set pixelSizeX(e){this._blurFilter.pixelSizeX=e}get pixelSizeY(){return this._blurFilter.pixelSizeY}set pixelSizeY(e){this._blurFilter.pixelSizeY=e}_updatePadding(){const e=Math.max(Math.abs(this.offsetX),Math.abs(this.offsetY));this.padding=e+2*this.blur+4*this.quality}};l(a,"DEFAULT_OPTIONS",{offset:{x:4,y:4},color:0,alpha:.5,shadowOnly:!1,kernels:void 0,blur:2,quality:3,pixelSize:{x:1,y:1},resolution:1});let c=a},8909:(e,n,t)=>{"use strict";var r=t(3423);t(4742),t(9096),Object.defineProperty;r.dJT},942:(e,n,t)=>{"use strict";var r=t(3423),o=t(4742),i=t(9096),u=Object.defineProperty,s=(e,n,t)=>(((e,n,t)=>{n in e?u(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t})(e,"symbol"!=typeof n?n+"":n,t),t);const l=class e extends r.dJT{constructor(n){n={...e.defaults,...n};const t=r.BrD.from({vertex:{source:i.A,entryPoint:"mainVertex"},fragment:{source:"struct GlitchUniforms {\n  uSeed: f32,\n  uDimensions: vec2<f32>,\n  uAspect: f32,\n  uFillMode: f32,\n  uOffset: f32,\n  uDirection: f32,\n  uRed: vec2<f32>,\n  uGreen: vec2<f32>,\n  uBlue: vec2<f32>,\n};\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> glitchUniforms : GlitchUniforms;\n@group(1) @binding(1) var uDisplacementMap: texture_2d<f32>; \n@group(1) @binding(2) var uDisplacementSampler: sampler; \n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  let uSeed: f32 = glitchUniforms.uSeed;\n  let uDimensions: vec2<f32> = glitchUniforms.uDimensions;\n  let uAspect: f32 = glitchUniforms.uAspect;\n  let uOffset: f32 = glitchUniforms.uOffset;\n  let uDirection: f32 = glitchUniforms.uDirection;\n  let uRed: vec2<f32> = glitchUniforms.uRed;\n  let uGreen: vec2<f32> = glitchUniforms.uGreen;\n  let uBlue: vec2<f32> = glitchUniforms.uBlue;\n\n  let uInputSize: vec4<f32> = gfu.uInputSize;\n  let uInputClamp: vec4<f32> = gfu.uInputClamp;\n\n  var discarded: bool = false;\n  var coord: vec2<f32> = (uv * uInputSize.xy) / uDimensions;\n\n    if (coord.x > 1.0 || coord.y > 1.0) {\n      discarded = true;\n    }\n\n    let sinDir: f32 = sin(uDirection);\n    let cosDir: f32 = cos(uDirection);\n\n    let cx: f32 = coord.x - 0.5;\n    let cy: f32 = (coord.y - 0.5) * uAspect;\n    var ny: f32 = (-sinDir * cx + cosDir * cy) / uAspect + 0.5;\n\n    ny = select(select(ny, -ny, ny < 0.0), 2.0 - ny, ny > 1.0);\n\n    let dc: vec4<f32> = textureSample(uDisplacementMap, uDisplacementSampler, vec2<f32>(0.5, ny));\n\n    let displacement: f32 = (dc.r - dc.g) * (uOffset / uInputSize.x);\n\n    coord = uv + vec2<f32>(cosDir * displacement, sinDir * displacement * uAspect);\n\n    let fillMode: i32 = i32(glitchUniforms.uFillMode);\n\n    if (fillMode == CLAMP) {\n      coord = clamp(coord, uInputClamp.xy, uInputClamp.zw);\n    } else {\n      if (coord.x > uInputClamp.z) {\n        if (fillMode == TRANSPARENT) {\n          discarded = true;\n        } else if (fillMode == LOOP) {\n          coord.x = coord.x - uInputClamp.z;\n        } else if (fillMode == MIRROR) {\n          coord.x = uInputClamp.z * 2.0 - coord.x;\n        }\n      } else if (coord.x < uInputClamp.x) {\n        if (fillMode == TRANSPARENT) {\n          discarded = true;\n        } else if (fillMode == LOOP) {\n          coord.x = coord.x + uInputClamp.z;\n        } else if (fillMode == MIRROR) {\n          coord.x = coord.x * -uInputClamp.z;\n        }\n      }\n\n      if (coord.y > uInputClamp.w) {\n        if (fillMode == TRANSPARENT) {\n          discarded = true;\n        } else if (fillMode == LOOP) {\n          coord.y = coord.y - uInputClamp.w;\n        } else if (fillMode == MIRROR) {\n          coord.y = uInputClamp.w * 2.0 - coord.y;\n        }\n      } else if (coord.y < uInputClamp.y) {\n        if (fillMode == TRANSPARENT) {\n          discarded = true;\n        } else if (fillMode == LOOP) {\n          coord.y = coord.y + uInputClamp.w;\n        } else if (fillMode == MIRROR) {\n          coord.y = coord.y * -uInputClamp.w;\n        }\n      }\n    }\n\n    let seedR: f32 = 1.0 - uSeed * 0.4;\n    let seedG: f32 = 1.0 - uSeed * 0.3;\n    let seedB: f32 = 1.0 - uSeed * 0.2;\n\n    let offsetR: vec2<f32> = vec2(uRed.x * seedR / uInputSize.x, uRed.y * seedR / uInputSize.y);\n    let offsetG: vec2<f32> = vec2(uGreen.x * seedG / uInputSize.x, uGreen.y * seedG / uInputSize.y);\n    let offsetB: vec2<f32> = vec2(uBlue.x * seedB / uInputSize.x, uBlue.y * seedB / uInputSize.y);\n\n    let r = textureSample(uTexture, uSampler, coord + offsetR).r;\n    let g = textureSample(uTexture, uSampler, coord + offsetG).g;\n    let b = textureSample(uTexture, uSampler, coord + offsetB).b;\n    let a = textureSample(uTexture, uSampler, coord).a;\n\n    return select(vec4<f32>(r, g, b, a), vec4<f32>(0.0,0.0,0.0,0.0), discarded);\n}\n\nconst TRANSPARENT: i32 = 0;\nconst ORIGINAL: i32 = 1;\nconst LOOP: i32 = 2;\nconst CLAMP: i32 = 3;\nconst MIRROR: i32 = 4;",entryPoint:"mainFragment"}}),u=r.M2g.from({vertex:o.A,fragment:"precision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform sampler2D uDisplacementMap;\nuniform float uSeed;\nuniform vec2 uDimensions;\nuniform float uAspect;\nuniform float uFillMode;\nuniform float uOffset;\nuniform float uDirection;\nuniform vec2 uRed;\nuniform vec2 uGreen;\nuniform vec2 uBlue;\n\nuniform vec4 uInputSize;\nuniform vec4 uInputClamp;\n\nconst int TRANSPARENT = 0;\nconst int ORIGINAL = 1;\nconst int LOOP = 2;\nconst int CLAMP = 3;\nconst int MIRROR = 4;\n\nvoid main(void)\n{\n    vec2 coord = (vTextureCoord * uInputSize.xy) / uDimensions;\n\n    if (coord.x > 1.0 || coord.y > 1.0) {\n        return;\n    }\n\n    float sinDir = sin(uDirection);\n    float cosDir = cos(uDirection);\n\n    float cx = coord.x - 0.5;\n    float cy = (coord.y - 0.5) * uAspect;\n    float ny = (-sinDir * cx + cosDir * cy) / uAspect + 0.5;\n\n    // displacementMap: repeat\n    // ny = ny > 1.0 ? ny - 1.0 : (ny < 0.0 ? 1.0 + ny : ny);\n\n    // displacementMap: mirror\n    ny = ny > 1.0 ? 2.0 - ny : (ny < 0.0 ? -ny : ny);\n\n    vec4 dc = texture(uDisplacementMap, vec2(0.5, ny));\n\n    float displacement = (dc.r - dc.g) * (uOffset / uInputSize.x);\n\n    coord = vTextureCoord + vec2(cosDir * displacement, sinDir * displacement * uAspect);\n\n    int fillMode = int(uFillMode);\n\n    if (fillMode == CLAMP) {\n        coord = clamp(coord, uInputClamp.xy, uInputClamp.zw);\n    } else {\n        if( coord.x > uInputClamp.z ) {\n            if (fillMode == TRANSPARENT) {\n                discard;\n            } else if (fillMode == LOOP) {\n                coord.x -= uInputClamp.z;\n            } else if (fillMode == MIRROR) {\n                coord.x = uInputClamp.z * 2.0 - coord.x;\n            }\n        } else if( coord.x < uInputClamp.x ) {\n            if (fillMode == TRANSPARENT) {\n                discard;\n            } else if (fillMode == LOOP) {\n                coord.x += uInputClamp.z;\n            } else if (fillMode == MIRROR) {\n                coord.x *= -uInputClamp.z;\n            }\n        }\n\n        if( coord.y > uInputClamp.w ) {\n            if (fillMode == TRANSPARENT) {\n                discard;\n            } else if (fillMode == LOOP) {\n                coord.y -= uInputClamp.w;\n            } else if (fillMode == MIRROR) {\n                coord.y = uInputClamp.w * 2.0 - coord.y;\n            }\n        } else if( coord.y < uInputClamp.y ) {\n            if (fillMode == TRANSPARENT) {\n                discard;\n            } else if (fillMode == LOOP) {\n                coord.y += uInputClamp.w;\n            } else if (fillMode == MIRROR) {\n                coord.y *= -uInputClamp.w;\n            }\n        }\n    }\n\n    finalColor.r = texture(uTexture, coord + uRed * (1.0 - uSeed * 0.4) / uInputSize.xy).r;\n    finalColor.g = texture(uTexture, coord + uGreen * (1.0 - uSeed * 0.3) / uInputSize.xy).g;\n    finalColor.b = texture(uTexture, coord + uBlue * (1.0 - uSeed * 0.2) / uInputSize.xy).b;\n    finalColor.a = texture(uTexture, coord).a;\n}\n",name:"glitch-filter"}),l=document.createElement("canvas");l.width=4,l.height=n.sampleSize??512;const a=new r.gPd({source:new r.bEs({resource:l})});super({gpuProgram:t,glProgram:u,resources:{glitchUniforms:{uSeed:{value:n?.seed??0,type:"f32"},uDimensions:{value:new Float32Array(2),type:"vec2<f32>"},uAspect:{value:1,type:"f32"},uFillMode:{value:n?.fillMode??0,type:"f32"},uOffset:{value:n?.offset??100,type:"f32"},uDirection:{value:n?.direction??0,type:"f32"},uRed:{value:n.red,type:"vec2<f32>"},uGreen:{value:n.green,type:"vec2<f32>"},uBlue:{value:n.blue,type:"vec2<f32>"}},uDisplacementMap:a.source,uDisplacementSampler:a.source.style}}),s(this,"uniforms"),s(this,"average",!1),s(this,"minSize",8),s(this,"sampleSize",512),s(this,"_canvas"),s(this,"texture"),s(this,"_slices",0),s(this,"_sizes",new Float32Array(1)),s(this,"_offsets",new Float32Array(1)),this.uniforms=this.resources.glitchUniforms.uniforms,this._canvas=l,this.texture=a,Object.assign(this,n)}apply(e,n,t,r){const{width:o,height:i}=n.frame;this.uniforms.uDimensions[0]=o,this.uniforms.uDimensions[1]=i,this.uniforms.uAspect=i/o,e.applyFilter(this,n,t,r)}_randomizeSizes(){const e=this._sizes,n=this._slices-1,t=this.sampleSize,r=Math.min(this.minSize/t,.9/this._slices);if(this.average){const t=this._slices;let o=1;for(let i=0;i<n;i++){const n=o/(t-i),u=Math.max(n*(1-.6*Math.random()),r);e[i]=u,o-=u}e[n]=o}else{let t=1;const o=Math.sqrt(1/this._slices);for(let i=0;i<n;i++){const n=Math.max(o*t*Math.random(),r);e[i]=n,t-=n}e[n]=t}this.shuffle()}shuffle(){const e=this._sizes;for(let n=this._slices-1;n>0;n--){const t=Math.random()*n|0,r=e[n];e[n]=e[t],e[t]=r}}_randomizeOffsets(){for(let e=0;e<this._slices;e++)this._offsets[e]=Math.random()*(Math.random()<.5?-1:1)}refresh(){this._randomizeSizes(),this._randomizeOffsets(),this.redraw()}redraw(){const e=this.sampleSize,n=this.texture,t=this._canvas.getContext("2d");let r;t.clearRect(0,0,8,e);let o=0;for(let n=0;n<this._slices;n++){r=Math.floor(256*this._offsets[n]);const i=this._sizes[n]*e,u=r>0?r:0,s=r<0?-r:0;t.fillStyle=`rgba(${u}, ${s}, 0, 1)`,t.fillRect(0,o|0,e,i+1|0),o+=i}n.source.update()}set sizes(e){const n=Math.min(this._slices,e.length);for(let t=0;t<n;t++)this._sizes[t]=e[t]}get sizes(){return this._sizes}set offsets(e){const n=Math.min(this._slices,e.length);for(let t=0;t<n;t++)this._offsets[t]=e[t]}get offsets(){return this._offsets}get slices(){return this._slices}set slices(e){this._slices!==e&&(this._slices=e,this._sizes=new Float32Array(e),this._offsets=new Float32Array(e),this.refresh())}get offset(){return this.uniforms.uOffset}set offset(e){this.uniforms.uOffset=e}get seed(){return this.uniforms.uSeed}set seed(e){this.uniforms.uSeed=e}get fillMode(){return this.uniforms.uFillMode}set fillMode(e){this.uniforms.uFillMode=e}get direction(){return this.uniforms.uDirection/r.Tde}set direction(e){this.uniforms.uDirection=e*r.Tde}get red(){return this.uniforms.uRed}set red(e){Array.isArray(e)&&(e={x:e[0],y:e[1]}),this.uniforms.uRed=e}get green(){return this.uniforms.uGreen}set green(e){Array.isArray(e)&&(e={x:e[0],y:e[1]}),this.uniforms.uGreen=e}get blue(){return this.uniforms.uBlue}set blue(e){Array.isArray(e)&&(e={x:e[0],y:e[1]}),this.uniforms.uBlue=e}destroy(){this.texture?.destroy(!0),this.texture=this._canvas=this.red=this.green=this.blue=this._sizes=this._offsets=null}};s(l,"defaults",{slices:5,offset:100,direction:0,fillMode:0,average:!1,seed:0,red:{x:0,y:0},green:{x:0,y:0},blue:{x:0,y:0},minSize:8,sampleSize:512})},5487:(e,n,t)=>{"use strict";var r=t(3423),o=t(4742),i=t(9096),u=Object.defineProperty,s=(e,n,t)=>(((e,n,t)=>{n in e?u(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t})(e,"symbol"!=typeof n?n+"":n,t),t);const l=class e extends r.dJT{constructor(n){const t=(n={...e.DEFAULT_OPTIONS,...n}).distance??10,u=n.quality??.1;super({gpuProgram:r.BrD.from({vertex:{source:i.A,entryPoint:"mainVertex"},fragment:{source:"struct GlowUniforms {\n  uDistance: f32,\n  uStrength: vec2<f32>,\n  uColor: vec3<f32>,\n  uAlpha: f32,\n  uQuality: f32,\n  uKnockout: f32,\n};\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> glowUniforms : GlowUniforms;\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  let quality = glowUniforms.uQuality;\n  let distance = glowUniforms.uDistance;\n\n  let dist: f32 = glowUniforms.uDistance;\n  let angleStepSize: f32 = min(1. / quality / distance, PI * 2.0);\n  let angleStepNum: f32 = ceil(PI * 2.0 / angleStepSize);\n\n  let px: vec2<f32> = vec2<f32>(1.0 / gfu.uInputSize.xy);\n\n  var totalAlpha: f32 = 0.0;\n\n  var direction: vec2<f32>;\n  var displaced: vec2<f32>;\n  var curColor: vec4<f32>;\n\n  for (var angle = 0.0; angle < PI * 2.0; angle += angleStepSize) {\n    direction = vec2<f32>(cos(angle), sin(angle)) * px;\n    for (var curDistance = 0.0; curDistance < dist; curDistance+=1) {\n      displaced = vec2<f32>(clamp(uv + direction * (curDistance + 1.0), gfu.uInputClamp.xy, gfu.uInputClamp.zw));\n      curColor = textureSample(uTexture, uSampler, displaced);\n      totalAlpha += (dist - curDistance) * curColor.a;\n    }\n  }\n    \n  curColor = textureSample(uTexture, uSampler, uv);\n\n  let glowColorRGB = glowUniforms.uColor;\n  let glowAlpha = glowUniforms.uAlpha;\n  let glowColor = vec4<f32>(glowColorRGB, glowAlpha);\n  let knockout: bool = glowUniforms.uKnockout > 0.5;\n  let innerStrength = glowUniforms.uStrength[0];\n  let outerStrength = glowUniforms.uStrength[1];\n\n  let alphaRatio: f32 = (totalAlpha / (angleStepNum * dist * (dist + 1.0) / 2.0));\n  let innerGlowAlpha: f32 = (1.0 - alphaRatio) * innerStrength * curColor.a * glowAlpha;\n  let innerGlowStrength: f32 = min(1.0, innerGlowAlpha);\n  \n  let innerColor: vec4<f32> = mix(curColor, glowColor, innerGlowStrength);\n  let outerGlowAlpha: f32 = alphaRatio * outerStrength * (1. - curColor.a) * glowAlpha;\n  let outerGlowStrength: f32 = min(1.0 - innerColor.a, outerGlowAlpha);\n  let outerGlowColor: vec4<f32> = outerGlowStrength * glowColor.rgba;\n  \n  if (knockout) {\n    let resultAlpha: f32 = outerGlowAlpha + innerGlowAlpha;\n    return vec4<f32>(glowColor.rgb * resultAlpha, resultAlpha);\n  }\n  else {\n    return innerColor + outerGlowColor;\n  }\n}\n\nconst PI: f32 = 3.14159265358979323846264;",entryPoint:"mainFragment"}}),glProgram:r.M2g.from({vertex:o.A,fragment:"precision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform vec2 uStrength;\nuniform vec3 uColor;\nuniform float uKnockout;\nuniform float uAlpha;\n\nuniform vec4 uInputSize;\nuniform vec4 uInputClamp;\n\nconst float PI = 3.14159265358979323846264;\n\n// Hard-assignment of DIST and ANGLE_STEP_SIZE instead of using uDistance and uQuality to allow them to be use on GLSL loop conditions\nconst float DIST = __DIST__;\nconst float ANGLE_STEP_SIZE = min(__ANGLE_STEP_SIZE__, PI * 2.);\nconst float ANGLE_STEP_NUM = ceil(PI * 2. / ANGLE_STEP_SIZE);\nconst float MAX_TOTAL_ALPHA = ANGLE_STEP_NUM * DIST * (DIST + 1.) / 2.;\n\nvoid main(void) {\n    vec2 px = vec2(1.) / uInputSize.xy;\n\n    float totalAlpha = 0.;\n\n    vec2 direction;\n    vec2 displaced;\n    vec4 curColor;\n\n    for (float angle = 0.; angle < PI * 2.; angle += ANGLE_STEP_SIZE) {\n      direction = vec2(cos(angle), sin(angle)) * px;\n\n      for (float curDistance = 0.; curDistance < DIST; curDistance++) {\n          displaced = clamp(vTextureCoord + direction * (curDistance + 1.), uInputClamp.xy, uInputClamp.zw);\n          curColor = texture(uTexture, displaced);\n          totalAlpha += (DIST - curDistance) * curColor.a;\n      }\n    }\n    \n    curColor = texture(uTexture, vTextureCoord);\n\n    vec4 glowColor = vec4(uColor, uAlpha);\n    bool knockout = uKnockout > .5;\n    float innerStrength = uStrength[0];\n    float outerStrength = uStrength[1];\n\n    float alphaRatio = totalAlpha / MAX_TOTAL_ALPHA;\n    float innerGlowAlpha = (1. - alphaRatio) * innerStrength * curColor.a * uAlpha;\n    float innerGlowStrength = min(1., innerGlowAlpha);\n    \n    vec4 innerColor = mix(curColor, glowColor, innerGlowStrength);\n    float outerGlowAlpha = alphaRatio * outerStrength * (1. - curColor.a) * uAlpha;\n    float outerGlowStrength = min(1. - innerColor.a, outerGlowAlpha);\n    vec4 outerGlowColor = outerGlowStrength * glowColor.rgba;\n\n    if (knockout) {\n      float resultAlpha = outerGlowAlpha + innerGlowAlpha;\n      finalColor = vec4(glowColor.rgb * resultAlpha, resultAlpha);\n    }\n    else {\n      finalColor = innerColor + outerGlowColor;\n    }\n}\n".replace(/__ANGLE_STEP_SIZE__/gi,`${(1/u/t).toFixed(7)}`).replace(/__DIST__/gi,`${t.toFixed(0)}.0`),name:"glow-filter"}),resources:{glowUniforms:{uDistance:{value:t,type:"f32"},uStrength:{value:[n.innerStrength,n.outerStrength],type:"vec2<f32>"},uColor:{value:new Float32Array(3),type:"vec3<f32>"},uAlpha:{value:n.alpha,type:"f32"},uQuality:{value:u,type:"f32"},uKnockout:{value:n?.knockout?1:0,type:"f32"}}},padding:t}),s(this,"uniforms"),s(this,"_color"),this.uniforms=this.resources.glowUniforms.uniforms,this._color=new r.Q1f,this.color=n.color??16777215}get distance(){return this.uniforms.uDistance}set distance(e){this.uniforms.uDistance=this.padding=e}get innerStrength(){return this.uniforms.uStrength[0]}set innerStrength(e){this.uniforms.uStrength[0]=e}get outerStrength(){return this.uniforms.uStrength[1]}set outerStrength(e){this.uniforms.uStrength[1]=e}get color(){return this._color.value}set color(e){this._color.setValue(e);const[n,t,r]=this._color.toArray();this.uniforms.uColor[0]=n,this.uniforms.uColor[1]=t,this.uniforms.uColor[2]=r}get alpha(){return this.uniforms.uAlpha}set alpha(e){this.uniforms.uAlpha=e}get quality(){return this.uniforms.uQuality}set quality(e){this.uniforms.uQuality=e}get knockout(){return 1===this.uniforms.uKnockout}set knockout(e){this.uniforms.uKnockout=e?1:0}};s(l,"DEFAULT_OPTIONS",{distance:10,outerStrength:4,innerStrength:0,color:16777215,alpha:1,quality:.1,knockout:!1})},2637:(e,n,t)=>{"use strict";var r=t(3423),o=t(4742),i=t(9096),u=Object.defineProperty,s=(e,n,t)=>(((e,n,t)=>{n in e?u(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t})(e,"symbol"!=typeof n?n+"":n,t),t);const l=class e extends r.dJT{constructor(n){n={...e.DEFAULT_OPTIONS,...n};super({gpuProgram:r.BrD.from({vertex:{source:i.A,entryPoint:"mainVertex"},fragment:{source:"struct GodrayUniforms {\n  uLight: vec2<f32>,\n  uParallel: f32,\n  uAspect: f32,\n  uTime: f32,\n  uRay: vec3<f32>,\n  uDimensions: vec2<f32>,\n};\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> godrayUniforms : GodrayUniforms;\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  let uDimensions: vec2<f32> = godrayUniforms.uDimensions;\n  let uParallel: bool = godrayUniforms.uParallel > 0.5;\n  let uLight: vec2<f32> = godrayUniforms.uLight;\n  let uAspect: f32 = godrayUniforms.uAspect;\n\n  let coord: vec2<f32> = uv * gfu.uInputSize.xy / uDimensions;\n\n  var d: f32;\n\n  if (uParallel) {\n    let _cos: f32 = uLight.x;\n    let _sin: f32 = uLight.y;\n    d = (_cos * coord.x) + (_sin * coord.y * uAspect);\n  } else {\n    let dx: f32 = coord.x - uLight.x / uDimensions.x;\n    let dy: f32 = (coord.y - uLight.y / uDimensions.y) * uAspect;\n    let dis: f32 = sqrt(dx * dx + dy * dy) + 0.00001;\n    d = dy / dis;\n  }\n\n  let uTime: f32 = godrayUniforms.uTime;\n  let uRay: vec3<f32> = godrayUniforms.uRay;\n  \n  let gain = uRay[0];\n  let lacunarity = uRay[1];\n  let alpha = uRay[2];\n\n  let dir: vec3<f32> = vec3<f32>(d, d, 0.0);\n  var noise: f32 = turb(dir + vec3<f32>(uTime, 0.0, 62.1 + uTime) * 0.05, vec3<f32>(480.0, 320.0, 480.0), lacunarity, gain);\n  noise = mix(noise, 0.0, 0.3);\n  //fade vertically.\n  var mist: vec4<f32> = vec4<f32>(vec3<f32>(noise), 1.0) * (1.0 - coord.y);\n  mist.a = 1.0;\n  // apply user alpha\n  mist *= alpha;\n  return textureSample(uTexture, uSampler, uv) + mist;\n}\n\n${PERLIN}".replace("${PERLIN}","// Taken from https://gist.github.com/munrocket/236ed5ba7e409b8bdf1ff6eca5dcdc39\n\nfn moduloVec3(x: vec3<f32>, y: vec3<f32>) -> vec3<f32>\n{\n  return x - y * floor(x/y);\n}\nfn mod289Vec3(x: vec3<f32>) -> vec3<f32>\n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nfn mod289Vec4(x: vec4<f32>) -> vec4<f32>\n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nfn permute4(x: vec4<f32>) -> vec4<f32>\n{\n    return mod289Vec4(((x * 34.0) + 1.0) * x);\n}\nfn taylorInvSqrt(r: vec4<f32>) -> vec4<f32>\n{\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\nfn fade3(t: vec3<f32>) -> vec3<f32>\n{\n    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\nfn fade2(t: vec2<f32>) -> vec2<f32> { return t * t * t * (t * (t * 6. - 15.) + 10.); }\n\nfn perlinNoise2(P: vec2<f32>) -> f32 {\n  var Pi: vec4<f32> = floor(P.xyxy) + vec4<f32>(0., 0., 1., 1.);\n  let Pf = fract(P.xyxy) - vec4<f32>(0., 0., 1., 1.);\n  Pi = Pi % vec4<f32>(289.); // To avoid truncation effects in permutation\n  let ix = Pi.xzxz;\n  let iy = Pi.yyww;\n  let fx = Pf.xzxz;\n  let fy = Pf.yyww;\n  let i = permute4(permute4(ix) + iy);\n  var gx: vec4<f32> = 2. * fract(i * 0.0243902439) - 1.; // 1/41 = 0.024...\n  let gy = abs(gx) - 0.5;\n  let tx = floor(gx + 0.5);\n  gx = gx - tx;\n  var g00: vec2<f32> = vec2<f32>(gx.x, gy.x);\n  var g10: vec2<f32> = vec2<f32>(gx.y, gy.y);\n  var g01: vec2<f32> = vec2<f32>(gx.z, gy.z);\n  var g11: vec2<f32> = vec2<f32>(gx.w, gy.w);\n  let norm = 1.79284291400159 - 0.85373472095314 *\n      vec4<f32>(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));\n  g00 = g00 * norm.x;\n  g01 = g01 * norm.y;\n  g10 = g10 * norm.z;\n  g11 = g11 * norm.w;\n  let n00 = dot(g00, vec2<f32>(fx.x, fy.x));\n  let n10 = dot(g10, vec2<f32>(fx.y, fy.y));\n  let n01 = dot(g01, vec2<f32>(fx.z, fy.z));\n  let n11 = dot(g11, vec2<f32>(fx.w, fy.w));\n  let fade_xy = fade2(Pf.xy);\n  let n_x = mix(vec2<f32>(n00, n01), vec2<f32>(n10, n11), vec2<f32>(fade_xy.x));\n  let n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\n// Classic Perlin noise, periodic variant\nfn perlinNoise3(P: vec3<f32>, rep: vec3<f32>) -> f32\n{\n    var Pi0: vec3<f32> = moduloVec3(floor(P), rep); // Integer part, modulo period\n    var Pi1: vec3<f32> = moduloVec3(Pi0 + vec3<f32>(1.0), rep); // Integer part + 1, mod period\n    Pi0 = mod289Vec3(Pi0);\n    Pi1 = mod289Vec3(Pi1);\n    let Pf0: vec3<f32> = fract(P); // Fractional part for interpolation\n    let Pf1: vec3<f32> = Pf0 - vec3<f32>(1.0); // Fractional part - 1.0\n    let ix: vec4<f32> = vec4<f32>(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    let iy: vec4<f32> = vec4<f32>(Pi0.yy, Pi1.yy);\n    let iz0: vec4<f32> = Pi0.zzzz;\n    let iz1: vec4<f32> = Pi1.zzzz;\n    let ixy: vec4<f32> = permute4(permute4(ix) + iy);\n    let ixy0: vec4<f32> = permute4(ixy + iz0);\n    let ixy1: vec4<f32> = permute4(ixy + iz1);\n    var gx0: vec4<f32> = ixy0 * (1.0 / 7.0);\n    var gy0: vec4<f32> = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n    gx0 = fract(gx0);\n    let gz0: vec4<f32> = vec4<f32>(0.5) - abs(gx0) - abs(gy0);\n    let sz0: vec4<f32> = step(gz0, vec4<f32>(0.0));\n    gx0 -= sz0 * (step(vec4<f32>(0.0), gx0) - 0.5);\n    gy0 -= sz0 * (step(vec4<f32>(0.0), gy0) - 0.5);\n    var gx1: vec4<f32> = ixy1 * (1.0 / 7.0);\n    var gy1: vec4<f32> = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n    gx1 = fract(gx1);\n    let gz1: vec4<f32> = vec4<f32>(0.5) - abs(gx1) - abs(gy1);\n    let sz1: vec4<f32> = step(gz1, vec4<f32>(0.0));\n    gx1 -= sz1 * (step(vec4<f32>(0.0), gx1) - 0.5);\n    gy1 -= sz1 * (step(vec4<f32>(0.0), gy1) - 0.5);\n    var g000: vec3<f32> = vec3<f32>(gx0.x, gy0.x, gz0.x);\n    var g100: vec3<f32> = vec3<f32>(gx0.y, gy0.y, gz0.y);\n    var g010: vec3<f32> = vec3<f32>(gx0.z, gy0.z, gz0.z);\n    var g110: vec3<f32> = vec3<f32>(gx0.w, gy0.w, gz0.w);\n    var g001: vec3<f32> = vec3<f32>(gx1.x, gy1.x, gz1.x);\n    var g101: vec3<f32> = vec3<f32>(gx1.y, gy1.y, gz1.y);\n    var g011: vec3<f32> = vec3<f32>(gx1.z, gy1.z, gz1.z);\n    var g111: vec3<f32> = vec3<f32>(gx1.w, gy1.w, gz1.w);\n    let norm0: vec4<f32> = taylorInvSqrt(vec4<f32>(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n    g000 *= norm0.x;\n    g010 *= norm0.y;\n    g100 *= norm0.z;\n    g110 *= norm0.w;\n    let norm1: vec4<f32> = taylorInvSqrt(vec4<f32>(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n    g001 *= norm1.x;\n    g011 *= norm1.y;\n    g101 *= norm1.z;\n    g111 *= norm1.w;\n    let n000: f32 = dot(g000, Pf0);\n    let n100: f32 = dot(g100, vec3<f32>(Pf1.x, Pf0.yz));\n    let n010: f32 = dot(g010, vec3<f32>(Pf0.x, Pf1.y, Pf0.z));\n    let n110: f32 = dot(g110, vec3<f32>(Pf1.xy, Pf0.z));\n    let n001: f32 = dot(g001, vec3<f32>(Pf0.xy, Pf1.z));\n    let n101: f32 = dot(g101, vec3<f32>(Pf1.x, Pf0.y, Pf1.z));\n    let n011: f32 = dot(g011, vec3<f32>(Pf0.x, Pf1.yz));\n    let n111: f32 = dot(g111, Pf1);\n    let fade_xyz: vec3<f32> = fade3(Pf0);\n    let n_z: vec4<f32> = mix(vec4<f32>(n000, n100, n010, n110), vec4<f32>(n001, n101, n011, n111), fade_xyz.z);\n    let n_yz: vec2<f32> = mix(n_z.xy, n_z.zw, fade_xyz.y);\n    let n_xyz: f32 = mix(n_yz.x, n_yz.y, fade_xyz.x);\n    return 2.2 * n_xyz;\n}\nfn turb(P: vec3<f32>, rep: vec3<f32>, lacunarity: f32, gain: f32) -> f32\n{\n    var sum: f32 = 0.0;\n    var sc: f32 = 1.0;\n    var totalgain: f32 = 1.0;\n    for (var i = 0.0; i < 6.0; i += 1)\n    {\n        sum += totalgain * perlinNoise3(P * sc, rep);\n        sc *= lacunarity;\n        totalgain *= gain;\n    }\n    return abs(sum);\n}"),entryPoint:"mainFragment"}}),glProgram:r.M2g.from({vertex:o.A,fragment:"precision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform vec2 uDimensions;\nuniform float uParallel;\nuniform vec2 uLight;\nuniform float uAspect;\nuniform float uTime;\nuniform vec3 uRay;\n\nuniform vec4 uInputSize;\n\n${PERLIN}\n\nvoid main(void) {\n    vec2 uDimensions = uDimensions;\n    bool uParallel = uParallel > 0.5;\n    vec2 uLight = uLight;\n    float uAspect = uAspect;\n\n    vec2 coord = vTextureCoord * uInputSize.xy / uDimensions;\n\n    float d;\n\n    if (uParallel) {\n        float _cos = uLight.x;\n        float _sin = uLight.y;\n        d = (_cos * coord.x) + (_sin * coord.y * uAspect);\n    } else {\n        float dx = coord.x - uLight.x / uDimensions.x;\n        float dy = (coord.y - uLight.y / uDimensions.y) * uAspect;\n        float dis = sqrt(dx * dx + dy * dy) + 0.00001;\n        d = dy / dis;\n    }\n\n    float uTime = uTime;\n    vec3 uRay = uRay;\n\n    float gain = uRay[0];\n    float lacunarity = uRay[1];\n    float alpha = uRay[2];\n\n    vec3 dir = vec3(d, d, 0.0);\n    float noise = turb(dir + vec3(uTime, 0.0, 62.1 + uTime) * 0.05, vec3(480.0, 320.0, 480.0), lacunarity, gain);\n    noise = mix(noise, 0.0, 0.3);\n    //fade vertically.\n    vec4 mist = vec4(vec3(noise), 1.0) * (1.0 - coord.y);\n    mist.a = 1.0;\n    // apply user alpha\n    mist *= alpha;\n\n    finalColor = texture(uTexture, vTextureCoord) + mist;\n}\n".replace("${PERLIN}","vec3 mod289(vec3 x)\n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 mod289(vec4 x)\n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 permute(vec4 x)\n{\n    return mod289(((x * 34.0) + 1.0) * x);\n}\nvec4 taylorInvSqrt(vec4 r)\n{\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\nvec3 fade(vec3 t)\n{\n    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n// Classic Perlin noise, periodic variant\nfloat pnoise(vec3 P, vec3 rep)\n{\n    vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period\n    vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period\n    Pi0 = mod289(Pi0);\n    Pi1 = mod289(Pi1);\n    vec3 Pf0 = fract(P); // Fractional part for interpolation\n    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = Pi0.zzzz;\n    vec4 iz1 = Pi1.zzzz;\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n    vec4 gx0 = ixy0 * (1.0 / 7.0);\n    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n    gx0 = fract(gx0);\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n    vec4 sz0 = step(gz0, vec4(0.0));\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n    gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n    vec4 gx1 = ixy1 * (1.0 / 7.0);\n    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n    gx1 = fract(gx1);\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n    vec4 sz1 = step(gz1, vec4(0.0));\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n    gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n    vec3 g000 = vec3(gx0.x, gy0.x, gz0.x);\n    vec3 g100 = vec3(gx0.y, gy0.y, gz0.y);\n    vec3 g010 = vec3(gx0.z, gy0.z, gz0.z);\n    vec3 g110 = vec3(gx0.w, gy0.w, gz0.w);\n    vec3 g001 = vec3(gx1.x, gy1.x, gz1.x);\n    vec3 g101 = vec3(gx1.y, gy1.y, gz1.y);\n    vec3 g011 = vec3(gx1.z, gy1.z, gz1.z);\n    vec3 g111 = vec3(gx1.w, gy1.w, gz1.w);\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n    g000 *= norm0.x;\n    g010 *= norm0.y;\n    g100 *= norm0.z;\n    g110 *= norm0.w;\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n    g001 *= norm1.x;\n    g011 *= norm1.y;\n    g101 *= norm1.z;\n    g111 *= norm1.w;\n    float n000 = dot(g000, Pf0);\n    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n    float n111 = dot(g111, Pf1);\n    vec3 fade_xyz = fade(Pf0);\n    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n    return 2.2 * n_xyz;\n}\nfloat turb(vec3 P, vec3 rep, float lacunarity, float gain)\n{\n    float sum = 0.0;\n    float sc = 1.0;\n    float totalgain = 1.0;\n    for (float i = 0.0; i < 6.0; i++)\n    {\n        sum += totalgain * pnoise(P * sc, rep);\n        sc *= lacunarity;\n        totalgain *= gain;\n    }\n    return abs(sum);\n}\n"),name:"god-ray-filter"}),resources:{godrayUniforms:{uLight:{value:new Float32Array(2),type:"vec2<f32>"},uParallel:{value:0,type:"f32"},uAspect:{value:0,type:"f32"},uTime:{value:n.time,type:"f32"},uRay:{value:new Float32Array(3),type:"vec3<f32>"},uDimensions:{value:new Float32Array(2),type:"vec2<f32>"}}}}),s(this,"uniforms"),s(this,"time",0),s(this,"_angleLight",[0,0]),s(this,"_angle",0),s(this,"_center"),this.uniforms=this.resources.godrayUniforms.uniforms,Object.assign(this,n)}apply(e,n,t,r){const o=n.frame.width,i=n.frame.height;this.uniforms.uLight[0]=this.parallel?this._angleLight[0]:this._center.x,this.uniforms.uLight[1]=this.parallel?this._angleLight[1]:this._center.y,this.uniforms.uDimensions[0]=o,this.uniforms.uDimensions[1]=i,this.uniforms.uAspect=i/o,this.uniforms.uTime=this.time,e.applyFilter(this,n,t,r)}get angle(){return this._angle}set angle(e){this._angle=e;const n=e*r.Tde;this._angleLight[0]=Math.cos(n),this._angleLight[1]=Math.sin(n)}get parallel(){return this.uniforms.uParallel>.5}set parallel(e){this.uniforms.uParallel=e?1:0}get center(){return this._center}set center(e){Array.isArray(e)&&(e={x:e[0],y:e[1]}),this._center=e}get centerX(){return this.center.x}set centerX(e){this.center.x=e}get centerY(){return this.center.y}set centerY(e){this.center.y=e}get gain(){return this.uniforms.uRay[0]}set gain(e){this.uniforms.uRay[0]=e}get lacunarity(){return this.uniforms.uRay[1]}set lacunarity(e){this.uniforms.uRay[1]=e}get alpha(){return this.uniforms.uRay[2]}set alpha(e){this.uniforms.uRay[2]=e}};s(l,"DEFAULT_OPTIONS",{angle:30,gain:.5,lacunarity:2.5,parallel:!0,time:0,center:{x:0,y:0},alpha:1})},8230:(e,n,t)=>{"use strict";var r=t(3423);t(4742),t(9096);r.dJT},7218:(e,n,t)=>{"use strict";var r=t(3423),o=t(4742),i=t(9096),u=Object.defineProperty,s=(e,n,t)=>(((e,n,t)=>{n in e?u(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t})(e,"symbol"!=typeof n?n+"":n,t),t);const l=class e extends r.dJT{constructor(n){n={...e.DEFAULT_OPTIONS,...n};super({gpuProgram:r.BrD.from({vertex:{source:i.A,entryPoint:"mainVertex"},fragment:{source:"struct HslUniforms {\n  uHsl:vec3<f32>,\n  uColorize:f32,\n  uAlpha:f32,\n};\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> hslUniforms : HslUniforms;\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @builtin(position) position: vec4<f32>\n) -> @location(0) vec4<f32> {\n    let color: vec4<f32> = textureSample(uTexture, uSampler, uv);\n    var resultRGB: vec3<f32> = color.rgb;\n\n    let hue: f32 = hslUniforms.uHsl[0];\n    let saturation: f32 = hslUniforms.uHsl[1];\n    let lightness: f32 = hslUniforms.uHsl[2];\n\n    // colorize\n    if (hslUniforms.uColorize > 0.5) {\n        resultRGB = vec3<f32>(dot(color.rgb, vec3<f32>(0.299, 0.587, 0.114)), 0., 0.);\n    }\n\n    // hue\n    resultRGB = hueShift(resultRGB, hue);\n\n    // saturation\n    // https://github.com/evanw/glfx.js/blob/master/src/filters/adjust/huesaturation.js\n    let average: f32 = (resultRGB.r + resultRGB.g + resultRGB.b) / 3.0;\n\n    if (saturation > 0.) {\n        resultRGB += (average - resultRGB) * (1. - 1. / (1.001 - saturation));\n    } else {\n        resultRGB -= (average - resultRGB) * saturation;\n    }\n\n    // lightness\n    resultRGB = mix(resultRGB, vec3<f32>(ceil(lightness)) * color.a, abs(lightness));\n\n    // alpha\n    return mix(color, vec4<f32>(resultRGB, color.a), hslUniforms.uAlpha);\n}\n\n// https://gist.github.com/mairod/a75e7b44f68110e1576d77419d608786?permalink_comment_id=3195243#gistcomment-3195243\nconst k: vec3<f32> = vec3(0.57735, 0.57735, 0.57735);\n\nfn hueShift(color: vec3<f32>, angle: f32) -> vec3<f32> \n{\n    let cosAngle: f32 = cos(angle);\n    return vec3<f32>(\n    color * cosAngle +\n    cross(k, color) * sin(angle) +\n    k * dot(k, color) * (1.0 - cosAngle)\n    );\n}",entryPoint:"mainFragment"}}),glProgram:r.M2g.from({vertex:o.A,fragment:"in vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform vec3 uHsl;\nuniform float uAlpha;\nuniform float uColorize;\n\n// https://en.wikipedia.org/wiki/Luma_(video)\nconst vec3 weight = vec3(0.299, 0.587, 0.114);\n\nfloat getWeightedAverage(vec3 rgb) {\n    return rgb.r * weight.r + rgb.g * weight.g + rgb.b * weight.b;\n}\n\n// https://gist.github.com/mairod/a75e7b44f68110e1576d77419d608786?permalink_comment_id=3195243#gistcomment-3195243\nconst vec3 k = vec3(0.57735, 0.57735, 0.57735);\n\nvec3 hueShift(vec3 color, float angle) {\n    float cosAngle = cos(angle);\n    return vec3(\n    color * cosAngle +\n    cross(k, color) * sin(angle) +\n    k * dot(k, color) * (1.0 - cosAngle)\n    );\n}\n\nvoid main()\n{\n    vec4 color = texture(uTexture, vTextureCoord);\n    vec3 resultRGB = color.rgb;\n\n    float hue = uHsl[0];\n    float saturation = uHsl[1];\n    float lightness = uHsl[2];\n\n    // colorize\n    if (uColorize > 0.5) {\n        resultRGB = vec3(getWeightedAverage(resultRGB), 0., 0.);\n    }\n\n    // hue\n    resultRGB = hueShift(resultRGB, hue);\n\n    // saturation\n    // https://github.com/evanw/glfx.js/blob/master/src/filters/adjust/huesaturation.js\n    float average = (resultRGB.r + resultRGB.g + resultRGB.b) / 3.0;\n\n    if (saturation > 0.) {\n        resultRGB += (average - resultRGB) * (1. - 1. / (1.001 - saturation));\n    } else {\n        resultRGB -= (average - resultRGB) * saturation;\n    }\n\n    // lightness\n    resultRGB = mix(resultRGB, vec3(ceil(lightness)) * color.a, abs(lightness));\n\n    // alpha\n    finalColor = mix(color, vec4(resultRGB, color.a), uAlpha);\n}\n",name:"hsl-adjustment-filter"}),resources:{hslUniforms:{uHsl:{value:new Float32Array(3),type:"vec3<f32>"},uColorize:{value:n.colorize?1:0,type:"f32"},uAlpha:{value:n.alpha,type:"f32"}}}}),s(this,"uniforms"),s(this,"_hue"),this.uniforms=this.resources.hslUniforms.uniforms,Object.assign(this,n)}get hue(){return this._hue}set hue(e){this._hue=e,this.uniforms.uHsl[0]=e*(Math.PI/180)}get saturation(){return this.uniforms.uHsl[1]}set saturation(e){this.uniforms.uHsl[1]=e}get lightness(){return this.uniforms.uHsl[2]}set lightness(e){this.uniforms.uHsl[2]=e}get colorize(){return 1===this.uniforms.uColorize}set colorize(e){this.uniforms.uColorize=e?1:0}get alpha(){return this.uniforms.uAlpha}set alpha(e){this.uniforms.uAlpha=e}};s(l,"DEFAULT_OPTIONS",{hue:0,saturation:0,lightness:0,colorize:!1,alpha:1})}}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9yLi5wbnBtLTcyZTFmNDA4LmUwOWJiMWJkNWYyODhiZWU5NjBjLmpzIiwibWFwcGluZ3MiOiIwSEFBQSxJQUFJQSxFQUFjLFVBQ2RDLEVBQVksUUFDWkMsRUFBYyxRQUNkQyxFQUFpQiw4QkFDakJDLEVBQWUsMkJBQ2ZDLEVBQWdCLFdBQ2hCQyxFQUFjLHFDQUNkQyxFQUFlLFFBQ2ZDLEVBQWUsaUJBQ2ZDLEVBQWdCLHdCQUNoQkMsRUFBa0IsY0FDbEJDLEVBQW9CLFFBQ3BCQyxFQUFhLGNBQ2JDLEVBQWMsZ0NBQ2RDLEVBQWUseUJBQ2ZDLEVBQXVCLFNBQVVDLEdBQ2pDLFlBQTZCLElBQWRBLEdBQ1ksYUFBdkJBLEVBQVVDLFVBQzBCLGlCQUE3QkQsRUFBVUUsZ0JBQ2pCRixFQUFVRSxlQUFpQixHQUNQLG9CQUFiQyxRQUNmLEVBSWUsU0FBU0MsRUFBU0MsR0FDN0IsSUFBSUMsRUFBTSxDQUNOQyxVQUFXLEdBQ1hOLFNBQVUsR0FDVkMsZUFBZ0IsR0FFZkcsR0FBOEIsb0JBQWRMLFVBT0ssaUJBQVZLLEVBQ1pDLEVBQUlDLFVBQVlGLEVBRVhBLEdBQVNBLEVBQU1FLFlBQ3BCRCxFQUFNLENBQ0ZDLFVBQVdGLEVBQU1FLFVBQ2pCTixTQUFVSSxFQUFNSixTQUNoQkMsZUFBZ0JHLEVBQU1ILGdCQUFrQixJQWI1Q0ksRUFBTSxDQUNGQyxVQUFXUCxVQUFVTyxVQUNyQk4sU0FBVUQsVUFBVUMsU0FDcEJDLGVBQWdCRixVQUFVRSxnQkFBa0IsR0FhcEQsSUFBSUssRUFBWUQsRUFBSUMsVUFDaEJDLEVBQU1ELEVBQVVFLE1BQU0sY0FDSixJQUFYRCxFQUFJLEtBQ1hELEVBQVlDLEVBQUksU0FHRSxLQUR0QkEsRUFBTUQsRUFBVUUsTUFBTSxZQUNQLEtBQ1hGLEVBQVlDLEVBQUksSUFFcEIsSUFBSUUsRUFuQ1IsU0FBcUJILEdBQ2pCLE9BQU8sU0FBVUksR0FBUyxPQUFPQSxFQUFNQyxLQUFLTCxFQUFZLENBQzVELENBaUNnQk0sQ0FBWU4sR0FDcEJPLEVBQVMs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TyxHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGl4aWpzLWdhbWUvLi9ub2RlX21vZHVsZXMvLnBucG0vaXNtb2JpbGVqc0AxLjEuMS9ub2RlX21vZHVsZXMvaXNtb2JpbGVqcy9lc20vaXNNb2JpbGUuanMiLCJ3ZWJwYWNrOi8vcGl4aWpzLWdhbWUvLi9ub2RlX21vZHVsZXMvLnBucG0vcGFyc2Utc3ZnLXBhdGhAMC4xLjIvbm9kZV9tb2R1bGVzL3BhcnNlLXN2Zy1wYXRoL2luZGV4LmpzIiwid2VicGFjazovL3BpeGlqcy1nYW1lLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3BpeGktZmlsdGVyc0A2LjAuNV9waXhpLmpzQDguNi40L25vZGVfbW9kdWxlcy9waXhpLWZpbHRlcnMvbGliL2FkanVzdG1lbnQvQWRqdXN0bWVudEZpbHRlci5tanMiLCJ3ZWJwYWNrOi8vcGl4aWpzLWdhbWUvLi9ub2RlX21vZHVsZXMvLnBucG0vcGl4aS1maWx0ZXJzQDYuMC41X3BpeGkuanNAOC42LjQvbm9kZV9tb2R1bGVzL3BpeGktZmlsdGVycy9saWIvYWRqdXN0bWVudC9hZGp1c3RtZW50Lm1qcyIsIndlYnBhY2s6Ly9waXhpanMtZ2FtZS8uL25vZGVfbW9kdWxlcy8ucG5wbS9waXhpLWZpbHRlcnNANi4wLjVfcGl4aS5qc0A4LjYuNC9ub2RlX21vZHVsZXMvcGl4aS1maWx0ZXJzL2xpYi9hZGp1c3RtZW50L2FkanVzdG1lbnQyLm1qcyIsIndlYnBhY2s6Ly9waXhpanMtZ2FtZS8uL25vZGVfbW9kdWxlcy8ucG5wbS9waXhpLWZpbHRlcnNANi4wLjVfcGl4aS5qc0A4LjYuNC9ub2RlX21vZHVsZXMvcGl4aS1maWx0ZXJzL2xpYi9hZHZhbmNlZC1ibG9vbS9FeHRyYWN0QnJpZ2h0bmVzc0ZpbHRlci5tanMiLCJ3ZWJwYWNrOi8vcGl4aWpzLWdhbWUvLi9ub2RlX21vZHVsZXMvLnBucG0vcGl4aS1maWx0ZXJzQDYuMC41X3BpeGkuanNAOC42LjQvbm9kZV9tb2R1bGVzL3BpeGktZmlsdGVycy9saWIvYWR2YW5jZWQtYmxvb20vZXh0cmFjdC1icmlnaHRuZXNzLm1qcyIsIndlYnBhY2s6Ly9waXhpanMtZ2FtZS8uL25vZGVfbW9kdWxlcy8ucG5wbS9waXhpLWZpbHRlcnNANi4wLjVfcGl4aS5qc0A4LjYuNC9ub2RlX21vZHVsZXMvcGl4aS1maWx0ZXJzL2xpYi9hZHZhbmNlZC1ibG9vbS9leHRyYWN0LWJyaWdodG5lc3MyLm1qcyIsIndlYnBhY2s6Ly9waXhpanMtZ2FtZS8uL25vZGVfbW9kdWxlcy8ucG5wbS9waXhpLWZpbHRlcnNANi4wLjVfcGl4aS5qc0A4LjYuNC9ub2RlX21vZHVsZXMvcGl4aS1maWx0ZXJzL2xpYi9hZHZhbmNlZC1ibG9vbS9BZHZhbmNlZEJsb29tRmlsdGVyLm1qcyIsIndlYnBhY2s6Ly9waXhpanMtZ2FtZS8uL25vZGVfbW9kdWxlcy8ucG5wbS9waXhpLWZpbHRlcnNANi4wLjVfcGl4aS5qc0A4LjYuNC9ub2RlX21vZHVsZXMvcGl4aS1maWx0ZXJzL2xpYi9hZHZhbmNlZC1ibG9vbS9hZHZhbmNlZC1ibG9vbTIubWpzIiwid2VicGFjazovL3BpeGlqcy1nYW1lLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3BpeGktZmlsdGVyc0A2LjAuNV9waXhpLmpzQDguNi40L25vZGVfbW9kdWxlcy9waXhpLWZpbHRlcnMvbGliL2FkdmFuY2VkLWJsb29tL2FkdmFuY2VkLWJsb29tLm1qcyIsIndlYnBhY2s6Ly9waXhpanMtZ2FtZS8uL25vZGVfbW9kdWxlcy8ucG5wbS9waXhpLWZpbHRlcnNANi4wLjVfcGl4aS5qc0A4LjYuNC9ub2RlX21vZHVsZXMvcGl4aS1maWx0ZXJzL2xpYi9hc2NpaS9Bc2NpaUZpbHRlci5tanMiLCJ3ZWJwYWNrOi8vcGl4aWpzLWdhbWUvLi9ub2RlX21vZHVsZXMvLnBucG0vcGl4aS1maWx0ZXJzQDYuMC41X3BpeGkuanNAOC42LjQvbm9kZV9tb2R1bGVzL3BpeGktZmlsdGVycy9saWIvYXNjaWkvYXNjaWkubWpzIiwid2VicGFjazovL3BpeGlqcy1nYW1lLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3BpeGktZmlsdGVyc0A2LjAuNV9waXhpLmpzQDguNi40L25vZGVfbW9kdWxlcy9waXhpLWZpbHRlcnMvbGliL2FzY2lpL2FzY2lpMi5tanMiLCJ3ZWJwYWNrOi8vcGl4aWpzLWdhbWUvLi9ub2RlX21vZHVsZXMvLnBucG0vcGl4aS1maWx0ZXJzQDYuMC41X3BpeGkuanNAOC42LjQvbm9kZV9tb2R1bGVzL3BpeGktZmlsdGVycy9saWIvYmFja2Ryb3AtYmx1ci9CYWNrZHJvcEJsdXJGaWx0ZXIubWpzIiwid2VicGFjazovL3BpeGlqcy1nYW1lLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3BpeGktZmlsdGVyc0A2LjAuNV9waXhpLmpzQDguNi40L25vZGVfbW9kdWxlcy9waXhpLWZpbHRlcnMvbGliL2JldmVsL0JldmVsRmlsdGVyLm1qcyIsIndlYnBhY2s6Ly9waXhpanMtZ2FtZS8uL25vZGVfbW9kdWxlcy8ucG5wbS9waXhpLWZpbHRlcnNANi4wLjVfcGl4aS5qc0A4LjYuNC9ub2RlX21vZHVsZXMvcGl4aS1maWx0ZXJzL2xpYi9iZXZlbC9iZXZlbC5tanMiLCJ3ZWJwYWNrOi8vcGl4aWpzLWdhbWUvLi9ub2RlX21vZHVsZXMvLnBucG0vcGl4aS1maWx0ZXJzQDYuMC41X3BpeGkuanNAOC42LjQvbm9kZV9tb2R1bGVzL3BpeGktZmlsdGVycy9saWIvYmV2ZWwvYmV2ZWwyLm1qcyIsIndlYnBhY2s6Ly9waXhpanMtZ2FtZS8uL25vZGVfbW9kdWxlcy8ucG5wbS9waXhpLWZpbHRlcnNANi4wLjVfcGl4aS5qc0A4LjYuNC9ub2RlX21vZHVsZXMvcGl4aS1maWx0ZXJzL2xpYi9ibG9vbS9CbG9vbUZpbHRlci5tanMiLCJ3ZWJwYWNrOi8vcGl4aWpzLWdhbWUvLi9ub2RlX21vZHVsZXMvLnBucG0vcGl4aS1maWx0ZXJzQDYuMC41X3BpeGkuanNAOC42LjQvbm9kZV9tb2R1bGVzL3BpeGktZmlsdGVycy9saWIvYnVsZ2UtcGluY2gvQnVsZ2VQaW5jaEZpbHRlci5tanMiLCJ3ZWJwYWNrOi8vcGl4aWpzLWdhbWUvLi9ub2RlX21vZHVsZXMvLnBucG0vcGl4aS1maWx0ZXJzQDYuMC41X3BpeGkuanNAOC42LjQvbm9kZV9tb2R1bGVzL3BpeGktZmlsdGVycy9saWIvYnVsZ2UtcGluY2gvYnVsZ2UtcGluY2gubWpzIiwid2VicGFjazovL3BpeGlqcy1nYW1lLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3BpeGktZmlsdGVyc0A2LjAuNV9waXhpLmpzQDguNi40L25vZGVfbW9kdWxlcy9waXhpLWZpbHRlcnMvbGliL2J1bGdlLXBpbmNoL2J1bGdlLXBpbmNoMi5tanMiLCJ3ZWJwYWNrOi8vcGl4aWpzLWdhbWUvLi9ub2RlX21vZHVsZXMvLnBucG0vcGl4aS1maWx0ZXJzQDYuMC41X3BpeGkuanNAOC42LjQvbm9kZV9tb2R1bGVzL3BpeGktZmlsdGVycy9saWIvY29sb3ItZ3JhZGllbnQvY29sb3ItZ3JhZGllbnQzLm1qcyIsIndlYnBhY2s6Ly9waXhpanMtZ2FtZS8uL25vZGVfbW9kdWxlcy8ucG5wbS9waXhpLWZpbHRlcnNANi4wLjVfcGl4aS5qc0A4LjYuNC9ub2RlX21vZHVsZXMvcGl4aS1maWx0ZXJzL2xpYi9jb2xvci1ncmFkaWVudC9Db2xvckdyYWRpZW50RmlsdGVyLm1qcyIsIndlYnBhY2s6Ly9waXhpanMtZ2FtZS8uL25vZGVfbW9kdWxlcy8ucG5wbS9waXhpLWZpbHRlcnNANi4wLjVfcGl4aS5qc0A4LjYuNC9ub2RlX21vZHVsZXMvcGl4aS1maWx0ZXJzL2xpYi9jb2xvci1ncmFkaWVudC9jb2xvci1ncmFkaWVudC5tanMiLCJ3ZWJwYWNrOi8vcGl4aWpzLWdhbWUvLi9ub2RlX21vZHVsZXMvLnBucG0vcGl4aS1maWx0ZXJzQDYuMC41X3BpeGkuanNAOC42LjQvbm9kZV9tb2R1bGVzL3BpeGktZmlsdGVycy9saWIvY29sb3ItZ3JhZGllbnQvY29sb3ItZ3JhZGllbnQyLm1qcyIsIndlYnBhY2s6Ly9waXhpanMtZ2FtZS8uL25vZGVfbW9kdWxlcy8ucG5wbS9waXhpLWZpbHRlcnNANi4wLjVfcGl4aS5qc0A4LjYuNC9ub2RlX21vZHVsZXMvcGl4aS1maWx0ZXJzL2xpYi9leHRlcm5hbC9ncmFkaWVudC1wYXJzZXIvYnVpbGQvbm9kZS5tanMiLCJ3ZWJwYWNrOi8vcGl4aWpzLWdhbWUvLi9ub2RlX21vZHVsZXMvLnBucG0vcGl4aS1maWx0ZXJzQDYuMC41X3BpeGkuanNAOC42LjQvbm9kZV9tb2R1bGVzL3BpeGktZmlsdGVycy9saWIvY29sb3ItZ3JhZGllbnQvQ3NzR3JhZGllbnRQYXJzZXIubWpzIiwid2VicGFjazovL3BpeGlqcy1nYW1lLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3BpeGktZmlsdGVyc0A2LjAuNV9waXhpLmpzQDguNi40L25vZGVfbW9kdWxlcy9waXhpLWZpbHRlcnMvbGliL2NvbG9yLW1hcC9Db2xvck1hcEZpbHRlci5tanMiLCJ3ZWJwYWNrOi8vcGl4aWpzLWdhbWUvLi9ub2RlX21vZHVsZXMvLnBucG0vcGl4aS1maWx0ZXJzQDYuMC41X3BpeGkuanNAOC42LjQvbm9kZV9tb2R1bGVzL3BpeGktZmlsdGVycy9saWIvY29sb3ItbWFwL2NvbG9yLW1hcC5tanMiLCJ3ZWJwYWNrOi8vcGl4aWpzLWdhbWUvLi9ub2RlX21vZHVsZXMvLnBucG0vcGl4aS1maWx0ZXJzQDYuMC41X3BpeGkuanNAOC42LjQvbm9kZV9tb2R1bGVzL3BpeGktZmlsdGVycy9saWIvY29sb3ItbWFwL2NvbG9yLW1hcDIubWpzIiwid2VicGFjazovL3BpeGlqcy1nYW1lLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3BpeGktZmlsdGVyc0A2LjAuNV9waXhpLmpzQDguNi40L25vZGVfbW9kdWxlcy9waXhpLWZpbHRlcnMvbGliL2NvbG9yLW92ZXJsYXkvQ29sb3JPdmVybGF5RmlsdGVyLm1qcyIsIndlYnBhY2s6Ly9waXhpanMtZ2FtZS8uL25vZGVfbW9kdWxlcy8ucG5wbS9waXhpLWZpbHRlcnNANi4wLjVfcGl4aS5qc0A4LjYuNC9ub2RlX21vZHVsZXMvcGl4aS1maWx0ZXJzL2xpYi9jb2xvci1vdmVybGF5L2NvbG9yLW92ZXJsYXkubWpzIiwid2VicGFjazovL3BpeGlqcy1nYW1lLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3BpeGktZmlsdGVyc0A2LjAuNV9waXhpLmpzQDguNi40L25vZGVfbW9kdWxlcy9waXhpLWZpbHRlcnMvbGliL2NvbG9yLW92ZXJsYXkvY29sb3Itb3ZlcmxheTIubWpzIiwid2VicGFjazovL3BpeGlqcy1nYW1lLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3BpeGktZmlsdGVyc0A2LjAuNV9waXhpLmpzQDguNi40L25vZGVfbW9kdWxlcy9waXhpLWZpbHRlcnMvbGliL2NvbG9yLXJlcGxhY2UvQ29sb3JSZXBsYWNlRmlsdGVyLm1qcyIsIndlYnBhY2s6Ly9waXhpanMtZ2FtZS8uL25vZGVfbW9kdWxlcy8ucG5wbS9waXhpLWZpbHRlcnNANi4wLjVfcGl4aS5qc0A4LjYuNC9ub2RlX21vZHVsZXMvcGl4aS1maWx0ZXJzL2xpYi9jb2xvci1yZXBsYWNlL2NvbG9yLXJlcGxhY2UubWpzIiwid2VicGFjazovL3BpeGlqcy1nYW1lLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3BpeGktZmlsdGVyc0A2LjAuNV9waXhpLmpzQDguNi40L25vZGVfbW9kdWxlcy9waXhpLWZpbHRlcnMvbGliL2NvbG9yLXJlcGxhY2UvY29sb3ItcmVwbGFjZTIubWpzIiwid2VicGFjazovL3BpeGlqcy1nYW1lLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3BpeGktZmlsdGVyc0A2LjAuNV9waXhpLmpzQDguNi40L25vZGVfbW9kdWxlcy9waXhpLWZpbHRlcnMvbGliL2NvbnZvbHV0aW9uL0NvbnZvbHV0aW9uRmlsdGVyLm1qcyIsIndlYnBhY2s6Ly9waXhpanMtZ2FtZS8uL25vZGVfbW9kdWxlcy8ucG5wbS9waXhpLWZpbHRlcnNANi4wLjVfcGl4aS5qc0A4LjYuNC9ub2RlX21vZHVsZXMvcGl4aS1maWx0ZXJzL2xpYi9jb252b2x1dGlvbi9jb252b2x1dGlvbjIubWpzIiwid2VicGFjazovL3BpeGlqcy1nYW1lLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3BpeGktZmlsdGVyc0A2LjAuNV9waXhpLmpzQDguNi40L25vZGVfbW9kdWxlcy9waXhpLWZpbHRlcnMvbGliL2NvbnZvbHV0aW9uL2NvbnZvbHV0aW9uLm1qcyIsIndlYnBhY2s6Ly9waXhpanMtZ2FtZS8uL25vZGVfbW9kdWxlcy8ucG5wbS9waXhpLWZpbHRlcnNANi4wLjVfcGl4aS5qc0A4LjYuNC9ub2RlX21vZHVsZXMvcGl4aS1maWx0ZXJzL2xpYi9jcm9zcy1oYXRjaC9Dcm9zc0hhdGNoRmlsdGVyLm1qcyIsIndlYnBhY2s6Ly9waXhpanMtZ2FtZS8uL25vZGVfbW9kdWxlcy8ucG5wbS9waXhpLWZpbHRlcnNANi4wLjVfcGl4aS5qc0A4LjYuNC9ub2RlX21vZHVsZXMvcGl4aS1maWx0ZXJzL2xpYi9jcnQvQ1JURmlsdGVyLm1qcyIsIndlYnBhY2s6Ly9waXhpanMtZ2FtZS8uL25vZGVfbW9kdWxlcy8ucG5wbS9waXhpLWZpbHRlcnNANi4wLjVfcGl4aS5qc0A4LjYuNC9ub2RlX21vZHVsZXMvcGl4aS1maWx0ZXJzL2xpYi9jcnQvY3J0Mi5tanMiLCJ3ZWJwYWNrOi8vcGl4aWpzLWdhbWUvLi9ub2RlX21vZHVsZXMvLnBucG0vcGl4aS1maWx0ZXJzQDYuMC41X3BpeGkuanNAOC42LjQvbm9kZV9tb2R1bGVzL3BpeGktZmlsdGVycy9saWIvY3J0L2NydC5tanMiLCJ3ZWJwYWNrOi8vcGl4aWpzLWdhbWUvLi9ub2RlX21vZHVsZXMvLnBucG0vcGl4aS1maWx0ZXJzQDYuMC41X3BpeGkuanNAOC42LjQvbm9kZV9tb2R1bGVzL3BpeGktZmlsdGVycy9saWIvZGVmYXVsdHMvZGVmYXVsdC5tanMiLCJ3ZWJwYWNrOi8vcGl4aWpzLWdhbWUvLi9ub2RlX21vZHVsZXMvLnBucG0vcGl4aS1maWx0ZXJzQDYuMC41X3BpeGkuanNAOC42LjQvbm9kZV9tb2R1bGVzL3BpeGktZmlsdGVycy9saWIvZGVmYXVsdHMvZGVmYXVsdDIubWpzIiwid2VicGFjazovL3BpeGlqcy1nYW1lLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3BpeGktZmlsdGVyc0A2LjAuNV9waXhpLmpzQDguNi40L25vZGVfbW9kdWxlcy9waXhpLWZpbHRlcnMvbGliL2RvdC9Eb3RGaWx0ZXIubWpzIiwid2VicGFjazovL3BpeGlqcy1nYW1lLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3BpeGktZmlsdGVyc0A2LjAuNV9waXhpLmpzQDguNi40L25vZGVfbW9kdWxlcy9waXhpLWZpbHRlcnMvbGliL2RvdC9kb3QubWpzIiwid2VicGFjazovL3BpeGlqcy1nYW1lLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3BpeGktZmlsdGVyc0A2LjAuNV9waXhpLmpzQDguNi40L25vZGVfbW9kdWxlcy9waXhpLWZpbHRlcnMvbGliL2RvdC9kb3QyLm1qcyIsIndlYnBhY2s6Ly9waXhpanMtZ2FtZS8uL25vZGVfbW9kdWxlcy8ucG5wbS9waXhpLWZpbHRlcnNANi4wLjVfcGl4aS5qc0A4LjYuNC9ub2RlX21vZHVsZXMvcGl4aS1maWx0ZXJzL2xpYi9kcm9wLXNoYWRvdy9Ecm9wU2hhZG93RmlsdGVyLm1qcyIsIndlYnBhY2s6Ly9waXhpanMtZ2FtZS8uL25vZGVfbW9kdWxlcy8ucG5wbS9waXhpLWZpbHRlcnNANi4wLjVfcGl4aS5qc0A4LjYuNC9ub2RlX21vZHVsZXMvcGl4aS1maWx0ZXJzL2xpYi9kcm9wLXNoYWRvdy9kcm9wLXNoYWRvdzIubWpzIiwid2VicGFjazovL3BpeGlqcy1nYW1lLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3BpeGktZmlsdGVyc0A2LjAuNV9waXhpLmpzQDguNi40L25vZGVfbW9kdWxlcy9waXhpLWZpbHRlcnMvbGliL2Ryb3Atc2hhZG93L2Ryb3Atc2hhZG93Lm1qcyIsIndlYnBhY2s6Ly9waXhpanMtZ2FtZS8uL25vZGVfbW9kdWxlcy8ucG5wbS9waXhpLWZpbHRlcnNANi4wLjVfcGl4aS5qc0A4LjYuNC9ub2RlX21vZHVsZXMvcGl4aS1maWx0ZXJzL2xpYi9lbWJvc3MvRW1ib3NzRmlsdGVyLm1qcyIsIndlYnBhY2s6Ly9waXhpanMtZ2FtZS8uL25vZGVfbW9kdWxlcy8ucG5wbS9waXhpLWZpbHRlcnNANi4wLjVfcGl4aS5qc0A4LjYuNC9ub2RlX21vZHVsZXMvcGl4aS1maWx0ZXJzL2xpYi9nbGl0Y2gvR2xpdGNoRmlsdGVyLm1qcyIsIndlYnBhY2s6Ly9waXhpanMtZ2FtZS8uL25vZGVfbW9kdWxlcy8ucG5wbS9waXhpLWZpbHRlcnNANi4wLjVfcGl4aS5qc0A4LjYuNC9ub2RlX21vZHVsZXMvcGl4aS1maWx0ZXJzL2xpYi9nbGl0Y2gvZ2xpdGNoLm1qcyIsIndlYnBhY2s6Ly9waXhpanMtZ2FtZS8uL25vZGVfbW9kdWxlcy8ucG5wbS9waXhpLWZpbHRlcnNANi4wLjVfcGl4aS5qc0A4LjYuNC9ub2RlX21vZHVsZXMvcGl4aS1maWx0ZXJzL2xpYi9nbGl0Y2gvZ2xpdGNoMi5tanMiLCJ3ZWJwYWNrOi8vcGl4aWpzLWdhbWUvLi9ub2RlX21vZHVsZXMvLnBucG0vcGl4aS1maWx0ZXJzQDYuMC41X3BpeGkuanNAOC42LjQvbm9kZV9tb2R1bGVzL3BpeGktZmlsdGVycy9saWIvZ2xvdy9HbG93RmlsdGVyLm1qcyIsIndlYnBhY2s6Ly9waXhpanMtZ2FtZS8uL25vZGVfbW9kdWxlcy8ucG5wbS9waXhpLWZpbHRlcnNANi4wLjVfcGl4aS5qc0A4LjYuNC9ub2RlX21vZHVsZXMvcGl4aS1maWx0ZXJzL2xpYi9nbG93L2dsb3cyLm1qcyIsIndlYnBhY2s6Ly9waXhpanMtZ2FtZS8uL25vZGVfbW9kdWxlcy8ucG5wbS9waXhpLWZpbHRlcnNANi4wLjVfcGl4aS5qc0A4LjYuNC9ub2RlX21vZHVsZXMvcGl4aS1maWx0ZXJzL2xpYi9nbG93L2dsb3cubWpzIiwid2VicGFjazovL3BpeGlqcy1nYW1lLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3BpeGktZmlsdGVyc0A2LjAuNV9waXhpLmpzQDguNi40L25vZGVfbW9kdWxlcy9waXhpLWZpbHRlcnMvbGliL2dvZHJheS9Hb2RyYXlGaWx0ZXIubWpzIiwid2VicGFjazovL3BpeGlqcy1nYW1lLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3BpeGktZmlsdGVyc0A2LjAuNV9waXhpLmpzQDguNi40L25vZGVfbW9kdWxlcy9waXhpLWZpbHRlcnMvbGliL2dvZHJheS9nb2QtcmF5Lm1qcyIsIndlYnBhY2s6Ly9waXhpanMtZ2FtZS8uL25vZGVfbW9kdWxlcy8ucG5wbS9waXhpLWZpbHRlcnNANi4wLjVfcGl4aS5qc0A4LjYuNC9ub2RlX21vZHVsZXMvcGl4aS1maWx0ZXJzL2xpYi9nb2RyYXkvcGVybGluMi5tanMiLCJ3ZWJwYWNrOi8vcGl4aWpzLWdhbWUvLi9ub2RlX21vZHVsZXMvLnBucG0vcGl4aS1maWx0ZXJzQDYuMC41X3BpeGkuanNAOC42LjQvbm9kZV9tb2R1bGVzL3BpeGktZmlsdGVycy9saWIvZ29kcmF5L2dvZC1yYXkyLm1qcyIsIndlYnBhY2s6Ly9waXhpanMtZ2FtZS8uL25vZGVfbW9kdWxlcy8ucG5wbS9waXhpLWZpbHRlcnNANi4wLjVfcGl4aS5qc0A4LjYuNC9ub2RlX21vZHVsZXMvcGl4aS1maWx0ZXJzL2xpYi9nb2RyYXkvcGVybGluLm1qcyIsIndlYnBhY2s6Ly9waXhpanMtZ2FtZS8uL25vZGVfbW9kdWxlcy8ucG5wbS9waXhpLWZpbHRlcnNANi4wLjVfcGl4aS5qc0A4LjYuNC9ub2RlX21vZHVsZXMvcGl4aS1maWx0ZXJzL2xpYi9ncmF5c2NhbGUvR3JheXNjYWxlRmlsdGVyLm1qcyIsIndlYnBhY2s6Ly9waXhpanMtZ2FtZS8uL25vZGVfbW9kdWxlcy8ucG5wbS9waXhpLWZpbHRlcnNANi4wLjVfcGl4aS5qc0A4LjYuNC9ub2RlX21vZHVsZXMvcGl4aS1maWx0ZXJzL2xpYi9oc2wtYWRqdXN0bWVudC9Ic2xBZGp1c3RtZW50RmlsdGVyLm1qcyIsIndlYnBhY2s6Ly9waXhpanMtZ2FtZS8uL25vZGVfbW9kdWxlcy8ucG5wbS9waXhpLWZpbHRlcnNANi4wLjVfcGl4aS5qc0A4LjYuNC9ub2RlX21vZHVsZXMvcGl4aS1maWx0ZXJzL2xpYi9oc2wtYWRqdXN0bWVudC9oc2xhZGp1c3RtZW50Lm1qcyIsIndlYnBhY2s6Ly9waXhpanMtZ2FtZS8uL25vZGVfbW9kdWxlcy8ucG5wbS9waXhpLWZpbHRlcnNANi4wLjVfcGl4aS5qc0A4LjYuNC9ub2RlX21vZHVsZXMvcGl4aS1maWx0ZXJzL2xpYi9oc2wtYWRqdXN0bWVudC9oc2xhZGp1c3RtZW50Mi5tanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGFwcGxlSXBob25lID0gL2lQaG9uZS9pO1xudmFyIGFwcGxlSXBvZCA9IC9pUG9kL2k7XG52YXIgYXBwbGVUYWJsZXQgPSAvaVBhZC9pO1xudmFyIGFwcGxlVW5pdmVyc2FsID0gL1xcYmlPUy11bml2ZXJzYWwoPzouKylNYWNcXGIvaTtcbnZhciBhbmRyb2lkUGhvbmUgPSAvXFxiQW5kcm9pZCg/Oi4rKU1vYmlsZVxcYi9pO1xudmFyIGFuZHJvaWRUYWJsZXQgPSAvQW5kcm9pZC9pO1xudmFyIGFtYXpvblBob25lID0gLyg/OlNENDkzMFVSfFxcYlNpbGsoPzouKylNb2JpbGVcXGIpL2k7XG52YXIgYW1hem9uVGFibGV0ID0gL1NpbGsvaTtcbnZhciB3aW5kb3dzUGhvbmUgPSAvV2luZG93cyBQaG9uZS9pO1xudmFyIHdpbmRvd3NUYWJsZXQgPSAvXFxiV2luZG93cyg/Oi4rKUFSTVxcYi9pO1xudmFyIG90aGVyQmxhY2tCZXJyeSA9IC9CbGFja0JlcnJ5L2k7XG52YXIgb3RoZXJCbGFja0JlcnJ5MTAgPSAvQkIxMC9pO1xudmFyIG90aGVyT3BlcmEgPSAvT3BlcmEgTWluaS9pO1xudmFyIG90aGVyQ2hyb21lID0gL1xcYihDcmlPU3xDaHJvbWUpKD86LispTW9iaWxlL2k7XG52YXIgb3RoZXJGaXJlZm94ID0gL01vYmlsZSg/Oi4rKUZpcmVmb3hcXGIvaTtcbnZhciBpc0FwcGxlVGFibGV0T25Jb3MxMyA9IGZ1bmN0aW9uIChuYXZpZ2F0b3IpIHtcbiAgICByZXR1cm4gKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIG5hdmlnYXRvci5wbGF0Zm9ybSA9PT0gJ01hY0ludGVsJyAmJlxuICAgICAgICB0eXBlb2YgbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID09PSAnbnVtYmVyJyAmJlxuICAgICAgICBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAxICYmXG4gICAgICAgIHR5cGVvZiBNU1N0cmVhbSA9PT0gJ3VuZGVmaW5lZCcpO1xufTtcbmZ1bmN0aW9uIGNyZWF0ZU1hdGNoKHVzZXJBZ2VudCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAocmVnZXgpIHsgcmV0dXJuIHJlZ2V4LnRlc3QodXNlckFnZW50KTsgfTtcbn1cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzTW9iaWxlKHBhcmFtKSB7XG4gICAgdmFyIG5hdiA9IHtcbiAgICAgICAgdXNlckFnZW50OiAnJyxcbiAgICAgICAgcGxhdGZvcm06ICcnLFxuICAgICAgICBtYXhUb3VjaFBvaW50czogMFxuICAgIH07XG4gICAgaWYgKCFwYXJhbSAmJiB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBuYXYgPSB7XG4gICAgICAgICAgICB1c2VyQWdlbnQ6IG5hdmlnYXRvci51c2VyQWdlbnQsXG4gICAgICAgICAgICBwbGF0Zm9ybTogbmF2aWdhdG9yLnBsYXRmb3JtLFxuICAgICAgICAgICAgbWF4VG91Y2hQb2ludHM6IG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyB8fCAwXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBwYXJhbSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbmF2LnVzZXJBZ2VudCA9IHBhcmFtO1xuICAgIH1cbiAgICBlbHNlIGlmIChwYXJhbSAmJiBwYXJhbS51c2VyQWdlbnQpIHtcbiAgICAgICAgbmF2ID0ge1xuICAgICAgICAgICAgdXNlckFnZW50OiBwYXJhbS51c2VyQWdlbnQsXG4gICAgICAgICAgICBwbGF0Zm9ybTogcGFyYW0ucGxhdGZvcm0sXG4gICAgICAgICAgICBtYXhUb3VjaFBvaW50czogcGFyYW0ubWF4VG91Y2hQb2ludHMgfHwgMFxuICAgICAgICB9O1xuICAgIH1cbiAgICB2YXIgdXNlckFnZW50ID0gbmF2LnVzZXJBZ2VudDtcbiAgICB2YXIgdG1wID0gdXNlckFnZW50LnNwbGl0KCdbRkJBTicpO1xuICAgIGlmICh0eXBlb2YgdG1wWzFdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB1c2VyQWdlbnQgPSB0bXBbMF07XG4gICAgfVxuICAgIHRtcCA9IHVzZXJBZ2VudC5zcGxpdCgnVHdpdHRlcicpO1xuICAgIGlmICh0eXBlb2YgdG1wWzFdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB1c2VyQWdlbnQgPSB0bXBbMF07XG4gICAgfVxuICAgIHZhciBtYXRjaCA9IGNyZWF0ZU1hdGNoKHVzZXJBZ2VudCk7XG4gICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgYXBwbGU6IHtcbiAgICAgICAgICAgIHBob25lOiBtYXRjaChhcHBsZUlwaG9uZSkgJiYgIW1hdGNoKHdpbmRvd3NQaG9uZSksXG4gICAgICAgICAgICBpcG9kOiBtYXRjaChhcHBsZUlwb2QpLFxuICAgICAgICAgICAgdGFibGV0OiAhbWF0Y2goYXBwbGVJcGhvbmUpICYmXG4gICAgICAgICAgICAgICAgKG1hdGNoKGFwcGxlVGFibGV0KSB8fCBpc0FwcGxlVGFibGV0T25Jb3MxMyhuYXYpKSAmJlxuICAgICAgICAgICAgICAgICFtYXRjaCh3aW5kb3dzUGhvbmUpLFxuICAgICAgICAgICAgdW5pdmVyc2FsOiBtYXRjaChhcHBsZVVuaXZlcnNhbCksXG4gICAgICAgICAgICBkZXZpY2U6IChtYXRjaChhcHBsZUlwaG9uZSkgfHxcbiAgICAgICAgICAgICAgICBtYXRjaChhcHBsZUlwb2QpIHx8XG4gICAgICAgICAgICAgICAgbWF0Y2goYXBwbGVUYWJsZXQpIHx8XG4gICAgICAgICAgICAgICAgbWF0Y2goYXBwbGVVbml2ZXJzYWwpIHx8XG4gICAgICAgICAgICAgICAgaXNBcHBsZVRhYmxldE9uSW9zMTMobmF2KSkgJiZcbiAgICAgICAgICAgICAgICAhbWF0Y2god2luZG93c1Bob25lKVxuICAgICAgICB9LFxuICAgICAgICBhbWF6b246IHtcbiAgICAgICAgICAgIHBob25lOiBtYXRjaChhbWF6b25QaG9uZSksXG4gICAgICAgICAgICB0YWJsZXQ6ICFtYXRjaChhbWF6b25QaG9uZSkgJiYgbWF0Y2goYW1hem9uVGFibGV0KSxcbiAgICAgICAgICAgIGRldmljZTogbWF0Y2goYW1hem9uUGhvbmUpIHx8IG1hdGNoKGFtYXpvblRhYmxldClcbiAgICAgICAgfSxcbiAgICAgICAgYW5kcm9pZDoge1xuICAgICAgICAgICAgcGhvbmU6ICghbWF0Y2god2luZG93c1Bob25lKSAmJiBtYXRjaChhbWF6b25QaG9uZSkpIHx8XG4gICAgICAgICAgICAgICAgKCFtYXRjaCh3aW5kb3dzUGhvbmUpICYmIG1hdGNoKGFuZHJvaWRQaG9uZSkpLFxuICAgICAgICAgICAgdGFibGV0OiAhbWF0Y2god2luZG93c1Bob25lKSAmJlxuICAgICAgICAgICAgICAgICFtYXRjaChhbWF6b25QaG9uZSkgJiZcbiAgICAgICAgICAgICAgICAhbWF0Y2goYW5kcm9pZFBob25lKSAmJlxuICAgICAgICAgICAgICAgIChtYXRjaChhbWF6b25UYWJsZXQpIHx8IG1hdGNoKGFuZHJvaWRUYWJsZXQpKSxcbiAgICAgICAgICAgIGRldmljZTogKCFtYXRjaCh3aW5kb3dzUGhvbmUpICYmXG4gICAgICAgICAgICAgICAgKG1hdGNoKGFtYXpvblBob25lKSB8fFxuICAgICAgICAgICAgICAgICAgICBtYXRjaChhbWF6b25UYWJsZXQpIHx8XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoKGFuZHJvaWRQaG9uZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2goYW5kcm9pZFRhYmxldCkpKSB8fFxuICAgICAgICAgICAgICAgIG1hdGNoKC9cXGJva2h0dHBcXGIvaSlcbiAgICAgICAgfSxcbiAgICAgICAgd2luZG93czoge1xuICAgICAgICAgICAgcGhvbmU6IG1hdGNoKHdpbmRvd3NQaG9uZSksXG4gICAgICAgICAgICB0YWJsZXQ6IG1hdGNoKHdpbmRvd3NUYWJsZXQpLFxuICAgICAgICAgICAgZGV2aWNlOiBtYXRjaCh3aW5kb3dzUGhvbmUpIHx8IG1hdGNoKHdpbmRvd3NUYWJsZXQpXG4gICAgICAgIH0sXG4gICAgICAgIG90aGVyOiB7XG4gICAgICAgICAgICBibGFja2JlcnJ5OiBtYXRjaChvdGhlckJsYWNrQmVycnkpLFxuICAgICAgICAgICAgYmxhY2tiZXJyeTEwOiBtYXRjaChvdGhlckJsYWNrQmVycnkxMCksXG4gICAgICAgICAgICBvcGVyYTogbWF0Y2gob3RoZXJPcGVyYSksXG4gICAgICAgICAgICBmaXJlZm94OiBtYXRjaChvdGhlckZpcmVmb3gpLFxuICAgICAgICAgICAgY2hyb21lOiBtYXRjaChvdGhlckNocm9tZSksXG4gICAgICAgICAgICBkZXZpY2U6IG1hdGNoKG90aGVyQmxhY2tCZXJyeSkgfHxcbiAgICAgICAgICAgICAgICBtYXRjaChvdGhlckJsYWNrQmVycnkxMCkgfHxcbiAgICAgICAgICAgICAgICBtYXRjaChvdGhlck9wZXJhKSB8fFxuICAgICAgICAgICAgICAgIG1hdGNoKG90aGVyRmlyZWZveCkgfHxcbiAgICAgICAgICAgICAgICBtYXRjaChvdGhlckNocm9tZSlcbiAgICAgICAgfSxcbiAgICAgICAgYW55OiBmYWxzZSxcbiAgICAgICAgcGhvbmU6IGZhbHNlLFxuICAgICAgICB0YWJsZXQ6IGZhbHNlXG4gICAgfTtcbiAgICByZXN1bHQuYW55ID1cbiAgICAgICAgcmVzdWx0LmFwcGxlLmRldmljZSB8fFxuICAgICAgICAgICAgcmVzdWx0LmFuZHJvaWQuZGV2aWNlIHx8XG4gICAgICAgICAgICByZXN1bHQud2luZG93cy5kZXZpY2UgfHxcbiAgICAgICAgICAgIHJlc3VsdC5vdGhlci5kZXZpY2U7XG4gICAgcmVzdWx0LnBob25lID1cbiAgICAgICAgcmVzdWx0LmFwcGxlLnBob25lIHx8IHJlc3VsdC5hbmRyb2lkLnBob25lIHx8IHJlc3VsdC53aW5kb3dzLnBob25lO1xuICAgIHJlc3VsdC50YWJsZXQgPVxuICAgICAgICByZXN1bHQuYXBwbGUudGFibGV0IHx8IHJlc3VsdC5hbmRyb2lkLnRhYmxldCB8fCByZXN1bHQud2luZG93cy50YWJsZXQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzTW9iaWxlLmpzLm1hcCIsIlxubW9kdWxlLmV4cG9ydHMgPSBwYXJzZVxuXG4vKipcbiAqIGV4cGVjdGVkIGFyZ3VtZW50IGxlbmd0aHNcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cblxudmFyIGxlbmd0aCA9IHthOiA3LCBjOiA2LCBoOiAxLCBsOiAyLCBtOiAyLCBxOiA0LCBzOiA0LCB0OiAyLCB2OiAxLCB6OiAwfVxuXG4vKipcbiAqIHNlZ21lbnQgcGF0dGVyblxuICogQHR5cGUge1JlZ0V4cH1cbiAqL1xuXG52YXIgc2VnbWVudCA9IC8oW2FzdHZ6cW1obGNdKShbXmFzdHZ6cW1obGNdKikvaWdcblxuLyoqXG4gKiBwYXJzZSBhbiBzdmcgcGF0aCBkYXRhIHN0cmluZy4gR2VuZXJhdGVzIGFuIEFycmF5XG4gKiBvZiBjb21tYW5kcyB3aGVyZSBlYWNoIGNvbW1hbmQgaXMgYW4gQXJyYXkgb2YgdGhlXG4gKiBmb3JtIGBbY29tbWFuZCwgYXJnMSwgYXJnMiwgLi4uXWBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblxuZnVuY3Rpb24gcGFyc2UocGF0aCkge1xuXHR2YXIgZGF0YSA9IFtdXG5cdHBhdGgucmVwbGFjZShzZWdtZW50LCBmdW5jdGlvbihfLCBjb21tYW5kLCBhcmdzKXtcblx0XHR2YXIgdHlwZSA9IGNvbW1hbmQudG9Mb3dlckNhc2UoKVxuXHRcdGFyZ3MgPSBwYXJzZVZhbHVlcyhhcmdzKVxuXG5cdFx0Ly8gb3ZlcmxvYWRlZCBtb3ZlVG9cblx0XHRpZiAodHlwZSA9PSAnbScgJiYgYXJncy5sZW5ndGggPiAyKSB7XG5cdFx0XHRkYXRhLnB1c2goW2NvbW1hbmRdLmNvbmNhdChhcmdzLnNwbGljZSgwLCAyKSkpXG5cdFx0XHR0eXBlID0gJ2wnXG5cdFx0XHRjb21tYW5kID0gY29tbWFuZCA9PSAnbScgPyAnbCcgOiAnTCdcblx0XHR9XG5cblx0XHR3aGlsZSAodHJ1ZSkge1xuXHRcdFx0aWYgKGFyZ3MubGVuZ3RoID09IGxlbmd0aFt0eXBlXSkge1xuXHRcdFx0XHRhcmdzLnVuc2hpZnQoY29tbWFuZClcblx0XHRcdFx0cmV0dXJuIGRhdGEucHVzaChhcmdzKVxuXHRcdFx0fVxuXHRcdFx0aWYgKGFyZ3MubGVuZ3RoIDwgbGVuZ3RoW3R5cGVdKSB0aHJvdyBuZXcgRXJyb3IoJ21hbGZvcm1lZCBwYXRoIGRhdGEnKVxuXHRcdFx0ZGF0YS5wdXNoKFtjb21tYW5kXS5jb25jYXQoYXJncy5zcGxpY2UoMCwgbGVuZ3RoW3R5cGVdKSkpXG5cdFx0fVxuXHR9KVxuXHRyZXR1cm4gZGF0YVxufVxuXG52YXIgbnVtYmVyID0gLy0/WzAtOV0qXFwuP1swLTldKyg/OmVbLStdP1xcZCspPy9pZ1xuXG5mdW5jdGlvbiBwYXJzZVZhbHVlcyhhcmdzKSB7XG5cdHZhciBudW1iZXJzID0gYXJncy5tYXRjaChudW1iZXIpXG5cdHJldHVybiBudW1iZXJzID8gbnVtYmVycy5tYXAoTnVtYmVyKSA6IFtdXG59XG4iLCJpbXBvcnQgeyBGaWx0ZXIsIEdwdVByb2dyYW0sIEdsUHJvZ3JhbSB9IGZyb20gJ3BpeGkuanMnO1xuaW1wb3J0IHZlcnRleCBmcm9tICcuLi9kZWZhdWx0cy9kZWZhdWx0Mi5tanMnO1xuaW1wb3J0IHdnc2xWZXJ0ZXggZnJvbSAnLi4vZGVmYXVsdHMvZGVmYXVsdC5tanMnO1xuaW1wb3J0IGZyYWdtZW50IGZyb20gJy4vYWRqdXN0bWVudDIubWpzJztcbmltcG9ydCBzb3VyY2UgZnJvbSAnLi9hZGp1c3RtZW50Lm1qcyc7XG5cbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbmNvbnN0IF9BZGp1c3RtZW50RmlsdGVyID0gY2xhc3MgX0FkanVzdG1lbnRGaWx0ZXIgZXh0ZW5kcyBGaWx0ZXIge1xuICAvKipcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBvZiB0aGUgYWRqdXN0bWVudCBmaWx0ZXIuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHsgLi4uX0FkanVzdG1lbnRGaWx0ZXIuREVGQVVMVF9PUFRJT05TLCAuLi5vcHRpb25zIH07XG4gICAgY29uc3QgZ3B1UHJvZ3JhbSA9IEdwdVByb2dyYW0uZnJvbSh7XG4gICAgICB2ZXJ0ZXg6IHtcbiAgICAgICAgc291cmNlOiB3Z3NsVmVydGV4LFxuICAgICAgICBlbnRyeVBvaW50OiBcIm1haW5WZXJ0ZXhcIlxuICAgICAgfSxcbiAgICAgIGZyYWdtZW50OiB7XG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgZW50cnlQb2ludDogXCJtYWluRnJhZ21lbnRcIlxuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGdsUHJvZ3JhbSA9IEdsUHJvZ3JhbS5mcm9tKHtcbiAgICAgIHZlcnRleCxcbiAgICAgIGZyYWdtZW50LFxuICAgICAgbmFtZTogXCJhZGp1c3RtZW50LWZpbHRlclwiXG4gICAgfSk7XG4gICAgc3VwZXIoe1xuICAgICAgZ3B1UHJvZ3JhbSxcbiAgICAgIGdsUHJvZ3JhbSxcbiAgICAgIHJlc291cmNlczoge1xuICAgICAgICBhZGp1c3RtZW50VW5pZm9ybXM6IHtcbiAgICAgICAgICB1R2FtbWE6IHsgdmFsdWU6IG9wdGlvbnMuZ2FtbWEsIHR5cGU6IFwiZjMyXCIgfSxcbiAgICAgICAgICB1Q29udHJhc3Q6IHsgdmFsdWU6IG9wdGlvbnMuY29udHJhc3QsIHR5cGU6IFwiZjMyXCIgfSxcbiAgICAgICAgICB1U2F0dXJhdGlvbjogeyB2YWx1ZTogb3B0aW9ucy5zYXR1cmF0aW9uLCB0eXBlOiBcImYzMlwiIH0sXG4gICAgICAgICAgdUJyaWdodG5lc3M6IHsgdmFsdWU6IG9wdGlvbnMuYnJpZ2h0bmVzcywgdHlwZTogXCJmMzJcIiB9LFxuICAgICAgICAgIHVDb2xvcjoge1xuICAgICAgICAgICAgdmFsdWU6IFtcbiAgICAgICAgICAgICAgb3B0aW9ucy5yZWQsXG4gICAgICAgICAgICAgIG9wdGlvbnMuZ3JlZW4sXG4gICAgICAgICAgICAgIG9wdGlvbnMuYmx1ZSxcbiAgICAgICAgICAgICAgb3B0aW9ucy5hbHBoYVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIHR5cGU6IFwidmVjNDxmMzI+XCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidW5pZm9ybXNcIik7XG4gICAgdGhpcy51bmlmb3JtcyA9IHRoaXMucmVzb3VyY2VzLmFkanVzdG1lbnRVbmlmb3Jtcy51bmlmb3JtcztcbiAgfVxuICAvKipcbiAgICogQW1vdW50IG9mIGx1bWluYW5jZVxuICAgKiBAZGVmYXVsdCAxXG4gICAqL1xuICBnZXQgZ2FtbWEoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMudUdhbW1hO1xuICB9XG4gIHNldCBnYW1tYSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMudUdhbW1hID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIEFtb3VudCBvZiBjb250cmFzdFxuICAgKiBAZGVmYXVsdCAxXG4gICAqL1xuICBnZXQgY29udHJhc3QoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMudUNvbnRyYXN0O1xuICB9XG4gIHNldCBjb250cmFzdCh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMudUNvbnRyYXN0ID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIEFtb3VudCBvZiBjb2xvciBzYXR1cmF0aW9uXG4gICAqIEBkZWZhdWx0IDFcbiAgICovXG4gIGdldCBzYXR1cmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnVTYXR1cmF0aW9uO1xuICB9XG4gIHNldCBzYXR1cmF0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy51U2F0dXJhdGlvbiA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgb3ZlcmFsbCBicmlnaHRuZXNzXG4gICAqIEBkZWZhdWx0IDFcbiAgICovXG4gIGdldCBicmlnaHRuZXNzKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnVCcmlnaHRuZXNzO1xuICB9XG4gIHNldCBicmlnaHRuZXNzKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy51QnJpZ2h0bmVzcyA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbXVsdGlwbGllZCByZWQgY2hhbm5lbFxuICAgKiBAZGVmYXVsdCAxXG4gICAqL1xuICBnZXQgcmVkKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnVDb2xvclswXTtcbiAgfVxuICBzZXQgcmVkKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy51Q29sb3JbMF0gPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIG11bHRpcGxpZWQgYmx1ZSBjaGFubmVsXG4gICAqIEBkZWZhdWx0IDFcbiAgICovXG4gIGdldCBncmVlbigpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy51Q29sb3JbMV07XG4gIH1cbiAgc2V0IGdyZWVuKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy51Q29sb3JbMV0gPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIG11bHRpcGxpZWQgZ3JlZW4gY2hhbm5lbFxuICAgKiBAZGVmYXVsdCAxXG4gICAqL1xuICBnZXQgYmx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy51Q29sb3JbMl07XG4gIH1cbiAgc2V0IGJsdWUodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnVDb2xvclsyXSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgb3ZlcmFsbCBhbHBoYSBjaGFubmVsXG4gICAqIEBkZWZhdWx0IDFcbiAgICovXG4gIGdldCBhbHBoYSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy51Q29sb3JbM107XG4gIH1cbiAgc2V0IGFscGhhKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy51Q29sb3JbM10gPSB2YWx1ZTtcbiAgfVxufTtcbi8qKiBEZWZhdWx0IHZhbHVlcyBmb3Igb3B0aW9ucy4gKi9cbl9fcHVibGljRmllbGQoX0FkanVzdG1lbnRGaWx0ZXIsIFwiREVGQVVMVF9PUFRJT05TXCIsIHtcbiAgZ2FtbWE6IDEsXG4gIGNvbnRyYXN0OiAxLFxuICBzYXR1cmF0aW9uOiAxLFxuICBicmlnaHRuZXNzOiAxLFxuICByZWQ6IDEsXG4gIGdyZWVuOiAxLFxuICBibHVlOiAxLFxuICBhbHBoYTogMVxufSk7XG5sZXQgQWRqdXN0bWVudEZpbHRlciA9IF9BZGp1c3RtZW50RmlsdGVyO1xuXG5leHBvcnQgeyBBZGp1c3RtZW50RmlsdGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BZGp1c3RtZW50RmlsdGVyLm1qcy5tYXBcbiIsInZhciBzb3VyY2UgPSBcInN0cnVjdCBBZGp1c3RtZW50VW5pZm9ybXMge1xcbiAgdUdhbW1hOiBmMzIsXFxuICB1Q29udHJhc3Q6IGYzMixcXG4gIHVTYXR1cmF0aW9uOiBmMzIsXFxuICB1QnJpZ2h0bmVzczogZjMyLFxcbiAgdUNvbG9yOiB2ZWM0PGYzMj4sXFxufTtcXG5cXG5AZ3JvdXAoMCkgQGJpbmRpbmcoMSkgdmFyIHVUZXh0dXJlOiB0ZXh0dXJlXzJkPGYzMj47IFxcbkBncm91cCgwKSBAYmluZGluZygyKSB2YXIgdVNhbXBsZXI6IHNhbXBsZXI7XFxuQGdyb3VwKDEpIEBiaW5kaW5nKDApIHZhcjx1bmlmb3JtPiBhZGp1c3RtZW50VW5pZm9ybXMgOiBBZGp1c3RtZW50VW5pZm9ybXM7XFxuXFxuQGZyYWdtZW50XFxuZm4gbWFpbkZyYWdtZW50KFxcbiAgQGxvY2F0aW9uKDApIHV2OiB2ZWMyPGYzMj4sXFxuICBAYnVpbHRpbihwb3NpdGlvbikgcG9zaXRpb246IHZlYzQ8ZjMyPlxcbikgLT4gQGxvY2F0aW9uKDApIHZlYzQ8ZjMyPiB7XFxuICB2YXIgc2FtcGxlID0gdGV4dHVyZVNhbXBsZSh1VGV4dHVyZSwgdVNhbXBsZXIsIHV2KTtcXG4gIGxldCBjb2xvciA9IGFkanVzdG1lbnRVbmlmb3Jtcy51Q29sb3I7XFxuXFxuICBpZiAoc2FtcGxlLmEgPiAwLjApIFxcbiAge1xcbiAgICBzYW1wbGUgPSB2ZWM0PGYzMj4oc2FtcGxlLnJnYiAvIHNhbXBsZS5hLCBzYW1wbGUuYSk7XFxuICAgIHZhciByZ2I6IHZlYzM8ZjMyPiA9IHBvdyhzYW1wbGUucmdiLCB2ZWMzPGYzMj4oMS4gLyBhZGp1c3RtZW50VW5pZm9ybXMudUdhbW1hKSk7XFxuICAgIHJnYiA9IG1peCh2ZWMzPGYzMj4oLjUpLCBtaXgodmVjMzxmMzI+KGRvdCh2ZWMzPGYzMj4oLjIxMjUsIC43MTU0LCAuMDcyMSksIHJnYikpLCByZ2IsIGFkanVzdG1lbnRVbmlmb3Jtcy51U2F0dXJhdGlvbiksIGFkanVzdG1lbnRVbmlmb3Jtcy51Q29udHJhc3QpO1xcbiAgICByZ2IuciAqPSBjb2xvci5yO1xcbiAgICByZ2IuZyAqPSBjb2xvci5nO1xcbiAgICByZ2IuYiAqPSBjb2xvci5iO1xcbiAgICBzYW1wbGUgPSB2ZWM0PGYzMj4ocmdiLnJnYiAqIGFkanVzdG1lbnRVbmlmb3Jtcy51QnJpZ2h0bmVzcywgc2FtcGxlLmEpO1xcbiAgICBzYW1wbGUgPSB2ZWM0PGYzMj4oc2FtcGxlLnJnYiAqIHNhbXBsZS5hLCBzYW1wbGUuYSk7XFxuICB9XFxuXFxuICByZXR1cm4gc2FtcGxlICogY29sb3IuYTtcXG59XCI7XG5cbmV4cG9ydCB7IHNvdXJjZSBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGp1c3RtZW50Lm1qcy5tYXBcbiIsInZhciBmcmFnbWVudCA9IFwiaW4gdmVjMiB2VGV4dHVyZUNvb3JkO1xcbm91dCB2ZWM0IGZpbmFsQ29sb3I7XFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxudW5pZm9ybSBmbG9hdCB1R2FtbWE7XFxudW5pZm9ybSBmbG9hdCB1Q29udHJhc3Q7XFxudW5pZm9ybSBmbG9hdCB1U2F0dXJhdGlvbjtcXG51bmlmb3JtIGZsb2F0IHVCcmlnaHRuZXNzO1xcbnVuaWZvcm0gdmVjNCB1Q29sb3I7XFxuXFxudm9pZCBtYWluKClcXG57XFxuICAgIHZlYzQgYyA9IHRleHR1cmUodVRleHR1cmUsIHZUZXh0dXJlQ29vcmQpO1xcblxcbiAgICBpZiAoYy5hID4gMC4wKSB7XFxuICAgICAgICBjLnJnYiAvPSBjLmE7XFxuXFxuICAgICAgICB2ZWMzIHJnYiA9IHBvdyhjLnJnYiwgdmVjMygxLiAvIHVHYW1tYSkpO1xcbiAgICAgICAgcmdiID0gbWl4KHZlYzMoLjUpLCBtaXgodmVjMyhkb3QodmVjMyguMjEyNSwgLjcxNTQsIC4wNzIxKSwgcmdiKSksIHJnYiwgdVNhdHVyYXRpb24pLCB1Q29udHJhc3QpO1xcbiAgICAgICAgcmdiLnIgKj0gdUNvbG9yLnI7XFxuICAgICAgICByZ2IuZyAqPSB1Q29sb3IuZztcXG4gICAgICAgIHJnYi5iICo9IHVDb2xvci5iO1xcbiAgICAgICAgYy5yZ2IgPSByZ2IgKiB1QnJpZ2h0bmVzcztcXG5cXG4gICAgICAgIGMucmdiICo9IGMuYTtcXG4gICAgfVxcblxcbiAgICBmaW5hbENvbG9yID0gYyAqIHVDb2xvci5hO1xcbn1cXG5cIjtcblxuZXhwb3J0IHsgZnJhZ21lbnQgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRqdXN0bWVudDIubWpzLm1hcFxuIiwiaW1wb3J0IHsgRmlsdGVyLCBHcHVQcm9ncmFtLCBHbFByb2dyYW0gfSBmcm9tICdwaXhpLmpzJztcbmltcG9ydCB2ZXJ0ZXggZnJvbSAnLi4vZGVmYXVsdHMvZGVmYXVsdDIubWpzJztcbmltcG9ydCB3Z3NsVmVydGV4IGZyb20gJy4uL2RlZmF1bHRzL2RlZmF1bHQubWpzJztcbmltcG9ydCBmcmFnbWVudCBmcm9tICcuL2V4dHJhY3QtYnJpZ2h0bmVzczIubWpzJztcbmltcG9ydCBzb3VyY2UgZnJvbSAnLi9leHRyYWN0LWJyaWdodG5lc3MubWpzJztcblxudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuY29uc3QgX0V4dHJhY3RCcmlnaHRuZXNzRmlsdGVyID0gY2xhc3MgX0V4dHJhY3RCcmlnaHRuZXNzRmlsdGVyIGV4dGVuZHMgRmlsdGVyIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7IC4uLl9FeHRyYWN0QnJpZ2h0bmVzc0ZpbHRlci5ERUZBVUxUX09QVElPTlMsIC4uLm9wdGlvbnMgfTtcbiAgICBjb25zdCBncHVQcm9ncmFtID0gR3B1UHJvZ3JhbS5mcm9tKHtcbiAgICAgIHZlcnRleDoge1xuICAgICAgICBzb3VyY2U6IHdnc2xWZXJ0ZXgsXG4gICAgICAgIGVudHJ5UG9pbnQ6IFwibWFpblZlcnRleFwiXG4gICAgICB9LFxuICAgICAgZnJhZ21lbnQ6IHtcbiAgICAgICAgc291cmNlLFxuICAgICAgICBlbnRyeVBvaW50OiBcIm1haW5GcmFnbWVudFwiXG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgZ2xQcm9ncmFtID0gR2xQcm9ncmFtLmZyb20oe1xuICAgICAgdmVydGV4LFxuICAgICAgZnJhZ21lbnQsXG4gICAgICBuYW1lOiBcImV4dHJhY3QtYnJpZ2h0bmVzcy1maWx0ZXJcIlxuICAgIH0pO1xuICAgIHN1cGVyKHtcbiAgICAgIGdwdVByb2dyYW0sXG4gICAgICBnbFByb2dyYW0sXG4gICAgICByZXNvdXJjZXM6IHtcbiAgICAgICAgZXh0cmFjdEJyaWdodG5lc3NVbmlmb3Jtczoge1xuICAgICAgICAgIHVUaHJlc2hvbGQ6IHsgdmFsdWU6IG9wdGlvbnMudGhyZXNob2xkLCB0eXBlOiBcImYzMlwiIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ1bmlmb3Jtc1wiKTtcbiAgICB0aGlzLnVuaWZvcm1zID0gdGhpcy5yZXNvdXJjZXMuZXh0cmFjdEJyaWdodG5lc3NVbmlmb3Jtcy51bmlmb3JtcztcbiAgfVxuICAvKipcbiAgICogRGVmaW5lcyBob3cgYnJpZ2h0IGEgY29sb3IgbmVlZHMgdG8gYmUgZXh0cmFjdGVkLlxuICAgKiBAZGVmYXVsdCAwLjVcbiAgICovXG4gIGdldCB0aHJlc2hvbGQoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMudVRocmVzaG9sZDtcbiAgfVxuICBzZXQgdGhyZXNob2xkKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy51VGhyZXNob2xkID0gdmFsdWU7XG4gIH1cbn07XG4vKiogRGVmYXVsdCB2YWx1ZXMgZm9yIG9wdGlvbnMuICovXG5fX3B1YmxpY0ZpZWxkKF9FeHRyYWN0QnJpZ2h0bmVzc0ZpbHRlciwgXCJERUZBVUxUX09QVElPTlNcIiwge1xuICB0aHJlc2hvbGQ6IDAuNVxufSk7XG5sZXQgRXh0cmFjdEJyaWdodG5lc3NGaWx0ZXIgPSBfRXh0cmFjdEJyaWdodG5lc3NGaWx0ZXI7XG5cbmV4cG9ydCB7IEV4dHJhY3RCcmlnaHRuZXNzRmlsdGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FeHRyYWN0QnJpZ2h0bmVzc0ZpbHRlci5tanMubWFwXG4iLCJ2YXIgc291cmNlID0gXCJzdHJ1Y3QgRXh0cmFjdEJyaWdodG5lc3NVbmlmb3JtcyB7XFxuICB1VGhyZXNob2xkOiBmMzIsXFxufTtcXG5cXG5AZ3JvdXAoMCkgQGJpbmRpbmcoMSkgdmFyIHVUZXh0dXJlOiB0ZXh0dXJlXzJkPGYzMj47IFxcbkBncm91cCgwKSBAYmluZGluZygyKSB2YXIgdVNhbXBsZXI6IHNhbXBsZXI7XFxuQGdyb3VwKDEpIEBiaW5kaW5nKDApIHZhcjx1bmlmb3JtPiBleHRyYWN0QnJpZ2h0bmVzc1VuaWZvcm1zIDogRXh0cmFjdEJyaWdodG5lc3NVbmlmb3JtcztcXG5cXG5AZnJhZ21lbnRcXG5mbiBtYWluRnJhZ21lbnQoXFxuICBAYnVpbHRpbihwb3NpdGlvbikgcG9zaXRpb246IHZlYzQ8ZjMyPixcXG4gIEBsb2NhdGlvbigwKSB1diA6IHZlYzI8ZjMyPlxcbikgLT4gQGxvY2F0aW9uKDApIHZlYzQ8ZjMyPiB7XFxuICBsZXQgY29sb3I6IHZlYzQ8ZjMyPiA9IHRleHR1cmVTYW1wbGUodVRleHR1cmUsIHVTYW1wbGVyLCB1dik7XFxuXFxuICAvLyBBIHNpbXBsZSAmIGZhc3QgYWxnb3JpdGhtIGZvciBnZXR0aW5nIGJyaWdodG5lc3MuXFxuICAvLyBJdCdzIGluYWNjdXJhdGUsIGJ1dCBnb29kIGVub3VnaCBmb3IgdGhpcyBmZWF0dXJlLlxcbiAgbGV0IG1heDogZjMyID0gbWF4KG1heChjb2xvci5yLCBjb2xvci5nKSwgY29sb3IuYik7XFxuICBsZXQgbWluOiBmMzIgPSBtaW4obWluKGNvbG9yLnIsIGNvbG9yLmcpLCBjb2xvci5iKTtcXG4gIGxldCBicmlnaHRuZXNzOiBmMzIgPSAobWF4ICsgbWluKSAqIDAuNTtcXG5cXG4gIHJldHVybiBzZWxlY3QodmVjNDxmMzI+KDAuKSwgY29sb3IsIGJyaWdodG5lc3MgPiBleHRyYWN0QnJpZ2h0bmVzc1VuaWZvcm1zLnVUaHJlc2hvbGQpO1xcbn1cXG5cIjtcblxuZXhwb3J0IHsgc291cmNlIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4dHJhY3QtYnJpZ2h0bmVzcy5tanMubWFwXG4iLCJ2YXIgZnJhZ21lbnQgPSBcIlxcbmluIHZlYzIgdlRleHR1cmVDb29yZDtcXG5vdXQgdmVjNCBmaW5hbENvbG9yO1xcblxcbnVuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbnVuaWZvcm0gZmxvYXQgdVRocmVzaG9sZDtcXG5cXG52b2lkIG1haW4oKSB7XFxuICAgIHZlYzQgY29sb3IgPSB0ZXh0dXJlKHVUZXh0dXJlLCB2VGV4dHVyZUNvb3JkKTtcXG5cXG4gICAgLy8gQSBzaW1wbGUgJiBmYXN0IGFsZ29yaXRobSBmb3IgZ2V0dGluZyBicmlnaHRuZXNzLlxcbiAgICAvLyBJdCdzIGluYWNjdXJhY3kgLCBidXQgZ29vZCBlbm91Z2h0IGZvciB0aGlzIGZlYXR1cmUuXFxuICAgIGZsb2F0IF9tYXggPSBtYXgobWF4KGNvbG9yLnIsIGNvbG9yLmcpLCBjb2xvci5iKTtcXG4gICAgZmxvYXQgX21pbiA9IG1pbihtaW4oY29sb3IuciwgY29sb3IuZyksIGNvbG9yLmIpO1xcbiAgICBmbG9hdCBicmlnaHRuZXNzID0gKF9tYXggKyBfbWluKSAqIDAuNTtcXG5cXG4gICAgaWYoYnJpZ2h0bmVzcyA+IHVUaHJlc2hvbGQpIHtcXG4gICAgICAgIGZpbmFsQ29sb3IgPSBjb2xvcjtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIGZpbmFsQ29sb3IgPSB2ZWM0KDAuMCwgMC4wLCAwLjAsIDAuMCk7XFxuICAgIH1cXG59XFxuXCI7XG5cbmV4cG9ydCB7IGZyYWdtZW50IGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4dHJhY3QtYnJpZ2h0bmVzczIubWpzLm1hcFxuIiwiaW1wb3J0IHsgRmlsdGVyLCBHcHVQcm9ncmFtLCBHbFByb2dyYW0sIFRleHR1cmUsIFRleHR1cmVQb29sIH0gZnJvbSAncGl4aS5qcyc7XG5pbXBvcnQgdmVydGV4IGZyb20gJy4uL2RlZmF1bHRzL2RlZmF1bHQyLm1qcyc7XG5pbXBvcnQgd2dzbFZlcnRleCBmcm9tICcuLi9kZWZhdWx0cy9kZWZhdWx0Lm1qcyc7XG5pbXBvcnQgeyBLYXdhc2VCbHVyRmlsdGVyIH0gZnJvbSAnLi4va2F3YXNlLWJsdXIvS2F3YXNlQmx1ckZpbHRlci5tanMnO1xuaW1wb3J0IGZyYWdtZW50IGZyb20gJy4vYWR2YW5jZWQtYmxvb20ubWpzJztcbmltcG9ydCBzb3VyY2UgZnJvbSAnLi9hZHZhbmNlZC1ibG9vbTIubWpzJztcbmltcG9ydCB7IEV4dHJhY3RCcmlnaHRuZXNzRmlsdGVyIH0gZnJvbSAnLi9FeHRyYWN0QnJpZ2h0bmVzc0ZpbHRlci5tanMnO1xuXG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiB7XG4gIF9fZGVmTm9ybWFsUHJvcChvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5jb25zdCBfQWR2YW5jZWRCbG9vbUZpbHRlciA9IGNsYXNzIF9BZHZhbmNlZEJsb29tRmlsdGVyIGV4dGVuZHMgRmlsdGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgdGhlIEFkdmFuY2VkQmxvb21GaWx0ZXIgY29uc3RydWN0b3IuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHsgLi4uX0FkdmFuY2VkQmxvb21GaWx0ZXIuREVGQVVMVF9PUFRJT05TLCAuLi5vcHRpb25zIH07XG4gICAgY29uc3QgZ3B1UHJvZ3JhbSA9IEdwdVByb2dyYW0uZnJvbSh7XG4gICAgICB2ZXJ0ZXg6IHtcbiAgICAgICAgc291cmNlOiB3Z3NsVmVydGV4LFxuICAgICAgICBlbnRyeVBvaW50OiBcIm1haW5WZXJ0ZXhcIlxuICAgICAgfSxcbiAgICAgIGZyYWdtZW50OiB7XG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgZW50cnlQb2ludDogXCJtYWluRnJhZ21lbnRcIlxuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGdsUHJvZ3JhbSA9IEdsUHJvZ3JhbS5mcm9tKHtcbiAgICAgIHZlcnRleCxcbiAgICAgIGZyYWdtZW50LFxuICAgICAgbmFtZTogXCJhZHZhbmNlZC1ibG9vbS1maWx0ZXJcIlxuICAgIH0pO1xuICAgIHN1cGVyKHtcbiAgICAgIGdwdVByb2dyYW0sXG4gICAgICBnbFByb2dyYW0sXG4gICAgICByZXNvdXJjZXM6IHtcbiAgICAgICAgYWR2YW5jZWRCbG9vbVVuaWZvcm1zOiB7XG4gICAgICAgICAgdUJsb29tU2NhbGU6IHsgdmFsdWU6IG9wdGlvbnMuYmxvb21TY2FsZSwgdHlwZTogXCJmMzJcIiB9LFxuICAgICAgICAgIHVCcmlnaHRuZXNzOiB7IHZhbHVlOiBvcHRpb25zLmJyaWdodG5lc3MsIHR5cGU6IFwiZjMyXCIgfVxuICAgICAgICB9LFxuICAgICAgICB1TWFwVGV4dHVyZTogVGV4dHVyZS5XSElURVxuICAgICAgfVxuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ1bmlmb3Jtc1wiKTtcbiAgICAvKiogVG8gYWRqdXN0IHRoZSBzdHJlbmd0aCBvZiB0aGUgYmxvb20uIEhpZ2hlciB2YWx1ZXMgaXMgbW9yZSBpbnRlbnNlIGJyaWdodG5lc3MuICovXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImJsb29tU2NhbGVcIiwgMSk7XG4gICAgLyoqIFRoZSBicmlnaHRuZXNzLCBsb3dlciB2YWx1ZSBpcyBtb3JlIHN1YnRsZSBicmlnaHRuZXNzLCBoaWdoZXIgdmFsdWUgaXMgYmxvd24tb3V0LiAqL1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJicmlnaHRuZXNzXCIsIDEpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfZXh0cmFjdEZpbHRlclwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX2JsdXJGaWx0ZXJcIik7XG4gICAgdGhpcy51bmlmb3JtcyA9IHRoaXMucmVzb3VyY2VzLmFkdmFuY2VkQmxvb21Vbmlmb3Jtcy51bmlmb3JtcztcbiAgICB0aGlzLl9leHRyYWN0RmlsdGVyID0gbmV3IEV4dHJhY3RCcmlnaHRuZXNzRmlsdGVyKHtcbiAgICAgIHRocmVzaG9sZDogb3B0aW9ucy50aHJlc2hvbGRcbiAgICB9KTtcbiAgICB0aGlzLl9ibHVyRmlsdGVyID0gbmV3IEthd2FzZUJsdXJGaWx0ZXIoe1xuICAgICAgc3RyZW5ndGg6IG9wdGlvbnMua2VybmVscyA/PyBvcHRpb25zLmJsdXIsXG4gICAgICBxdWFsaXR5OiBvcHRpb25zLmtlcm5lbHMgPyB2b2lkIDAgOiBvcHRpb25zLnF1YWxpdHlcbiAgICB9KTtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBPdmVycmlkZSBleGlzdGluZyBhcHBseSBtZXRob2QgaW4gYEZpbHRlcmBcbiAgICogQG92ZXJyaWRlXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGFwcGx5KGZpbHRlck1hbmFnZXIsIGlucHV0LCBvdXRwdXQsIGNsZWFyTW9kZSkge1xuICAgIGNvbnN0IGJyaWdodFRhcmdldCA9IFRleHR1cmVQb29sLmdldFNhbWVTaXplVGV4dHVyZShpbnB1dCk7XG4gICAgdGhpcy5fZXh0cmFjdEZpbHRlci5hcHBseShmaWx0ZXJNYW5hZ2VyLCBpbnB1dCwgYnJpZ2h0VGFyZ2V0LCB0cnVlKTtcbiAgICBjb25zdCBibG9vbVRhcmdldCA9IFRleHR1cmVQb29sLmdldFNhbWVTaXplVGV4dHVyZShpbnB1dCk7XG4gICAgdGhpcy5fYmx1ckZpbHRlci5hcHBseShmaWx0ZXJNYW5hZ2VyLCBicmlnaHRUYXJnZXQsIGJsb29tVGFyZ2V0LCB0cnVlKTtcbiAgICB0aGlzLnVuaWZvcm1zLnVCbG9vbVNjYWxlID0gdGhpcy5ibG9vbVNjYWxlO1xuICAgIHRoaXMudW5pZm9ybXMudUJyaWdodG5lc3MgPSB0aGlzLmJyaWdodG5lc3M7XG4gICAgdGhpcy5yZXNvdXJjZXMudU1hcFRleHR1cmUgPSBibG9vbVRhcmdldC5zb3VyY2U7XG4gICAgZmlsdGVyTWFuYWdlci5hcHBseUZpbHRlcih0aGlzLCBpbnB1dCwgb3V0cHV0LCBjbGVhck1vZGUpO1xuICAgIFRleHR1cmVQb29sLnJldHVyblRleHR1cmUoYmxvb21UYXJnZXQpO1xuICAgIFRleHR1cmVQb29sLnJldHVyblRleHR1cmUoYnJpZ2h0VGFyZ2V0KTtcbiAgfVxuICAvKipcbiAgICogRGVmaW5lcyBob3cgYnJpZ2h0IGEgY29sb3IgbmVlZHMgdG8gYmUgZXh0cmFjdGVkLlxuICAgKiBAZGVmYXVsdCAwLjVcbiAgICovXG4gIGdldCB0aHJlc2hvbGQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2V4dHJhY3RGaWx0ZXIudGhyZXNob2xkO1xuICB9XG4gIHNldCB0aHJlc2hvbGQodmFsdWUpIHtcbiAgICB0aGlzLl9leHRyYWN0RmlsdGVyLnRocmVzaG9sZCA9IHZhbHVlO1xuICB9XG4gIC8qKiBUaGUga2VybmVscyBvZiB0aGUgQmx1ciBGaWx0ZXIgKi9cbiAgZ2V0IGtlcm5lbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JsdXJGaWx0ZXIua2VybmVscztcbiAgfVxuICBzZXQga2VybmVscyh2YWx1ZSkge1xuICAgIHRoaXMuX2JsdXJGaWx0ZXIua2VybmVscyA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgc3RyZW5ndGggb2YgdGhlIEJsdXIgcHJvcGVydGllcyBzaW11bHRhbmVvdXNseVxuICAgKiBAZGVmYXVsdCAyXG4gICAqL1xuICBnZXQgYmx1cigpIHtcbiAgICByZXR1cm4gdGhpcy5fYmx1ckZpbHRlci5zdHJlbmd0aDtcbiAgfVxuICBzZXQgYmx1cih2YWx1ZSkge1xuICAgIHRoaXMuX2JsdXJGaWx0ZXIuc3RyZW5ndGggPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIHF1YWxpdHkgb2YgdGhlIEJsdXIgRmlsdGVyXG4gICAqIEBkZWZhdWx0IDRcbiAgICovXG4gIGdldCBxdWFsaXR5KCkge1xuICAgIHJldHVybiB0aGlzLl9ibHVyRmlsdGVyLnF1YWxpdHk7XG4gIH1cbiAgc2V0IHF1YWxpdHkodmFsdWUpIHtcbiAgICB0aGlzLl9ibHVyRmlsdGVyLnF1YWxpdHkgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIHBpeGVsIHNpemUgb2YgdGhlIEthd2FzZSBCbHVyIGZpbHRlclxuICAgKiBAZGVmYXVsdCB7eDoxLHk6MX1cbiAgICovXG4gIGdldCBwaXhlbFNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JsdXJGaWx0ZXIucGl4ZWxTaXplO1xuICB9XG4gIHNldCBwaXhlbFNpemUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICB2YWx1ZSA9IHsgeDogdmFsdWUsIHk6IHZhbHVlIH07XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgdmFsdWUgPSB7IHg6IHZhbHVlWzBdLCB5OiB2YWx1ZVsxXSB9O1xuICAgIH1cbiAgICB0aGlzLl9ibHVyRmlsdGVyLnBpeGVsU2l6ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgaG9yaXpvbnRhbCBwaXhlbFNpemUgb2YgdGhlIEthd2FzZSBCbHVyIGZpbHRlclxuICAgKiBAZGVmYXVsdCAxXG4gICAqL1xuICBnZXQgcGl4ZWxTaXplWCgpIHtcbiAgICByZXR1cm4gdGhpcy5fYmx1ckZpbHRlci5waXhlbFNpemVYO1xuICB9XG4gIHNldCBwaXhlbFNpemVYKHZhbHVlKSB7XG4gICAgdGhpcy5fYmx1ckZpbHRlci5waXhlbFNpemVYID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSB2ZXJ0aWNhbCBwaXhlbCBzaXplIG9mIHRoZSBLYXdhc2UgQmx1ciBmaWx0ZXJcbiAgICogQGRlZmF1bHQgMVxuICAgKi9cbiAgZ2V0IHBpeGVsU2l6ZVkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JsdXJGaWx0ZXIucGl4ZWxTaXplWTtcbiAgfVxuICBzZXQgcGl4ZWxTaXplWSh2YWx1ZSkge1xuICAgIHRoaXMuX2JsdXJGaWx0ZXIucGl4ZWxTaXplWSA9IHZhbHVlO1xuICB9XG59O1xuLyoqIERlZmF1bHQgdmFsdWVzIGZvciBvcHRpb25zLiAqL1xuX19wdWJsaWNGaWVsZChfQWR2YW5jZWRCbG9vbUZpbHRlciwgXCJERUZBVUxUX09QVElPTlNcIiwge1xuICB0aHJlc2hvbGQ6IDAuNSxcbiAgYmxvb21TY2FsZTogMSxcbiAgYnJpZ2h0bmVzczogMSxcbiAgYmx1cjogOCxcbiAgcXVhbGl0eTogNCxcbiAgcGl4ZWxTaXplOiB7IHg6IDEsIHk6IDEgfVxufSk7XG5sZXQgQWR2YW5jZWRCbG9vbUZpbHRlciA9IF9BZHZhbmNlZEJsb29tRmlsdGVyO1xuXG5leHBvcnQgeyBBZHZhbmNlZEJsb29tRmlsdGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BZHZhbmNlZEJsb29tRmlsdGVyLm1qcy5tYXBcbiIsInZhciBzb3VyY2UgPSBcInN0cnVjdCBBZHZhbmNlZEJsb29tVW5pZm9ybXMge1xcbiAgdUJsb29tU2NhbGU6IGYzMixcXG4gIHVCcmlnaHRuZXNzOiBmMzIsXFxufTtcXG5cXG5AZ3JvdXAoMCkgQGJpbmRpbmcoMSkgdmFyIHVUZXh0dXJlOiB0ZXh0dXJlXzJkPGYzMj47IFxcbkBncm91cCgwKSBAYmluZGluZygyKSB2YXIgdVNhbXBsZXI6IHNhbXBsZXI7XFxuQGdyb3VwKDEpIEBiaW5kaW5nKDApIHZhcjx1bmlmb3JtPiBhZHZhbmNlZEJsb29tVW5pZm9ybXMgOiBBZHZhbmNlZEJsb29tVW5pZm9ybXM7XFxuQGdyb3VwKDEpIEBiaW5kaW5nKDEpIHZhciB1TWFwVGV4dHVyZTogdGV4dHVyZV8yZDxmMzI+O1xcblxcbkBmcmFnbWVudFxcbmZuIG1haW5GcmFnbWVudChcXG4gIEBidWlsdGluKHBvc2l0aW9uKSBwb3NpdGlvbjogdmVjNDxmMzI+LFxcbiAgQGxvY2F0aW9uKDApIHV2IDogdmVjMjxmMzI+XFxuKSAtPiBAbG9jYXRpb24oMCkgdmVjNDxmMzI+IHtcXG4gIHZhciBjb2xvciA9IHRleHR1cmVTYW1wbGUodVRleHR1cmUsIHVTYW1wbGVyLCB1dik7XFxuICBjb2xvciA9IHZlYzQ8ZjMyPihjb2xvci5yZ2IgKiBhZHZhbmNlZEJsb29tVW5pZm9ybXMudUJyaWdodG5lc3MsIGNvbG9yLmEpO1xcblxcbiAgdmFyIGJsb29tQ29sb3IgPSB2ZWM0PGYzMj4odGV4dHVyZVNhbXBsZSh1TWFwVGV4dHVyZSwgdVNhbXBsZXIsIHV2KS5yZ2IsIDAuMCk7XFxuICBibG9vbUNvbG9yID0gdmVjNDxmMzI+KGJsb29tQ29sb3IucmdiICogYWR2YW5jZWRCbG9vbVVuaWZvcm1zLnVCbG9vbVNjYWxlLCBibG9vbUNvbG9yLmEpO1xcbiAgXFxuICByZXR1cm4gY29sb3IgKyBibG9vbUNvbG9yO1xcbn1cXG5cIjtcblxuZXhwb3J0IHsgc291cmNlIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkdmFuY2VkLWJsb29tMi5tanMubWFwXG4iLCJ2YXIgZnJhZ21lbnQgPSBcImluIHZlYzIgdlRleHR1cmVDb29yZDtcXG5vdXQgdmVjNCBmaW5hbENvbG9yO1xcblxcbnVuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVNYXBUZXh0dXJlO1xcbnVuaWZvcm0gZmxvYXQgdUJsb29tU2NhbGU7XFxudW5pZm9ybSBmbG9hdCB1QnJpZ2h0bmVzcztcXG5cXG52b2lkIG1haW4oKSB7XFxuICAgIHZlYzQgY29sb3IgPSB0ZXh0dXJlKHVUZXh0dXJlLCB2VGV4dHVyZUNvb3JkKTtcXG4gICAgY29sb3IucmdiICo9IHVCcmlnaHRuZXNzO1xcbiAgICB2ZWM0IGJsb29tQ29sb3IgPSB2ZWM0KHRleHR1cmUodU1hcFRleHR1cmUsIHZUZXh0dXJlQ29vcmQpLnJnYiwgMC4wKTtcXG4gICAgYmxvb21Db2xvci5yZ2IgKj0gdUJsb29tU2NhbGU7XFxuICAgIGZpbmFsQ29sb3IgPSBjb2xvciArIGJsb29tQ29sb3I7XFxufVxcblwiO1xuXG5leHBvcnQgeyBmcmFnbWVudCBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZHZhbmNlZC1ibG9vbS5tanMubWFwXG4iLCJpbXBvcnQgeyBGaWx0ZXIsIGRlcHJlY2F0aW9uLCBHcHVQcm9ncmFtLCBHbFByb2dyYW0sIENvbG9yIH0gZnJvbSAncGl4aS5qcyc7XG5pbXBvcnQgdmVydGV4IGZyb20gJy4uL2RlZmF1bHRzL2RlZmF1bHQyLm1qcyc7XG5pbXBvcnQgd2dzbFZlcnRleCBmcm9tICcuLi9kZWZhdWx0cy9kZWZhdWx0Lm1qcyc7XG5pbXBvcnQgZnJhZ21lbnQgZnJvbSAnLi9hc2NpaTIubWpzJztcbmltcG9ydCBzb3VyY2UgZnJvbSAnLi9hc2NpaS5tanMnO1xuXG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiB7XG4gIF9fZGVmTm9ybWFsUHJvcChvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5jb25zdCBfQXNjaWlGaWx0ZXIgPSBjbGFzcyBfQXNjaWlGaWx0ZXIgZXh0ZW5kcyBGaWx0ZXIge1xuICAvKiogQGlnbm9yZSAqL1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmdzWzBdID8/IHt9O1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJudW1iZXJcIikge1xuICAgICAgZGVwcmVjYXRpb24oXCI2LjAuMFwiLCBcIkFzY2lpRmlsdGVyIGNvbnN0cnVjdG9yIHBhcmFtcyBhcmUgbm93IG9wdGlvbnMgb2JqZWN0LiBTZWUgcGFyYW1zOiB7IHNpemUsIGNvbG9yLCByZXBsYWNlQ29sb3IgfVwiKTtcbiAgICAgIG9wdGlvbnMgPSB7IHNpemU6IG9wdGlvbnMgfTtcbiAgICB9XG4gICAgY29uc3QgcmVwbGFjZUNvbG9yID0gb3B0aW9ucz8uY29sb3IgJiYgb3B0aW9ucy5yZXBsYWNlQ29sb3IgIT09IGZhbHNlO1xuICAgIG9wdGlvbnMgPSB7IC4uLl9Bc2NpaUZpbHRlci5ERUZBVUxUX09QVElPTlMsIC4uLm9wdGlvbnMgfTtcbiAgICBjb25zdCBncHVQcm9ncmFtID0gR3B1UHJvZ3JhbS5mcm9tKHtcbiAgICAgIHZlcnRleDoge1xuICAgICAgICBzb3VyY2U6IHdnc2xWZXJ0ZXgsXG4gICAgICAgIGVudHJ5UG9pbnQ6IFwibWFpblZlcnRleFwiXG4gICAgICB9LFxuICAgICAgZnJhZ21lbnQ6IHtcbiAgICAgICAgc291cmNlLFxuICAgICAgICBlbnRyeVBvaW50OiBcIm1haW5GcmFnbWVudFwiXG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgZ2xQcm9ncmFtID0gR2xQcm9ncmFtLmZyb20oe1xuICAgICAgdmVydGV4LFxuICAgICAgZnJhZ21lbnQsXG4gICAgICBuYW1lOiBcImFzY2lpLWZpbHRlclwiXG4gICAgfSk7XG4gICAgc3VwZXIoe1xuICAgICAgZ3B1UHJvZ3JhbSxcbiAgICAgIGdsUHJvZ3JhbSxcbiAgICAgIHJlc291cmNlczoge1xuICAgICAgICBhc2NpaVVuaWZvcm1zOiB7XG4gICAgICAgICAgdVNpemU6IHsgdmFsdWU6IG9wdGlvbnMuc2l6ZSwgdHlwZTogXCJmMzJcIiB9LFxuICAgICAgICAgIHVDb2xvcjogeyB2YWx1ZTogbmV3IEZsb2F0MzJBcnJheSgzKSwgdHlwZTogXCJ2ZWMzPGYzMj5cIiB9LFxuICAgICAgICAgIHVSZXBsYWNlQ29sb3I6IHsgdmFsdWU6IE51bWJlcihyZXBsYWNlQ29sb3IpLCB0eXBlOiBcImYzMlwiIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ1bmlmb3Jtc1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX2NvbG9yXCIpO1xuICAgIHRoaXMudW5pZm9ybXMgPSB0aGlzLnJlc291cmNlcy5hc2NpaVVuaWZvcm1zLnVuaWZvcm1zO1xuICAgIHRoaXMuX2NvbG9yID0gbmV3IENvbG9yKCk7XG4gICAgdGhpcy5jb2xvciA9IG9wdGlvbnMuY29sb3IgPz8gMTY3NzcyMTU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBwaXhlbCBzaXplIHVzZWQgYnkgdGhlIGZpbHRlci5cbiAgICogQGRlZmF1bHQgOFxuICAgKi9cbiAgZ2V0IHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMudVNpemU7XG4gIH1cbiAgc2V0IHNpemUodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnVTaXplID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSByZXN1bHRpbmcgY29sb3Igb2YgdGhlIGFzY2lpIGNoYXJhY3RlcnMsIGFzIGEgMyBjb21wb25lbnQgUkdCIG9yIG51bWVyaWNhbCBoZXhcbiAgICogQGV4YW1wbGUgWzEuMCwgMS4wLCAxLjBdID0gMHhmZmZmZmZcbiAgICogQGRlZmF1bHQgMHhmZmZmZmZcbiAgICovXG4gIGdldCBjb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5fY29sb3IudmFsdWU7XG4gIH1cbiAgc2V0IGNvbG9yKHZhbHVlKSB7XG4gICAgdGhpcy5fY29sb3Iuc2V0VmFsdWUodmFsdWUpO1xuICAgIGNvbnN0IFtyLCBnLCBiXSA9IHRoaXMuX2NvbG9yLnRvQXJyYXkoKTtcbiAgICB0aGlzLnVuaWZvcm1zLnVDb2xvclswXSA9IHI7XG4gICAgdGhpcy51bmlmb3Jtcy51Q29sb3JbMV0gPSBnO1xuICAgIHRoaXMudW5pZm9ybXMudUNvbG9yWzJdID0gYjtcbiAgfVxuICAvKipcbiAgICogRGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IHRvIHJlcGxhY2UgdGhlIHNvdXJjZSBjb2xvcnMgd2l0aCB0aGUgcHJvdmlkZWQuXG4gICAqL1xuICBnZXQgcmVwbGFjZUNvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnVSZXBsYWNlQ29sb3IgPiAwLjU7XG4gIH1cbiAgc2V0IHJlcGxhY2VDb2xvcih2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMudVJlcGxhY2VDb2xvciA9IHZhbHVlID8gMSA6IDA7XG4gIH1cbn07XG4vKiogRGVmYXVsdCB2YWx1ZXMgZm9yIG9wdGlvbnMuICovXG5fX3B1YmxpY0ZpZWxkKF9Bc2NpaUZpbHRlciwgXCJERUZBVUxUX09QVElPTlNcIiwge1xuICBzaXplOiA4LFxuICBjb2xvcjogMTY3NzcyMTUsXG4gIHJlcGxhY2VDb2xvcjogZmFsc2Vcbn0pO1xubGV0IEFzY2lpRmlsdGVyID0gX0FzY2lpRmlsdGVyO1xuXG5leHBvcnQgeyBBc2NpaUZpbHRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXNjaWlGaWx0ZXIubWpzLm1hcFxuIiwidmFyIHNvdXJjZSA9IFwic3RydWN0IEFzY2lpVW5pZm9ybXMge1xcbiAgICB1U2l6ZTogZjMyLFxcbiAgICB1Q29sb3I6IHZlYzM8ZjMyPixcXG4gICAgdVJlcGxhY2VDb2xvcjogZjMyLFxcbn07XFxuXFxuc3RydWN0IEdsb2JhbEZpbHRlclVuaWZvcm1zIHtcXG4gICAgdUlucHV0U2l6ZTp2ZWM0PGYzMj4sXFxuICAgIHVJbnB1dFBpeGVsOnZlYzQ8ZjMyPixcXG4gICAgdUlucHV0Q2xhbXA6dmVjNDxmMzI+LFxcbiAgICB1T3V0cHV0RnJhbWU6dmVjNDxmMzI+LFxcbiAgICB1R2xvYmFsRnJhbWU6dmVjNDxmMzI+LFxcbiAgICB1T3V0cHV0VGV4dHVyZTp2ZWM0PGYzMj4sXFxufTtcXG5cXG5AZ3JvdXAoMCkgQGJpbmRpbmcoMCkgdmFyPHVuaWZvcm0+IGdmdTogR2xvYmFsRmlsdGVyVW5pZm9ybXM7XFxuXFxuQGdyb3VwKDApIEBiaW5kaW5nKDEpIHZhciB1VGV4dHVyZTogdGV4dHVyZV8yZDxmMzI+OyBcXG5AZ3JvdXAoMCkgQGJpbmRpbmcoMikgdmFyIHVTYW1wbGVyOiBzYW1wbGVyO1xcbkBncm91cCgxKSBAYmluZGluZygwKSB2YXI8dW5pZm9ybT4gYXNjaWlVbmlmb3JtcyA6IEFzY2lpVW5pZm9ybXM7XFxuXFxuQGZyYWdtZW50XFxuZm4gbWFpbkZyYWdtZW50KFxcbiAgICBAbG9jYXRpb24oMCkgdXY6IHZlYzI8ZjMyPixcXG4gICAgQGJ1aWx0aW4ocG9zaXRpb24pIHBvc2l0aW9uOiB2ZWM0PGYzMj5cXG4pIC0+IEBsb2NhdGlvbigwKSB2ZWM0PGYzMj4ge1xcbiAgICBsZXQgcGl4ZWxTaXplOiBmMzIgPSBhc2NpaVVuaWZvcm1zLnVTaXplO1xcbiAgICBsZXQgY29vcmQ6IHZlYzI8ZjMyPiA9IG1hcENvb3JkKHV2KTtcXG5cXG4gICAgLy8gZ2V0IHRoZSByb3VuZGVkIGNvbG9yLi5cXG4gICAgdmFyIHBpeENvb3JkOiB2ZWMyPGYzMj4gPSBwaXhlbGF0ZShjb29yZCwgdmVjMjxmMzI+KHBpeGVsU2l6ZSkpO1xcbiAgICBwaXhDb29yZCA9IHVubWFwQ29vcmQocGl4Q29vcmQpO1xcblxcbiAgICB2YXIgY29sb3IgPSB0ZXh0dXJlU2FtcGxlKHVUZXh0dXJlLCB1U2FtcGxlciwgcGl4Q29vcmQpO1xcblxcbiAgICAvLyBkZXRlcm1pbmUgdGhlIGNoYXJhY3RlciB0byB1c2VcXG4gICAgbGV0IGdyYXk6IGYzMiA9IDAuMyAqIGNvbG9yLnIgKyAwLjU5ICogY29sb3IuZyArIDAuMTEgKiBjb2xvci5iO1xcbiAgICBcXG4gICAgdmFyIG46IGYzMiA9IDY1NTM2LjA7IC8vIC5cXG4gICAgaWYgKGdyYXkgPiAwLjIpIHtcXG4gICAgICAgIG4gPSA2NTYwMC4wOyAgICAvLyA6XFxuICAgIH1cXG4gICAgaWYgKGdyYXkgPiAwLjMpIHtcXG4gICAgICAgIG4gPSAzMzI3NzIuMDsgICAvLyAqXFxuICAgIH1cXG4gICAgaWYgKGdyYXkgPiAwLjQpIHtcXG4gICAgICAgIG4gPSAxNTI1NTA4Ni4wOyAvLyBvXFxuICAgIH1cXG4gICAgaWYgKGdyYXkgPiAwLjUpIHtcXG4gICAgICAgIG4gPSAyMzM4NTE2NC4wOyAvLyAmXFxuICAgIH1cXG4gICAgaWYgKGdyYXkgPiAwLjYpIHtcXG4gICAgICAgIG4gPSAxNTI1MjAxNC4wOyAvLyA4XFxuICAgIH1cXG4gICAgaWYgKGdyYXkgPiAwLjcpIHtcXG4gICAgICAgIG4gPSAxMzE5OTQ1Mi4wOyAvLyBAXFxuICAgIH1cXG4gICAgaWYgKGdyYXkgPiAwLjgpIHtcXG4gICAgICAgIG4gPSAxMTUxMjgxMC4wOyAvLyAjXFxuICAgIH1cXG5cXG4gICAgLy8gZ2V0IHRoZSBtb2QuLlxcbiAgICBsZXQgbW9kZDogdmVjMjxmMzI+ID0gZ2V0TW9kKGNvb3JkLCB2ZWMyPGYzMj4ocGl4ZWxTaXplKSk7XFxuICAgIHJldHVybiBzZWxlY3QoY29sb3IsIHZlYzQ8ZjMyPihhc2NpaVVuaWZvcm1zLnVDb2xvciwgMS4pLCBhc2NpaVVuaWZvcm1zLnVSZXBsYWNlQ29sb3IgPiAwLjUpICogY2hhcmFjdGVyKG4sIHZlYzI8ZjMyPigtMS4wKSArIG1vZGQgKiAyLjApO1xcbn1cXG5cXG5mbiBwaXhlbGF0ZShjb29yZDogdmVjMjxmMzI+LCBzaXplOiB2ZWMyPGYzMj4pIC0+IHZlYzI8ZjMyPlxcbntcXG4gICAgcmV0dXJuIGZsb29yKCBjb29yZCAvIHNpemUgKSAqIHNpemU7XFxufVxcblxcbmZuIGdldE1vZChjb29yZDogdmVjMjxmMzI+LCBzaXplOiB2ZWMyPGYzMj4pIC0+IHZlYzI8ZjMyPlxcbntcXG4gICAgcmV0dXJuIG1vZHVsb1ZlYzIoIGNvb3JkICwgc2l6ZSkgLyBzaXplO1xcbn1cXG5cXG5mbiBjaGFyYWN0ZXIobjogZjMyLCBwOiB2ZWMyPGYzMj4pIC0+IGYzMlxcbntcXG4gICAgdmFyIHE6IHZlYzI8ZjMyPiA9IGZsb29yKHAqdmVjMjxmMzI+KDQuMCwgNC4wKSArIDIuNSk7XFxuXFxuICAgIGlmIChjbGFtcChxLngsIDAuMCwgNC4wKSA9PSBxLngpXFxuICAgIHtcXG4gICAgICAgIGlmIChjbGFtcChxLnksIDAuMCwgNC4wKSA9PSBxLnkpXFxuICAgICAgICB7XFxuICAgICAgICBpZiAoaTMyKG1vZHVsbyhuL2V4cDIocS54ICsgNS4wKnEueSksIDIuMCkpID09IDEpXFxuICAgICAgICB7XFxuICAgICAgICAgICAgcmV0dXJuIDEuMDtcXG4gICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgfVxcblxcbiAgICByZXR1cm4gMC4wO1xcbn1cXG5cXG5mbiBtb2R1bG8oeDogZjMyLCB5OiBmMzIpIC0+IGYzMlxcbntcXG4gIHJldHVybiB4IC0geSAqIGZsb29yKHgveSk7XFxufVxcblxcbmZuIG1vZHVsb1ZlYzIoeDogdmVjMjxmMzI+LCB5OiB2ZWMyPGYzMj4pIC0+IHZlYzI8ZjMyPlxcbntcXG4gIHJldHVybiB4IC0geSAqIGZsb29yKHgveSk7XFxufVxcblxcbmZuIG1hcENvb3JkKGNvb3JkOiB2ZWMyPGYzMj4gKSAtPiB2ZWMyPGYzMj5cXG57XFxuICAgIHZhciBtYXBwZWRDb29yZDogdmVjMjxmMzI+ID0gY29vcmQ7XFxuICAgIG1hcHBlZENvb3JkICo9IGdmdS51SW5wdXRTaXplLnh5O1xcbiAgICBtYXBwZWRDb29yZCArPSBnZnUudU91dHB1dEZyYW1lLnh5O1xcbiAgICByZXR1cm4gbWFwcGVkQ29vcmQ7XFxufVxcblxcbmZuIHVubWFwQ29vcmQoY29vcmQ6IHZlYzI8ZjMyPiApIC0+IHZlYzI8ZjMyPlxcbntcXG4gICAgdmFyIG1hcHBlZENvb3JkOiB2ZWMyPGYzMj4gPSBjb29yZDtcXG4gICAgbWFwcGVkQ29vcmQgLT0gZ2Z1LnVPdXRwdXRGcmFtZS54eTtcXG4gICAgbWFwcGVkQ29vcmQgLz0gZ2Z1LnVJbnB1dFNpemUueHk7XFxuICAgIHJldHVybiBtYXBwZWRDb29yZDtcXG59XCI7XG5cbmV4cG9ydCB7IHNvdXJjZSBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc2NpaS5tanMubWFwXG4iLCJ2YXIgZnJhZ21lbnQgPSBcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5pbiB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxub3V0IHZlYzQgZmluYWxDb2xvcjtcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG51bmlmb3JtIGZsb2F0IHVTaXplO1xcbnVuaWZvcm0gdmVjMyB1Q29sb3I7XFxudW5pZm9ybSBmbG9hdCB1UmVwbGFjZUNvbG9yO1xcblxcbnVuaWZvcm0gdmVjNCB1SW5wdXRTaXplO1xcblxcbnZlYzIgbWFwQ29vcmQoIHZlYzIgY29vcmQgKVxcbntcXG4gICAgY29vcmQgKj0gdUlucHV0U2l6ZS54eTtcXG4gICAgY29vcmQgKz0gdUlucHV0U2l6ZS56dztcXG5cXG4gICAgcmV0dXJuIGNvb3JkO1xcbn1cXG5cXG52ZWMyIHVubWFwQ29vcmQoIHZlYzIgY29vcmQgKVxcbntcXG4gICAgY29vcmQgLT0gdUlucHV0U2l6ZS56dztcXG4gICAgY29vcmQgLz0gdUlucHV0U2l6ZS54eTtcXG5cXG4gICAgcmV0dXJuIGNvb3JkO1xcbn1cXG5cXG52ZWMyIHBpeGVsYXRlKHZlYzIgY29vcmQsIHZlYzIgc2l6ZSlcXG57XFxuICAgIHJldHVybiBmbG9vcihjb29yZCAvIHNpemUpICogc2l6ZTtcXG59XFxuXFxudmVjMiBnZXRNb2QodmVjMiBjb29yZCwgdmVjMiBzaXplKVxcbntcXG4gICAgcmV0dXJuIG1vZChjb29yZCwgc2l6ZSkgLyBzaXplO1xcbn1cXG5cXG5mbG9hdCBjaGFyYWN0ZXIoZmxvYXQgbiwgdmVjMiBwKVxcbntcXG4gICAgcCA9IGZsb29yKHAqdmVjMig0LjAsIDQuMCkgKyAyLjUpO1xcblxcbiAgICBpZiAoY2xhbXAocC54LCAwLjAsIDQuMCkgPT0gcC54KVxcbiAgICB7XFxuICAgICAgICBpZiAoY2xhbXAocC55LCAwLjAsIDQuMCkgPT0gcC55KVxcbiAgICAgICAge1xcbiAgICAgICAgICAgIGlmIChpbnQobW9kKG4vZXhwMihwLnggKyA1LjAqcC55KSwgMi4wKSkgPT0gMSkgcmV0dXJuIDEuMDtcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICByZXR1cm4gMC4wO1xcbn1cXG5cXG52b2lkIG1haW4oKVxcbntcXG4gICAgdmVjMiBjb29yZCA9IG1hcENvb3JkKHZUZXh0dXJlQ29vcmQpO1xcblxcbiAgICAvLyBnZXQgdGhlIGdyaWQgcG9zaXRpb25cXG4gICAgdmVjMiBwaXhDb29yZCA9IHBpeGVsYXRlKGNvb3JkLCB2ZWMyKHVTaXplKSk7XFxuICAgIHBpeENvb3JkID0gdW5tYXBDb29yZChwaXhDb29yZCk7XFxuXFxuICAgIC8vIHNhbXBsZSB0aGUgY29sb3IgYXQgZ3JpZCBwb3NpdGlvblxcbiAgICB2ZWM0IGNvbG9yID0gdGV4dHVyZSh1VGV4dHVyZSwgcGl4Q29vcmQpO1xcblxcbiAgICAvLyBicmlnaHRuZXNzIG9mIHRoZSBjb2xvciBhcyBpdCdzIHBlcmNlaXZlZCBieSB0aGUgaHVtYW4gZXllXFxuICAgIGZsb2F0IGdyYXkgPSAwLjMgKiBjb2xvci5yICsgMC41OSAqIGNvbG9yLmcgKyAwLjExICogY29sb3IuYjtcXG5cXG4gICAgLy8gZGV0ZXJtaW5lIHRoZSBjaGFyYWN0ZXIgdG8gdXNlXFxuICAgIGZsb2F0IG4gPSAgNjU1MzYuMDsgICAgICAgICAgICAgLy8gLlxcbiAgICBpZiAoZ3JheSA+IDAuMikgbiA9IDY1NjAwLjA7ICAgIC8vIDpcXG4gICAgaWYgKGdyYXkgPiAwLjMpIG4gPSAzMzI3NzIuMDsgICAvLyAqXFxuICAgIGlmIChncmF5ID4gMC40KSBuID0gMTUyNTUwODYuMDsgLy8gb1xcbiAgICBpZiAoZ3JheSA+IDAuNSkgbiA9IDIzMzg1MTY0LjA7IC8vICZcXG4gICAgaWYgKGdyYXkgPiAwLjYpIG4gPSAxNTI1MjAxNC4wOyAvLyA4XFxuICAgIGlmIChncmF5ID4gMC43KSBuID0gMTMxOTk0NTIuMDsgLy8gQFxcbiAgICBpZiAoZ3JheSA+IDAuOCkgbiA9IDExNTEyODEwLjA7IC8vICNcXG5cXG4gICAgLy8gZ2V0IHRoZSBtb2QuLlxcbiAgICB2ZWMyIG1vZGQgPSBnZXRNb2QoY29vcmQsIHZlYzIodVNpemUpKTtcXG5cXG4gICAgZmluYWxDb2xvciA9ICh1UmVwbGFjZUNvbG9yID4gMC41ID8gdmVjNCh1Q29sb3IsIDEuKSA6IGNvbG9yKSAqIGNoYXJhY3RlciggbiwgdmVjMigtMS4wKSArIG1vZGQgKiAyLjApO1xcbn1cXG5cIjtcblxuZXhwb3J0IHsgZnJhZ21lbnQgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXNjaWkyLm1qcy5tYXBcbiIsImltcG9ydCB7IEJsdXJGaWx0ZXIsIEZpbHRlciwgR3B1UHJvZ3JhbSwgR2xQcm9ncmFtLCBUZXh0dXJlLCBUZXh0dXJlUG9vbCB9IGZyb20gJ3BpeGkuanMnO1xuaW1wb3J0IHZlcnRleCBmcm9tICcuLi9kZWZhdWx0cy9kZWZhdWx0Mi5tanMnO1xuaW1wb3J0IHdnc2xWZXJ0ZXggZnJvbSAnLi4vZGVmYXVsdHMvZGVmYXVsdC5tanMnO1xuaW1wb3J0IGZyYWdtZW50IGZyb20gJy4vYmFja2Ryb3AtYmx1ci1ibGVuZC5tanMnO1xuaW1wb3J0IHdnc2xGcmFnbWVudCBmcm9tICcuL2JhY2tkcm9wLWJsdXItYmxlbmQyLm1qcyc7XG5cbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbmNsYXNzIEJhY2tkcm9wQmx1ckZpbHRlciBleHRlbmRzIEJsdXJGaWx0ZXIge1xuICAvKipcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBvZiB0aGUgYmx1ciBmaWx0ZXIuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9ibGVuZFBhc3NcIik7XG4gICAgdGhpcy5ibGVuZFJlcXVpcmVkID0gdHJ1ZTtcbiAgICB0aGlzLnBhZGRpbmcgPSAwO1xuICAgIHRoaXMuX2JsZW5kUGFzcyA9IG5ldyBGaWx0ZXIoe1xuICAgICAgZ3B1UHJvZ3JhbTogR3B1UHJvZ3JhbS5mcm9tKHtcbiAgICAgICAgdmVydGV4OiB7XG4gICAgICAgICAgc291cmNlOiB3Z3NsVmVydGV4LFxuICAgICAgICAgIGVudHJ5UG9pbnQ6IFwibWFpblZlcnRleFwiXG4gICAgICAgIH0sXG4gICAgICAgIGZyYWdtZW50OiB7XG4gICAgICAgICAgc291cmNlOiB3Z3NsRnJhZ21lbnQsXG4gICAgICAgICAgZW50cnlQb2ludDogXCJtYWluRnJhZ21lbnRcIlxuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIGdsUHJvZ3JhbTogR2xQcm9ncmFtLmZyb20oe1xuICAgICAgICB2ZXJ0ZXgsXG4gICAgICAgIGZyYWdtZW50LFxuICAgICAgICBuYW1lOiBcImRyb3Atc2hhZG93LWZpbHRlclwiXG4gICAgICB9KSxcbiAgICAgIHJlc291cmNlczoge1xuICAgICAgICB1QmFja2dyb3VuZDogVGV4dHVyZS5FTVBUWVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBPdmVycmlkZSBleGlzdGluZyBhcHBseSBtZXRob2QgaW4gYEZpbHRlcmBcbiAgICogQG92ZXJyaWRlXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGFwcGx5KGZpbHRlck1hbmFnZXIsIGlucHV0LCBvdXRwdXQsIGNsZWFyTW9kZSkge1xuICAgIGNvbnN0IGJhY2tUZXh0dXJlID0gZmlsdGVyTWFuYWdlci5fYWN0aXZlRmlsdGVyRGF0YS5iYWNrVGV4dHVyZTtcbiAgICBjb25zdCBibHVycmVkQmFja2dyb3VuZCA9IFRleHR1cmVQb29sLmdldFNhbWVTaXplVGV4dHVyZShpbnB1dCk7XG4gICAgc3VwZXIuYXBwbHkoZmlsdGVyTWFuYWdlciwgYmFja1RleHR1cmUsIGJsdXJyZWRCYWNrZ3JvdW5kLCB0cnVlKTtcbiAgICB0aGlzLl9ibGVuZFBhc3MucmVzb3VyY2VzLnVCYWNrZ3JvdW5kID0gYmx1cnJlZEJhY2tncm91bmQuc291cmNlO1xuICAgIHRoaXMuX2JsZW5kUGFzcy5hcHBseShmaWx0ZXJNYW5hZ2VyLCBpbnB1dCwgb3V0cHV0LCBjbGVhck1vZGUpO1xuICAgIFRleHR1cmVQb29sLnJldHVyblRleHR1cmUoYmx1cnJlZEJhY2tncm91bmQpO1xuICB9XG4gIHVwZGF0ZVBhZGRpbmcoKSB7XG4gICAgdGhpcy5wYWRkaW5nID0gMDtcbiAgfVxufVxuXG5leHBvcnQgeyBCYWNrZHJvcEJsdXJGaWx0ZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJhY2tkcm9wQmx1ckZpbHRlci5tanMubWFwXG4iLCJpbXBvcnQgeyBGaWx0ZXIsIEdwdVByb2dyYW0sIEdsUHJvZ3JhbSwgQ29sb3IsIERFR19UT19SQUQgfSBmcm9tICdwaXhpLmpzJztcbmltcG9ydCB2ZXJ0ZXggZnJvbSAnLi4vZGVmYXVsdHMvZGVmYXVsdDIubWpzJztcbmltcG9ydCB3Z3NsVmVydGV4IGZyb20gJy4uL2RlZmF1bHRzL2RlZmF1bHQubWpzJztcbmltcG9ydCBmcmFnbWVudCBmcm9tICcuL2JldmVsMi5tanMnO1xuaW1wb3J0IHNvdXJjZSBmcm9tICcuL2JldmVsLm1qcyc7XG5cbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbmNvbnN0IF9CZXZlbEZpbHRlciA9IGNsYXNzIF9CZXZlbEZpbHRlciBleHRlbmRzIEZpbHRlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIHRoZSBCZXZlbEZpbHRlciBjb25zdHJ1Y3Rvci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0geyAuLi5fQmV2ZWxGaWx0ZXIuREVGQVVMVF9PUFRJT05TLCAuLi5vcHRpb25zIH07XG4gICAgY29uc3QgZ3B1UHJvZ3JhbSA9IEdwdVByb2dyYW0uZnJvbSh7XG4gICAgICB2ZXJ0ZXg6IHtcbiAgICAgICAgc291cmNlOiB3Z3NsVmVydGV4LFxuICAgICAgICBlbnRyeVBvaW50OiBcIm1haW5WZXJ0ZXhcIlxuICAgICAgfSxcbiAgICAgIGZyYWdtZW50OiB7XG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgZW50cnlQb2ludDogXCJtYWluRnJhZ21lbnRcIlxuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGdsUHJvZ3JhbSA9IEdsUHJvZ3JhbS5mcm9tKHtcbiAgICAgIHZlcnRleCxcbiAgICAgIGZyYWdtZW50LFxuICAgICAgbmFtZTogXCJiZXZlbC1maWx0ZXJcIlxuICAgIH0pO1xuICAgIHN1cGVyKHtcbiAgICAgIGdwdVByb2dyYW0sXG4gICAgICBnbFByb2dyYW0sXG4gICAgICByZXNvdXJjZXM6IHtcbiAgICAgICAgYmV2ZWxVbmlmb3Jtczoge1xuICAgICAgICAgIHVMaWdodENvbG9yOiB7IHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KDMpLCB0eXBlOiBcInZlYzM8ZjMyPlwiIH0sXG4gICAgICAgICAgdUxpZ2h0QWxwaGE6IHsgdmFsdWU6IG9wdGlvbnMubGlnaHRBbHBoYSwgdHlwZTogXCJmMzJcIiB9LFxuICAgICAgICAgIHVTaGFkb3dDb2xvcjogeyB2YWx1ZTogbmV3IEZsb2F0MzJBcnJheSgzKSwgdHlwZTogXCJ2ZWMzPGYzMj5cIiB9LFxuICAgICAgICAgIHVTaGFkb3dBbHBoYTogeyB2YWx1ZTogb3B0aW9ucy5zaGFkb3dBbHBoYSwgdHlwZTogXCJmMzJcIiB9LFxuICAgICAgICAgIHVUcmFuc2Zvcm06IHsgdmFsdWU6IG5ldyBGbG9hdDMyQXJyYXkoMiksIHR5cGU6IFwidmVjMjxmMzI+XCIgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gV29ya2Fyb3VuZDogaHR0cHM6Ly9naXRodWIuY29tL3BpeGlqcy9maWx0ZXJzL2lzc3Vlcy8yMzBcbiAgICAgIC8vIGFwcGxpZXMgY29ycmVjdGx5IG9ubHkgaWYgdGhlcmUgaXMgYXQgbGVhc3QgYSBzaW5nbGUtcGl4ZWwgcGFkZGluZyB3aXRoIGFscGhhPTAgYXJvdW5kIGFuIGltYWdlXG4gICAgICAvLyBUbyBzb2x2ZSB0aGlzIHByb2JsZW0sIGEgcGFkZGluZyBvZiAxIHB1dCBvbiB0aGUgZmlsdGVyIHNob3VsZCBzdWZmaWNlXG4gICAgICBwYWRkaW5nOiAxXG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInVuaWZvcm1zXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfdGhpY2tuZXNzXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfcm90YXRpb25cIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9saWdodENvbG9yXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfc2hhZG93Q29sb3JcIik7XG4gICAgdGhpcy51bmlmb3JtcyA9IHRoaXMucmVzb3VyY2VzLmJldmVsVW5pZm9ybXMudW5pZm9ybXM7XG4gICAgdGhpcy5fbGlnaHRDb2xvciA9IG5ldyBDb2xvcigpO1xuICAgIHRoaXMuX3NoYWRvd0NvbG9yID0gbmV3IENvbG9yKCk7XG4gICAgdGhpcy5saWdodENvbG9yID0gb3B0aW9ucy5saWdodENvbG9yID8/IDE2Nzc3MjE1O1xuICAgIHRoaXMuc2hhZG93Q29sb3IgPSBvcHRpb25zLnNoYWRvd0NvbG9yID8/IDA7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogVGhlIGFuZ2xlIG9mIHRoZSBsaWdodCBpbiBkZWdyZWVzXG4gICAqIEBkZWZhdWx0IDQ1XG4gICAqL1xuICBnZXQgcm90YXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JvdGF0aW9uIC8gREVHX1RPX1JBRDtcbiAgfVxuICBzZXQgcm90YXRpb24odmFsdWUpIHtcbiAgICB0aGlzLl9yb3RhdGlvbiA9IHZhbHVlICogREVHX1RPX1JBRDtcbiAgICB0aGlzLl91cGRhdGVUcmFuc2Zvcm0oKTtcbiAgfVxuICAvKipcbiAgICogVGhlIHRoaWNrbmVzcyBvZiB0aGUgYmV2ZWxcbiAgICogQGRlZmF1bHQgMlxuICAgKi9cbiAgZ2V0IHRoaWNrbmVzcygpIHtcbiAgICByZXR1cm4gdGhpcy5fdGhpY2tuZXNzO1xuICB9XG4gIHNldCB0aGlja25lc3ModmFsdWUpIHtcbiAgICB0aGlzLl90aGlja25lc3MgPSB2YWx1ZTtcbiAgICB0aGlzLl91cGRhdGVUcmFuc2Zvcm0oKTtcbiAgfVxuICAvKipcbiAgICogVGhlIGNvbG9yIHZhbHVlIG9mIHRoZSBsZWZ0ICYgdG9wIGJldmVsLlxuICAgKiBAZXhhbXBsZSBbMS4wLCAxLjAsIDEuMF0gPSAweGZmZmZmZlxuICAgKiBAZGVmYXVsdCAweGZmZmZmZlxuICAgKi9cbiAgZ2V0IGxpZ2h0Q29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xpZ2h0Q29sb3IudmFsdWU7XG4gIH1cbiAgc2V0IGxpZ2h0Q29sb3IodmFsdWUpIHtcbiAgICB0aGlzLl9saWdodENvbG9yLnNldFZhbHVlKHZhbHVlKTtcbiAgICBjb25zdCBbciwgZywgYl0gPSB0aGlzLl9saWdodENvbG9yLnRvQXJyYXkoKTtcbiAgICB0aGlzLnVuaWZvcm1zLnVMaWdodENvbG9yWzBdID0gcjtcbiAgICB0aGlzLnVuaWZvcm1zLnVMaWdodENvbG9yWzFdID0gZztcbiAgICB0aGlzLnVuaWZvcm1zLnVMaWdodENvbG9yWzJdID0gYjtcbiAgfVxuICAvKipcbiAgICogVGhlIGFscGhhIHZhbHVlIG9mIHRoZSBsZWZ0ICYgdG9wIGJldmVsLlxuICAgKiBAZGVmYXVsdCAwLjdcbiAgICovXG4gIGdldCBsaWdodEFscGhhKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnVMaWdodEFscGhhO1xuICB9XG4gIHNldCBsaWdodEFscGhhKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy51TGlnaHRBbHBoYSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgY29sb3IgdmFsdWUgb2YgdGhlIHJpZ2h0ICYgYm90dG9tIGJldmVsLlxuICAgKiBAZGVmYXVsdCAweGZmZmZmZlxuICAgKi9cbiAgZ2V0IHNoYWRvd0NvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLl9zaGFkb3dDb2xvci52YWx1ZTtcbiAgfVxuICBzZXQgc2hhZG93Q29sb3IodmFsdWUpIHtcbiAgICB0aGlzLl9zaGFkb3dDb2xvci5zZXRWYWx1ZSh2YWx1ZSk7XG4gICAgY29uc3QgW3IsIGcsIGJdID0gdGhpcy5fc2hhZG93Q29sb3IudG9BcnJheSgpO1xuICAgIHRoaXMudW5pZm9ybXMudVNoYWRvd0NvbG9yWzBdID0gcjtcbiAgICB0aGlzLnVuaWZvcm1zLnVTaGFkb3dDb2xvclsxXSA9IGc7XG4gICAgdGhpcy51bmlmb3Jtcy51U2hhZG93Q29sb3JbMl0gPSBiO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYWxwaGEgdmFsdWUgb2YgdGhlIHJpZ2h0ICYgYm90dG9tIGJldmVsLlxuICAgKiBAZGVmYXVsdCAwLjdcbiAgICovXG4gIGdldCBzaGFkb3dBbHBoYSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy51U2hhZG93QWxwaGE7XG4gIH1cbiAgc2V0IHNoYWRvd0FscGhhKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy51U2hhZG93QWxwaGEgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlIHRoZSB0cmFuc2Zvcm0gbWF0cml4IG9mIG9mZnNldCBhbmdsZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF91cGRhdGVUcmFuc2Zvcm0oKSB7XG4gICAgdGhpcy51bmlmb3Jtcy51VHJhbnNmb3JtWzBdID0gdGhpcy50aGlja25lc3MgKiBNYXRoLmNvcyh0aGlzLl9yb3RhdGlvbik7XG4gICAgdGhpcy51bmlmb3Jtcy51VHJhbnNmb3JtWzFdID0gdGhpcy50aGlja25lc3MgKiBNYXRoLnNpbih0aGlzLl9yb3RhdGlvbik7XG4gIH1cbn07XG4vKiogRGVmYXVsdCB2YWx1ZXMgZm9yIG9wdGlvbnMuICovXG5fX3B1YmxpY0ZpZWxkKF9CZXZlbEZpbHRlciwgXCJERUZBVUxUX09QVElPTlNcIiwge1xuICByb3RhdGlvbjogNDUsXG4gIHRoaWNrbmVzczogMixcbiAgbGlnaHRDb2xvcjogMTY3NzcyMTUsXG4gIGxpZ2h0QWxwaGE6IDAuNyxcbiAgc2hhZG93Q29sb3I6IDAsXG4gIHNoYWRvd0FscGhhOiAwLjdcbn0pO1xubGV0IEJldmVsRmlsdGVyID0gX0JldmVsRmlsdGVyO1xuXG5leHBvcnQgeyBCZXZlbEZpbHRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmV2ZWxGaWx0ZXIubWpzLm1hcFxuIiwidmFyIHNvdXJjZSA9IFwic3RydWN0IEJldmVsVW5pZm9ybXMge1xcbiAgdUxpZ2h0Q29sb3I6IHZlYzM8ZjMyPixcXG4gIHVMaWdodEFscGhhOiBmMzIsXFxuICB1U2hhZG93Q29sb3I6IHZlYzM8ZjMyPixcXG4gIHVTaGFkb3dBbHBoYTogZjMyLFxcbiAgdVRyYW5zZm9ybTogdmVjMjxmMzI+LFxcbn07XFxuXFxuc3RydWN0IEdsb2JhbEZpbHRlclVuaWZvcm1zIHtcXG4gIHVJbnB1dFNpemU6dmVjNDxmMzI+LFxcbiAgdUlucHV0UGl4ZWw6dmVjNDxmMzI+LFxcbiAgdUlucHV0Q2xhbXA6dmVjNDxmMzI+LFxcbiAgdU91dHB1dEZyYW1lOnZlYzQ8ZjMyPixcXG4gIHVHbG9iYWxGcmFtZTp2ZWM0PGYzMj4sXFxuICB1T3V0cHV0VGV4dHVyZTp2ZWM0PGYzMj4sXFxufTtcXG5cXG5AZ3JvdXAoMCkgQGJpbmRpbmcoMCkgdmFyPHVuaWZvcm0+IGdmdTogR2xvYmFsRmlsdGVyVW5pZm9ybXM7XFxuXFxuQGdyb3VwKDApIEBiaW5kaW5nKDEpIHZhciB1VGV4dHVyZTogdGV4dHVyZV8yZDxmMzI+OyBcXG5AZ3JvdXAoMCkgQGJpbmRpbmcoMikgdmFyIHVTYW1wbGVyOiBzYW1wbGVyO1xcbkBncm91cCgxKSBAYmluZGluZygwKSB2YXI8dW5pZm9ybT4gYmV2ZWxVbmlmb3JtcyA6IEJldmVsVW5pZm9ybXM7XFxuXFxuQGZyYWdtZW50XFxuZm4gbWFpbkZyYWdtZW50KFxcbiAgQGJ1aWx0aW4ocG9zaXRpb24pIHBvc2l0aW9uOiB2ZWM0PGYzMj4sXFxuICBAbG9jYXRpb24oMCkgdXYgOiB2ZWMyPGYzMj5cXG4pIC0+IEBsb2NhdGlvbigwKSB2ZWM0PGYzMj4ge1xcbiAgbGV0IHRyYW5zZm9ybSA9IHZlYzI8ZjMyPigxLjAgLyBnZnUudUlucHV0U2l6ZS54eSkgKiB2ZWMyPGYzMj4oYmV2ZWxVbmlmb3Jtcy51VHJhbnNmb3JtLngsIGJldmVsVW5pZm9ybXMudVRyYW5zZm9ybS55KTtcXG4gIHZhciBjb2xvcjogdmVjNDxmMzI+ID0gdGV4dHVyZVNhbXBsZSh1VGV4dHVyZSwgdVNhbXBsZXIsIHV2KTtcXG4gIGxldCBsaWdodFNhbXBsZTogZjMyID0gdGV4dHVyZVNhbXBsZSh1VGV4dHVyZSwgdVNhbXBsZXIsIHV2IC0gdHJhbnNmb3JtKS5hO1xcbiAgbGV0IHNoYWRvd1NhbXBsZTogZjMyID0gdGV4dHVyZVNhbXBsZSh1VGV4dHVyZSwgdVNhbXBsZXIsIHV2ICsgdHJhbnNmb3JtKS5hO1xcblxcbiAgbGV0IGxpZ2h0ID0gdmVjNDxmMzI+KGJldmVsVW5pZm9ybXMudUxpZ2h0Q29sb3IsIGJldmVsVW5pZm9ybXMudUxpZ2h0QWxwaGEpO1xcbiAgbGV0IHNoYWRvdyA9IHZlYzQ8ZjMyPihiZXZlbFVuaWZvcm1zLnVTaGFkb3dDb2xvciwgYmV2ZWxVbmlmb3Jtcy51U2hhZG93QWxwaGEpO1xcblxcbiAgY29sb3IgPSB2ZWM0PGYzMj4obWl4KGNvbG9yLnJnYiwgbGlnaHQucmdiLCBjbGFtcCgoY29sb3IuYSAtIGxpZ2h0U2FtcGxlKSAqIGxpZ2h0LmEsIDAuMCwgMS4wKSksIGNvbG9yLmEpO1xcbiAgY29sb3IgPSB2ZWM0PGYzMj4obWl4KGNvbG9yLnJnYiwgc2hhZG93LnJnYiwgY2xhbXAoKGNvbG9yLmEgLSBzaGFkb3dTYW1wbGUpICogc2hhZG93LmEsIDAuMCwgMS4wKSksIGNvbG9yLmEpO1xcbiAgXFxuICByZXR1cm4gdmVjNDxmMzI+KGNvbG9yLnJnYiAqIGNvbG9yLmEsIGNvbG9yLmEpO1xcbn1cIjtcblxuZXhwb3J0IHsgc291cmNlIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJldmVsLm1qcy5tYXBcbiIsInZhciBmcmFnbWVudCA9IFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbmluIHZlYzIgdlRleHR1cmVDb29yZDtcXG5vdXQgdmVjNCBmaW5hbENvbG9yO1xcblxcbnVuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbnVuaWZvcm0gdmVjMiB1VHJhbnNmb3JtO1xcbnVuaWZvcm0gdmVjMyB1TGlnaHRDb2xvcjtcXG51bmlmb3JtIGZsb2F0IHVMaWdodEFscGhhO1xcbnVuaWZvcm0gdmVjMyB1U2hhZG93Q29sb3I7XFxudW5pZm9ybSBmbG9hdCB1U2hhZG93QWxwaGE7XFxuXFxudW5pZm9ybSB2ZWM0IHVJbnB1dFNpemU7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gICAgdmVjMiB0cmFuc2Zvcm0gPSB2ZWMyKDEuMCAvIHVJbnB1dFNpemUpICogdmVjMih1VHJhbnNmb3JtLngsIHVUcmFuc2Zvcm0ueSk7XFxuICAgIHZlYzQgY29sb3IgPSB0ZXh0dXJlKHVUZXh0dXJlLCB2VGV4dHVyZUNvb3JkKTtcXG4gICAgZmxvYXQgbGlnaHQgPSB0ZXh0dXJlKHVUZXh0dXJlLCB2VGV4dHVyZUNvb3JkIC0gdHJhbnNmb3JtKS5hO1xcbiAgICBmbG9hdCBzaGFkb3cgPSB0ZXh0dXJlKHVUZXh0dXJlLCB2VGV4dHVyZUNvb3JkICsgdHJhbnNmb3JtKS5hO1xcblxcbiAgICBjb2xvci5yZ2IgPSBtaXgoY29sb3IucmdiLCB1TGlnaHRDb2xvciwgY2xhbXAoKGNvbG9yLmEgLSBsaWdodCkgKiB1TGlnaHRBbHBoYSwgMC4wLCAxLjApKTtcXG4gICAgY29sb3IucmdiID0gbWl4KGNvbG9yLnJnYiwgdVNoYWRvd0NvbG9yLCBjbGFtcCgoY29sb3IuYSAtIHNoYWRvdykgKiB1U2hhZG93QWxwaGEsIDAuMCwgMS4wKSk7XFxuICAgIGZpbmFsQ29sb3IgPSB2ZWM0KGNvbG9yLnJnYiAqIGNvbG9yLmEsIGNvbG9yLmEpO1xcbn1cXG5cIjtcblxuZXhwb3J0IHsgZnJhZ21lbnQgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmV2ZWwyLm1qcy5tYXBcbiIsImltcG9ydCB7IEFscGhhRmlsdGVyLCBkZXByZWNhdGlvbiwgQmx1ckZpbHRlclBhc3MsIFRleHR1cmVQb29sIH0gZnJvbSAncGl4aS5qcyc7XG5cbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbmNvbnN0IF9CbG9vbUZpbHRlciA9IGNsYXNzIF9CbG9vbUZpbHRlciBleHRlbmRzIEFscGhhRmlsdGVyIHtcbiAgLyoqIEBpZ25vcmUgKi9cbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIGxldCBvcHRpb25zID0gYXJnc1swXSA/PyB7fTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwibnVtYmVyXCIgfHwgQXJyYXkuaXNBcnJheShvcHRpb25zKSB8fCBcInhcIiBpbiBvcHRpb25zICYmIFwieVwiIGluIG9wdGlvbnMpIHtcbiAgICAgIGRlcHJlY2F0aW9uKFwiNi4wLjBcIiwgXCJCbG9vbUZpbHRlciBjb25zdHJ1Y3RvciBwYXJhbXMgYXJlIG5vdyBvcHRpb25zIG9iamVjdC4gU2VlIHBhcmFtczogeyBzdHJlbmd0aCwgcXVhbGl0eSwgcmVzb2x1dGlvbiwga2VybmVsU2l6ZSB9XCIpO1xuICAgICAgbGV0IHN0cmVuZ3RoID0gb3B0aW9ucztcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHN0cmVuZ3RoKSlcbiAgICAgICAgc3RyZW5ndGggPSB7IHg6IHN0cmVuZ3RoWzBdLCB5OiBzdHJlbmd0aFsxXSB9O1xuICAgICAgb3B0aW9ucyA9IHsgc3RyZW5ndGggfTtcbiAgICAgIGlmIChhcmdzWzFdICE9PSB2b2lkIDApXG4gICAgICAgIG9wdGlvbnMucXVhbGl0eSA9IGFyZ3NbMV07XG4gICAgICBpZiAoYXJnc1syXSAhPT0gdm9pZCAwKVxuICAgICAgICBvcHRpb25zLnJlc29sdXRpb24gPSBhcmdzWzJdO1xuICAgICAgaWYgKGFyZ3NbM10gIT09IHZvaWQgMClcbiAgICAgICAgb3B0aW9ucy5rZXJuZWxTaXplID0gYXJnc1szXTtcbiAgICB9XG4gICAgb3B0aW9ucyA9IHsgLi4uX0Jsb29tRmlsdGVyLkRFRkFVTFRfT1BUSU9OUywgLi4ub3B0aW9ucyB9O1xuICAgIHN1cGVyKCk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9ibHVyWEZpbHRlclwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX2JsdXJZRmlsdGVyXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfc3RyZW5ndGhcIik7XG4gICAgdGhpcy5fc3RyZW5ndGggPSB7IHg6IDIsIHk6IDIgfTtcbiAgICBpZiAob3B0aW9ucy5zdHJlbmd0aCkge1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnN0cmVuZ3RoID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHRoaXMuX3N0cmVuZ3RoLnggPSBvcHRpb25zLnN0cmVuZ3RoO1xuICAgICAgICB0aGlzLl9zdHJlbmd0aC55ID0gb3B0aW9ucy5zdHJlbmd0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3N0cmVuZ3RoLnggPSBvcHRpb25zLnN0cmVuZ3RoLng7XG4gICAgICAgIHRoaXMuX3N0cmVuZ3RoLnkgPSBvcHRpb25zLnN0cmVuZ3RoLnk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2JsdXJYRmlsdGVyID0gbmV3IEJsdXJGaWx0ZXJQYXNzKHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBob3Jpem9udGFsOiB0cnVlLFxuICAgICAgc3RyZW5ndGg6IHRoaXMuc3RyZW5ndGhYXG4gICAgfSk7XG4gICAgdGhpcy5fYmx1cllGaWx0ZXIgPSBuZXcgQmx1ckZpbHRlclBhc3Moe1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhvcml6b250YWw6IGZhbHNlLFxuICAgICAgc3RyZW5ndGg6IHRoaXMuc3RyZW5ndGhZXG4gICAgfSk7XG4gICAgdGhpcy5fYmx1cllGaWx0ZXIuYmxlbmRNb2RlID0gXCJzY3JlZW5cIjtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBPdmVycmlkZSBleGlzdGluZyBhcHBseSBtZXRob2QgaW4gYEZpbHRlcmBcbiAgICogQG92ZXJyaWRlXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGFwcGx5KGZpbHRlck1hbmFnZXIsIGlucHV0LCBvdXRwdXQsIGNsZWFyKSB7XG4gICAgY29uc3QgcmVuZGVyVGFyZ2V0ID0gVGV4dHVyZVBvb2wuZ2V0U2FtZVNpemVUZXh0dXJlKGlucHV0KTtcbiAgICBmaWx0ZXJNYW5hZ2VyLmFwcGx5RmlsdGVyKHRoaXMsIGlucHV0LCBvdXRwdXQsIGNsZWFyKTtcbiAgICB0aGlzLl9ibHVyWEZpbHRlci5hcHBseShmaWx0ZXJNYW5hZ2VyLCBpbnB1dCwgcmVuZGVyVGFyZ2V0LCB0cnVlKTtcbiAgICB0aGlzLl9ibHVyWUZpbHRlci5hcHBseShmaWx0ZXJNYW5hZ2VyLCByZW5kZXJUYXJnZXQsIG91dHB1dCwgZmFsc2UpO1xuICAgIFRleHR1cmVQb29sLnJldHVyblRleHR1cmUocmVuZGVyVGFyZ2V0KTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgc3RyZW5ndGggb2YgYm90aCB0aGUgYmx1clggYW5kIGJsdXJZIHByb3BlcnRpZXMgc2ltdWx0YW5lb3VzbHlcbiAgICogQGRlZmF1bHQgMlxuICAgKi9cbiAgZ2V0IHN0cmVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLl9zdHJlbmd0aDtcbiAgfVxuICBzZXQgc3RyZW5ndGgodmFsdWUpIHtcbiAgICB0aGlzLl9zdHJlbmd0aCA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiA/IHsgeDogdmFsdWUsIHk6IHZhbHVlIH0gOiB2YWx1ZTtcbiAgICB0aGlzLl91cGRhdGVTdHJlbmd0aCgpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzdHJlbmd0aCBvZiB0aGUgYmx1ciBvbiB0aGUgYHhgIGF4aXNcbiAgICogQGRlZmF1bHQgMlxuICAgKi9cbiAgZ2V0IHN0cmVuZ3RoWCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJlbmd0aC54O1xuICB9XG4gIHNldCBzdHJlbmd0aFgodmFsdWUpIHtcbiAgICB0aGlzLnN0cmVuZ3RoLnggPSB2YWx1ZTtcbiAgICB0aGlzLl91cGRhdGVTdHJlbmd0aCgpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzdHJlbmd0aCBvZiB0aGUgYmx1ciBvbiB0aGUgYHlgIGF4aXNcbiAgICogQGRlZmF1bHQgMlxuICAgKi9cbiAgZ2V0IHN0cmVuZ3RoWSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJlbmd0aC55O1xuICB9XG4gIHNldCBzdHJlbmd0aFkodmFsdWUpIHtcbiAgICB0aGlzLnN0cmVuZ3RoLnkgPSB2YWx1ZTtcbiAgICB0aGlzLl91cGRhdGVTdHJlbmd0aCgpO1xuICB9XG4gIF91cGRhdGVTdHJlbmd0aCgpIHtcbiAgICB0aGlzLl9ibHVyWEZpbHRlci5ibHVyID0gdGhpcy5zdHJlbmd0aFg7XG4gICAgdGhpcy5fYmx1cllGaWx0ZXIuYmx1ciA9IHRoaXMuc3RyZW5ndGhZO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSA2LjAuMFxuICAgKlxuICAgKiBUaGUgc3RyZW5ndGggb2YgYm90aCB0aGUgYmx1clggYW5kIGJsdXJZIHByb3BlcnRpZXMgc2ltdWx0YW5lb3VzbHlcbiAgICogQGRlZmF1bHQgMlxuICAgKiBAc2VlIEJsb29tRmlsdGVyI3N0cmVuZ3RoXG4gICAqL1xuICBnZXQgYmx1cigpIHtcbiAgICBkZXByZWNhdGlvbihcIjYuMC4wXCIsIFwiQmxvb21GaWx0ZXIuYmx1ciBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIEJsb29tRmlsdGVyLnN0cmVuZ3RoIGluc3RlYWRcIik7XG4gICAgcmV0dXJuIHRoaXMuc3RyZW5ndGhYO1xuICB9XG4gIHNldCBibHVyKHZhbHVlKSB7XG4gICAgZGVwcmVjYXRpb24oXCI2LjAuMFwiLCBcIkJsb29tRmlsdGVyLmJsdXIgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBCbG9vbUZpbHRlci5zdHJlbmd0aCBpbnN0ZWFkXCIpO1xuICAgIHRoaXMuc3RyZW5ndGggPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgNi4wLjBcbiAgICpcbiAgICogVGhlIHN0cmVuZ3RoIG9mIHRoZSBibHVyWCBwcm9wZXJ0eVxuICAgKiBAZGVmYXVsdCAyXG4gICAqIEBzZWUgQmxvb21GaWx0ZXIjc3RyZW5ndGhYXG4gICAqL1xuICBnZXQgYmx1clgoKSB7XG4gICAgZGVwcmVjYXRpb24oXCI2LjAuMFwiLCBcIkJsb29tRmlsdGVyLmJsdXJYIGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgQmxvb21GaWx0ZXIuc3RyZW5ndGhYIGluc3RlYWRcIik7XG4gICAgcmV0dXJuIHRoaXMuc3RyZW5ndGhYO1xuICB9XG4gIHNldCBibHVyWCh2YWx1ZSkge1xuICAgIGRlcHJlY2F0aW9uKFwiNi4wLjBcIiwgXCJCbG9vbUZpbHRlci5ibHVyWCBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIEJsb29tRmlsdGVyLnN0cmVuZ3RoWCBpbnN0ZWFkXCIpO1xuICAgIHRoaXMuc3RyZW5ndGhYID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIDYuMC4wXG4gICAqXG4gICAqIFRoZSBzdHJlbmd0aCBvZiB0aGUgYmx1clkgcHJvcGVydHlcbiAgICogQGRlZmF1bHQgMlxuICAgKiBAc2VlIEJsb29tRmlsdGVyI3N0cmVuZ3RoWVxuICAgKi9cbiAgZ2V0IGJsdXJZKCkge1xuICAgIGRlcHJlY2F0aW9uKFwiNi4wLjBcIiwgXCJCbG9vbUZpbHRlci5ibHVyWSBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIEJsb29tRmlsdGVyLnN0cmVuZ3RoWSBpbnN0ZWFkXCIpO1xuICAgIHJldHVybiB0aGlzLnN0cmVuZ3RoWTtcbiAgfVxuICBzZXQgYmx1clkodmFsdWUpIHtcbiAgICBkZXByZWNhdGlvbihcIjYuMC4wXCIsIFwiQmxvb21GaWx0ZXIuYmx1clkgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBCbG9vbUZpbHRlci5zdHJlbmd0aFkgaW5zdGVhZFwiKTtcbiAgICB0aGlzLnN0cmVuZ3RoWSA9IHZhbHVlO1xuICB9XG59O1xuLyoqIERlZmF1bHQgdmFsdWVzIGZvciBvcHRpb25zLiAqL1xuX19wdWJsaWNGaWVsZChfQmxvb21GaWx0ZXIsIFwiREVGQVVMVF9PUFRJT05TXCIsIHtcbiAgc3RyZW5ndGg6IHsgeDogMiwgeTogMiB9LFxuICBxdWFsaXR5OiA0LFxuICByZXNvbHV0aW9uOiAxLFxuICBrZXJuZWxTaXplOiA1XG59KTtcbmxldCBCbG9vbUZpbHRlciA9IF9CbG9vbUZpbHRlcjtcblxuZXhwb3J0IHsgQmxvb21GaWx0ZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJsb29tRmlsdGVyLm1qcy5tYXBcbiIsImltcG9ydCB7IEZpbHRlciwgR3B1UHJvZ3JhbSwgR2xQcm9ncmFtIH0gZnJvbSAncGl4aS5qcyc7XG5pbXBvcnQgdmVydGV4IGZyb20gJy4uL2RlZmF1bHRzL2RlZmF1bHQyLm1qcyc7XG5pbXBvcnQgd2dzbFZlcnRleCBmcm9tICcuLi9kZWZhdWx0cy9kZWZhdWx0Lm1qcyc7XG5pbXBvcnQgZnJhZ21lbnQgZnJvbSAnLi9idWxnZS1waW5jaDIubWpzJztcbmltcG9ydCBzb3VyY2UgZnJvbSAnLi9idWxnZS1waW5jaC5tanMnO1xuXG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiB7XG4gIF9fZGVmTm9ybWFsUHJvcChvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5jb25zdCBfQnVsZ2VQaW5jaEZpbHRlciA9IGNsYXNzIF9CdWxnZVBpbmNoRmlsdGVyIGV4dGVuZHMgRmlsdGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgdGhlIEJ1bGdlUGluY2hGaWx0ZXIgY29uc3RydWN0b3IuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHsgLi4uX0J1bGdlUGluY2hGaWx0ZXIuREVGQVVMVF9PUFRJT05TLCAuLi5vcHRpb25zIH07XG4gICAgY29uc3QgZ3B1UHJvZ3JhbSA9IEdwdVByb2dyYW0uZnJvbSh7XG4gICAgICB2ZXJ0ZXg6IHtcbiAgICAgICAgc291cmNlOiB3Z3NsVmVydGV4LFxuICAgICAgICBlbnRyeVBvaW50OiBcIm1haW5WZXJ0ZXhcIlxuICAgICAgfSxcbiAgICAgIGZyYWdtZW50OiB7XG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgZW50cnlQb2ludDogXCJtYWluRnJhZ21lbnRcIlxuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGdsUHJvZ3JhbSA9IEdsUHJvZ3JhbS5mcm9tKHtcbiAgICAgIHZlcnRleCxcbiAgICAgIGZyYWdtZW50LFxuICAgICAgbmFtZTogXCJidWxnZS1waW5jaC1maWx0ZXJcIlxuICAgIH0pO1xuICAgIHN1cGVyKHtcbiAgICAgIGdwdVByb2dyYW0sXG4gICAgICBnbFByb2dyYW0sXG4gICAgICByZXNvdXJjZXM6IHtcbiAgICAgICAgYnVsZ2VQaW5jaFVuaWZvcm1zOiB7XG4gICAgICAgICAgdURpbWVuc2lvbnM6IHsgdmFsdWU6IFswLCAwXSwgdHlwZTogXCJ2ZWMyPGYzMj5cIiB9LFxuICAgICAgICAgIHVDZW50ZXI6IHsgdmFsdWU6IG9wdGlvbnMuY2VudGVyLCB0eXBlOiBcInZlYzI8ZjMyPlwiIH0sXG4gICAgICAgICAgdVJhZGl1czogeyB2YWx1ZTogb3B0aW9ucy5yYWRpdXMsIHR5cGU6IFwiZjMyXCIgfSxcbiAgICAgICAgICB1U3RyZW5ndGg6IHsgdmFsdWU6IG9wdGlvbnMuc3RyZW5ndGgsIHR5cGU6IFwiZjMyXCIgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInVuaWZvcm1zXCIpO1xuICAgIHRoaXMudW5pZm9ybXMgPSB0aGlzLnJlc291cmNlcy5idWxnZVBpbmNoVW5pZm9ybXMudW5pZm9ybXM7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogT3ZlcnJpZGUgZXhpc3RpbmcgYXBwbHkgbWV0aG9kIGluIGBGaWx0ZXJgXG4gICAqIEBvdmVycmlkZVxuICAgKiBAaWdub3JlXG4gICAqL1xuICBhcHBseShmaWx0ZXJNYW5hZ2VyLCBpbnB1dCwgb3V0cHV0LCBjbGVhck1vZGUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnVEaW1lbnNpb25zWzBdID0gaW5wdXQuZnJhbWUud2lkdGg7XG4gICAgdGhpcy51bmlmb3Jtcy51RGltZW5zaW9uc1sxXSA9IGlucHV0LmZyYW1lLmhlaWdodDtcbiAgICBmaWx0ZXJNYW5hZ2VyLmFwcGx5RmlsdGVyKHRoaXMsIGlucHV0LCBvdXRwdXQsIGNsZWFyTW9kZSk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGNlbnRlciBvZiB0aGUgZWZmZWN0IGluIG5vcm1hbGl6ZWQgc2NyZWVuIGNvb3Jkcy5cbiAgICogeyB4OiAwLCB5OiAwIH0gbWVhbnMgdG9wLWxlZnQgYW5kIHsgeDogMSwgeTogMSB9IG1lYW4gYm90dG9tLXJpZ2h0XG4gICAqIEBkZWZhdWx0IHt4OjAuNSx5OjAuNX1cbiAgICovXG4gIGdldCBjZW50ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMudUNlbnRlcjtcbiAgfVxuICBzZXQgY2VudGVyKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgdmFsdWUgPSB7IHg6IHZhbHVlLCB5OiB2YWx1ZSB9O1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHZhbHVlID0geyB4OiB2YWx1ZVswXSwgeTogdmFsdWVbMV0gfTtcbiAgICB9XG4gICAgdGhpcy51bmlmb3Jtcy51Q2VudGVyID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGNlbnRlciBvZiB0aGUgZWZmZWN0IGluIG5vcm1hbGl6ZWQgc2NyZWVuIGNvb3JkcyBvbiB0aGUgYHhgIGF4aXNcbiAgICogQGRlZmF1bHQgMFxuICAgKi9cbiAgZ2V0IGNlbnRlclgoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMudUNlbnRlci54O1xuICB9XG4gIHNldCBjZW50ZXJYKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy51Q2VudGVyLnggPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgY2VudGVyIG9mIHRoZSBlZmZlY3QgaW4gbm9ybWFsaXplZCBzY3JlZW4gY29vcmRzIG9uIHRoZSBgeWAgYXhpc1xuICAgKiBAZGVmYXVsdCAwXG4gICAqL1xuICBnZXQgY2VudGVyWSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy51Q2VudGVyLnk7XG4gIH1cbiAgc2V0IGNlbnRlclkodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnVDZW50ZXIueSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgcmFkaXVzIG9mIHRoZSBjaXJjbGUgb2YgZWZmZWN0XG4gICAqIEBkZWZhdWx0IDEwMFxuICAgKi9cbiAgZ2V0IHJhZGl1cygpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy51UmFkaXVzO1xuICB9XG4gIHNldCByYWRpdXModmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnVSYWRpdXMgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogQSB2YWx1ZSBiZXR3ZWVuIC0xIGFuZCAxICgtMSBpcyBzdHJvbmcgcGluY2gsIDAgaXMgbm8gZWZmZWN0LCAxIGlzIHN0cm9uZyBidWxnZSlcbiAgICogQGRlZmF1bHQgMVxuICAgKi9cbiAgZ2V0IHN0cmVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnVTdHJlbmd0aDtcbiAgfVxuICBzZXQgc3RyZW5ndGgodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnVTdHJlbmd0aCA9IHZhbHVlO1xuICB9XG59O1xuLyoqIERlZmF1bHQgdmFsdWVzIGZvciBvcHRpb25zLiAqL1xuX19wdWJsaWNGaWVsZChfQnVsZ2VQaW5jaEZpbHRlciwgXCJERUZBVUxUX09QVElPTlNcIiwge1xuICBjZW50ZXI6IHsgeDogMC41LCB5OiAwLjUgfSxcbiAgcmFkaXVzOiAxMDAsXG4gIHN0cmVuZ3RoOiAxXG59KTtcbmxldCBCdWxnZVBpbmNoRmlsdGVyID0gX0J1bGdlUGluY2hGaWx0ZXI7XG5cbmV4cG9ydCB7IEJ1bGdlUGluY2hGaWx0ZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJ1bGdlUGluY2hGaWx0ZXIubWpzLm1hcFxuIiwidmFyIHNvdXJjZSA9IFwic3RydWN0IEJ1bGdlUGluY2hVbmlmb3JtcyB7XFxuICB1RGltZW5zaW9uczogdmVjMjxmMzI+LFxcbiAgdUNlbnRlcjogdmVjMjxmMzI+LFxcbiAgdVJhZGl1czogZjMyLFxcbiAgdVN0cmVuZ3RoOiBmMzIsXFxufTtcXG5cXG5zdHJ1Y3QgR2xvYmFsRmlsdGVyVW5pZm9ybXMge1xcbiAgdUlucHV0U2l6ZTp2ZWM0PGYzMj4sXFxuICB1SW5wdXRQaXhlbDp2ZWM0PGYzMj4sXFxuICB1SW5wdXRDbGFtcDp2ZWM0PGYzMj4sXFxuICB1T3V0cHV0RnJhbWU6dmVjNDxmMzI+LFxcbiAgdUdsb2JhbEZyYW1lOnZlYzQ8ZjMyPixcXG4gIHVPdXRwdXRUZXh0dXJlOnZlYzQ8ZjMyPixcXG59O1xcblxcbkBncm91cCgwKSBAYmluZGluZygwKSB2YXI8dW5pZm9ybT4gZ2Z1OiBHbG9iYWxGaWx0ZXJVbmlmb3JtcztcXG5cXG5AZ3JvdXAoMCkgQGJpbmRpbmcoMSkgdmFyIHVUZXh0dXJlOiB0ZXh0dXJlXzJkPGYzMj47IFxcbkBncm91cCgwKSBAYmluZGluZygyKSB2YXIgdVNhbXBsZXI6IHNhbXBsZXI7XFxuQGdyb3VwKDEpIEBiaW5kaW5nKDApIHZhcjx1bmlmb3JtPiBidWxnZVBpbmNoVW5pZm9ybXMgOiBCdWxnZVBpbmNoVW5pZm9ybXM7XFxuXFxuQGZyYWdtZW50XFxuZm4gbWFpbkZyYWdtZW50KFxcbiAgQGJ1aWx0aW4ocG9zaXRpb24pIHBvc2l0aW9uOiB2ZWM0PGYzMj4sXFxuICBAbG9jYXRpb24oMCkgdXYgOiB2ZWMyPGYzMj5cXG4pIC0+IEBsb2NhdGlvbigwKSB2ZWM0PGYzMj4ge1xcbiAgbGV0IGRpbWVuc2lvbnM6IHZlYzI8ZjMyPiA9IGJ1bGdlUGluY2hVbmlmb3Jtcy51RGltZW5zaW9ucztcXG4gIGxldCBjZW50ZXI6IHZlYzI8ZjMyPiA9IGJ1bGdlUGluY2hVbmlmb3Jtcy51Q2VudGVyO1xcbiAgbGV0IHJhZGl1czogZjMyID0gYnVsZ2VQaW5jaFVuaWZvcm1zLnVSYWRpdXM7XFxuICBsZXQgc3RyZW5ndGg6IGYzMiA9IGJ1bGdlUGluY2hVbmlmb3Jtcy51U3RyZW5ndGg7XFxuICB2YXIgY29vcmQ6IHZlYzI8ZjMyPiA9ICh1diAqIGdmdS51SW5wdXRTaXplLnh5KSAtIGNlbnRlciAqIGRpbWVuc2lvbnMueHk7XFxuXFxuICBsZXQgZGlzdGFuY2U6IGYzMiA9IGxlbmd0aChjb29yZCk7XFxuXFxuICBpZiAoZGlzdGFuY2UgPCByYWRpdXMpIHtcXG4gICAgICBsZXQgcGVyY2VudDogZjMyID0gZGlzdGFuY2UgLyByYWRpdXM7XFxuICAgICAgaWYgKHN0cmVuZ3RoID4gMC4wKSB7XFxuICAgICAgICAgIGNvb3JkICo9IG1peCgxLjAsIHNtb290aHN0ZXAoMC4wLCByYWRpdXMgLyBkaXN0YW5jZSwgcGVyY2VudCksIHN0cmVuZ3RoICogMC43NSk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgY29vcmQgKj0gbWl4KDEuMCwgcG93KHBlcmNlbnQsIDEuMCArIHN0cmVuZ3RoICogMC43NSkgKiByYWRpdXMgLyBkaXN0YW5jZSwgMS4wIC0gcGVyY2VudCk7XFxuICAgICAgfVxcbiAgfVxcbiAgICBjb29yZCArPSAoY2VudGVyICogZGltZW5zaW9ucy54eSk7XFxuICAgIGNvb3JkIC89IGdmdS51SW5wdXRTaXplLnh5O1xcblxcbiAgICBsZXQgY2xhbXBlZENvb3JkOiB2ZWMyPGYzMj4gPSBjbGFtcChjb29yZCwgZ2Z1LnVJbnB1dENsYW1wLnh5LCBnZnUudUlucHV0Q2xhbXAuencpO1xcbiAgICB2YXIgY29sb3I6IHZlYzQ8ZjMyPiA9IHRleHR1cmVTYW1wbGUodVRleHR1cmUsIHVTYW1wbGVyLCBjbGFtcGVkQ29vcmQpO1xcbiAgICBpZiAoY29vcmQueCAhPSBjbGFtcGVkQ29vcmQueCAmJiBjb29yZC55ICE9IGNsYW1wZWRDb29yZC55KSB7XFxuICAgICAgICBjb2xvciAqPSBtYXgoMC4wLCAxLjAgLSBsZW5ndGgoY29vcmQgLSBjbGFtcGVkQ29vcmQpKTtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gY29sb3I7XFxufVxcblxcbmZuIGNvbXBhcmVWZWMyKHg6IHZlYzI8ZjMyPiwgeTogdmVjMjxmMzI+KSAtPiBib29sXFxue1xcbiAgaWYgKHgueCA9PSB5LnggJiYgeC55ID09IHkueSlcXG4gIHtcXG4gICAgcmV0dXJuIHRydWU7XFxuICB9XFxuXFxuICByZXR1cm4gZmFsc2U7XFxufVwiO1xuXG5leHBvcnQgeyBzb3VyY2UgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVsZ2UtcGluY2gubWpzLm1hcFxuIiwidmFyIGZyYWdtZW50ID0gXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuaW4gdmVjMiB2VGV4dHVyZUNvb3JkO1xcbm91dCB2ZWM0IGZpbmFsQ29sb3I7XFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxudW5pZm9ybSB2ZWMyIHVEaW1lbnNpb25zO1xcbnVuaWZvcm0gdmVjMiB1Q2VudGVyO1xcbnVuaWZvcm0gZmxvYXQgdVJhZGl1cztcXG51bmlmb3JtIGZsb2F0IHVTdHJlbmd0aDtcXG5cXG51bmlmb3JtIHZlYzQgdUlucHV0U2l6ZTtcXG51bmlmb3JtIHZlYzQgdUlucHV0Q2xhbXA7XFxuXFxudm9pZCBtYWluKClcXG57XFxuICAgIHZlYzIgY29vcmQgPSB2VGV4dHVyZUNvb3JkICogdUlucHV0U2l6ZS54eTtcXG4gICAgY29vcmQgLT0gdUNlbnRlciAqIHVEaW1lbnNpb25zLnh5O1xcbiAgICBmbG9hdCBkaXN0YW5jZSA9IGxlbmd0aChjb29yZCk7XFxuXFxuICAgIGlmIChkaXN0YW5jZSA8IHVSYWRpdXMpIHtcXG4gICAgICAgIGZsb2F0IHBlcmNlbnQgPSBkaXN0YW5jZSAvIHVSYWRpdXM7XFxuICAgICAgICBpZiAodVN0cmVuZ3RoID4gMC4wKSB7XFxuICAgICAgICAgICAgY29vcmQgKj0gbWl4KDEuMCwgc21vb3Roc3RlcCgwLjAsIHVSYWRpdXMgLyBkaXN0YW5jZSwgcGVyY2VudCksIHVTdHJlbmd0aCAqIDAuNzUpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBjb29yZCAqPSBtaXgoMS4wLCBwb3cocGVyY2VudCwgMS4wICsgdVN0cmVuZ3RoICogMC43NSkgKiB1UmFkaXVzIC8gZGlzdGFuY2UsIDEuMCAtIHBlcmNlbnQpO1xcbiAgICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGNvb3JkICs9IHVDZW50ZXIgKiB1RGltZW5zaW9ucy54eTtcXG4gICAgY29vcmQgLz0gdUlucHV0U2l6ZS54eTtcXG4gICAgdmVjMiBjbGFtcGVkQ29vcmQgPSBjbGFtcChjb29yZCwgdUlucHV0Q2xhbXAueHksIHVJbnB1dENsYW1wLnp3KTtcXG4gICAgdmVjNCBjb2xvciA9IHRleHR1cmUodVRleHR1cmUsIGNsYW1wZWRDb29yZCk7XFxuXFxuICAgIGlmIChjb29yZCAhPSBjbGFtcGVkQ29vcmQpIHtcXG4gICAgICAgIGNvbG9yICo9IG1heCgwLjAsIDEuMCAtIGxlbmd0aChjb29yZCAtIGNsYW1wZWRDb29yZCkpO1xcbiAgICB9XFxuXFxuICAgIGZpbmFsQ29sb3IgPSBjb2xvcjtcXG59XFxuXCI7XG5cbmV4cG9ydCB7IGZyYWdtZW50IGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1bGdlLXBpbmNoMi5tanMubWFwXG4iLCJ2YXIgc291cmNlID0gXCJzdHJ1Y3QgQmFzZVVuaWZvcm1zIHtcXG4gIHVPcHRpb25zOiB2ZWM0PGYzMj4sXFxuICB1Q291bnRzOiB2ZWMyPGYzMj4sXFxufTtcXG5cXG5zdHJ1Y3QgU3RvcHNVbmlmb3JtcyB7XFxuICB1Q29sb3JzOiBhcnJheTx2ZWMzPGYzMj4sIE1BWF9TVE9QUz4sXFxuICB1U3RvcHM6IGFycmF5PHZlYzQ8ZjMyPiwgTUFYX1NUT1BTPixcXG59O1xcblxcbnN0cnVjdCBHbG9iYWxGaWx0ZXJVbmlmb3JtcyB7XFxuICB1SW5wdXRTaXplOnZlYzQ8ZjMyPixcXG4gIHVJbnB1dFBpeGVsOnZlYzQ8ZjMyPixcXG4gIHVJbnB1dENsYW1wOnZlYzQ8ZjMyPixcXG4gIHVPdXRwdXRGcmFtZTp2ZWM0PGYzMj4sXFxuICB1R2xvYmFsRnJhbWU6dmVjNDxmMzI+LFxcbiAgdU91dHB1dFRleHR1cmU6dmVjNDxmMzI+LFxcbn07XFxuXFxuQGdyb3VwKDApIEBiaW5kaW5nKDApIHZhcjx1bmlmb3JtPiBnZnU6IEdsb2JhbEZpbHRlclVuaWZvcm1zO1xcblxcbkBncm91cCgwKSBAYmluZGluZygxKSB2YXIgdVRleHR1cmU6IHRleHR1cmVfMmQ8ZjMyPjsgXFxuQGdyb3VwKDApIEBiaW5kaW5nKDIpIHZhciB1U2FtcGxlcjogc2FtcGxlcjtcXG5AZ3JvdXAoMSkgQGJpbmRpbmcoMCkgdmFyPHVuaWZvcm0+IGJhc2VVbmlmb3JtcyA6IEJhc2VVbmlmb3JtcztcXG5AZ3JvdXAoMSkgQGJpbmRpbmcoMSkgdmFyPHVuaWZvcm0+IHN0b3BzVW5pZm9ybXMgOiBTdG9wc1VuaWZvcm1zO1xcblxcbnN0cnVjdCBWU091dHB1dCB7XFxuICBAYnVpbHRpbihwb3NpdGlvbikgcG9zaXRpb246IHZlYzQ8ZjMyPixcXG4gIEBsb2NhdGlvbigwKSB1diA6IHZlYzI8ZjMyPixcXG4gIEBsb2NhdGlvbigxKSBjb29yZCA6IHZlYzI8ZjMyPlxcbn07XFxuXFxuZm4gZmlsdGVyVmVydGV4UG9zaXRpb24oYVBvc2l0aW9uOnZlYzI8ZjMyPikgLT4gdmVjNDxmMzI+XFxue1xcbiAgICB2YXIgcG9zaXRpb24gPSBhUG9zaXRpb24gKiBnZnUudU91dHB1dEZyYW1lLnp3ICsgZ2Z1LnVPdXRwdXRGcmFtZS54eTtcXG5cXG4gICAgcG9zaXRpb24ueCA9IHBvc2l0aW9uLnggKiAoMi4wIC8gZ2Z1LnVPdXRwdXRUZXh0dXJlLngpIC0gMS4wO1xcbiAgICBwb3NpdGlvbi55ID0gcG9zaXRpb24ueSAqICgyLjAqZ2Z1LnVPdXRwdXRUZXh0dXJlLnogLyBnZnUudU91dHB1dFRleHR1cmUueSkgLSBnZnUudU91dHB1dFRleHR1cmUuejtcXG5cXG4gICAgcmV0dXJuIHZlYzQocG9zaXRpb24sIDAuMCwgMS4wKTtcXG59XFxuXFxuZm4gZmlsdGVyVGV4dHVyZUNvb3JkKCBhUG9zaXRpb246dmVjMjxmMzI+ICkgLT4gdmVjMjxmMzI+XFxue1xcbiAgICByZXR1cm4gYVBvc2l0aW9uICogKGdmdS51T3V0cHV0RnJhbWUuencgKiBnZnUudUlucHV0U2l6ZS56dyk7XFxufVxcblxcbmZuIGZpbHRlckNvb3JkKCB2VGV4dHVyZUNvb3JkOnZlYzI8ZjMyPiApIC0+IHZlYzI8ZjMyPlxcbntcXG4gICAgcmV0dXJuIHZUZXh0dXJlQ29vcmQgKiBnZnUudUlucHV0U2l6ZS54eSAvIGdmdS51T3V0cHV0RnJhbWUuenc7XFxufVxcblxcbmZuIGdsb2JhbFRleHR1cmVDb29yZCggYVBvc2l0aW9uOnZlYzI8ZjMyPiApIC0+IHZlYzI8ZjMyPlxcbntcXG4gIHJldHVybiAgKGFQb3NpdGlvbi54eSAvIGdmdS51R2xvYmFsRnJhbWUuencpICsgKGdmdS51R2xvYmFsRnJhbWUueHkgLyBnZnUudUdsb2JhbEZyYW1lLnp3KTsgIFxcbn1cXG5cXG5mbiBnZXRTaXplKCkgLT4gdmVjMjxmMzI+XFxue1xcbiAgcmV0dXJuIGdmdS51R2xvYmFsRnJhbWUuenc7XFxufVxcbiAgXFxuQHZlcnRleFxcbmZuIG1haW5WZXJ0ZXgoXFxuICBAbG9jYXRpb24oMCkgYVBvc2l0aW9uIDogdmVjMjxmMzI+LCBcXG4pIC0+IFZTT3V0cHV0IHtcXG4gIGxldCB2VGV4dHVyZUNvb3JkOiB2ZWMyPGYzMj4gPSBmaWx0ZXJUZXh0dXJlQ29vcmQoYVBvc2l0aW9uKTtcXG4gIHJldHVybiBWU091dHB1dChcXG4gICBmaWx0ZXJWZXJ0ZXhQb3NpdGlvbihhUG9zaXRpb24pLFxcbiAgIHZUZXh0dXJlQ29vcmQsXFxuICAgZmlsdGVyQ29vcmQodlRleHR1cmVDb29yZCksXFxuICApO1xcbn1cXG5cXG5zdHJ1Y3QgQ29sb3JTdG9wIHtcXG4gIG9mZnNldDogZjMyLFxcbiAgY29sb3I6IHZlYzM8ZjMyPixcXG4gIGFscGhhOiBmMzIsXFxufTtcXG5cXG5mbiByb3RhdGUyZChhbmdsZTogZjMyKSAtPiBtYXQyeDI8ZjMyPntcXG4gIHJldHVybiBtYXQyeDIoY29zKGFuZ2xlKSwgLXNpbihhbmdsZSksXFxuICBzaW4oYW5nbGUpLCBjb3MoYW5nbGUpKTtcXG59XFxuXFxuZm4gcHJvamVjdExpbmVhclBvc2l0aW9uKHBvczogdmVjMjxmMzI+LCBhbmdsZTogZjMyKSAtPiBmMzIge1xcbiAgdmFyIGNlbnRlcjogdmVjMjxmMzI+ID0gdmVjMjxmMzI+KDAuNSk7XFxuICB2YXIgcmVzdWx0OiB2ZWMyPGYzMj4gPSBwb3MgLSBjZW50ZXI7XFxuICByZXN1bHQgPSByb3RhdGUyZChhbmdsZSkgKiByZXN1bHQ7XFxuICByZXN1bHQgPSByZXN1bHQgKyBjZW50ZXI7XFxuICByZXR1cm4gY2xhbXAocmVzdWx0LngsIDAuMCwgMS4wKTtcXG59XFxuXFxuZm4gcHJvamVjdFJhZGlhbFBvc2l0aW9uKHBvczogdmVjMjxmMzI+KSAtPiBmMzIge1xcbiAgdmFyIHI6IGYzMiA9IGRpc3RhbmNlKHBvcywgdmVjMjxmMzI+KDAuNSkpO1xcbiAgcmV0dXJuIGNsYW1wKDIuMCAqIHIsIDAuMCwgMS4wKTtcXG59XFxuXFxuZm4gcHJvamVjdEFuZ2xlUG9zaXRpb24ocG9zOiB2ZWMyPGYzMj4sIGFuZ2xlOiBmMzIpIC0+IGYzMiB7XFxuICB2YXIgY2VudGVyOiB2ZWMyPGYzMj4gPSBwb3MgLSB2ZWMyPGYzMj4oMC41LCAwLjUpO1xcbiAgdmFyIHBvbGFyQW5nbGU6IGYzMiA9IGF0YW4yKC1jZW50ZXIueSwgY2VudGVyLngpO1xcbiAgcmV0dXJuICgocG9sYXJBbmdsZSArIGFuZ2xlKSAlIFBJXzIpIC8gUElfMjtcXG59XFxuXFxuZm4gcHJvamVjdFBvc2l0aW9uKHBvczogdmVjMjxmMzI+LCBncmFkaWVudFR5cGU6IGkzMiwgYW5nbGU6IGYzMikgLT4gZjMyIHtcXG4gIGlmIChncmFkaWVudFR5cGUgPT0gVFlQRV9MSU5FQVIpIHtcXG4gICAgICByZXR1cm4gcHJvamVjdExpbmVhclBvc2l0aW9uKHBvcywgYW5nbGUpO1xcbiAgfSBlbHNlIGlmIChncmFkaWVudFR5cGUgPT0gVFlQRV9SQURJQUwpIHtcXG4gICAgICByZXR1cm4gcHJvamVjdFJhZGlhbFBvc2l0aW9uKHBvcyk7XFxuICB9IGVsc2UgaWYgKGdyYWRpZW50VHlwZSA9PSBUWVBFX0NPTklDKSB7XFxuICAgICAgcmV0dXJuIHByb2plY3RBbmdsZVBvc2l0aW9uKHBvcywgYW5nbGUpO1xcbiAgfVxcblxcbiAgcmV0dXJuIHBvcy55O1xcbn1cXG5cXG5AZnJhZ21lbnRcXG5mbiBtYWluRnJhZ21lbnQoXFxuICBAYnVpbHRpbihwb3NpdGlvbikgcG9zaXRpb246IHZlYzQ8ZjMyPixcXG4gIEBsb2NhdGlvbigwKSB1diA6IHZlYzI8ZjMyPixcXG4gIEBsb2NhdGlvbigxKSBjb29yZCA6IHZlYzI8ZjMyPlxcbikgLT4gQGxvY2F0aW9uKDApIHZlYzQ8ZjMyPiB7XFxuICBsZXQgdVR5cGU6IGkzMiA9IGkzMihiYXNlVW5pZm9ybXMudU9wdGlvbnNbMF0pO1xcbiAgbGV0IHVBbmdsZTogZjMyID0gYmFzZVVuaWZvcm1zLnVPcHRpb25zWzFdO1xcbiAgbGV0IHVBbHBoYTogZjMyID0gYmFzZVVuaWZvcm1zLnVPcHRpb25zWzJdO1xcbiAgbGV0IHVSZXBsYWNlOiBmMzIgPSBiYXNlVW5pZm9ybXMudU9wdGlvbnNbM107XFxuXFxuICBsZXQgdU51bVN0b3BzOiBpMzIgPSBpMzIoYmFzZVVuaWZvcm1zLnVDb3VudHNbMF0pO1xcbiAgbGV0IHVNYXhDb2xvcnM6IGYzMiA9IGJhc2VVbmlmb3Jtcy51Q291bnRzWzFdO1xcblxcbiAgLy8gY3VycmVudC9vcmlnaW5hbCBjb2xvclxcbiAgdmFyIGN1cnJlbnRDb2xvcjogdmVjNDxmMzI+ID0gdGV4dHVyZVNhbXBsZSh1VGV4dHVyZSwgdVNhbXBsZXIsIHV2KTtcXG5cXG4gIC8vIHNraXAgY2FsY3VsYXRpb25zIGlmIGdyYWRpZW50IGFscGhhIGlzIDBcXG4gIGlmICh1QWxwaGEgPT0gMC4wKSB7IHJldHVybiBjdXJyZW50Q29sb3I7IH1cXG5cXG4gIC8vIHByb2plY3QgcG9zaXRpb25cXG4gIHZhciB5OiBmMzIgPSBwcm9qZWN0UG9zaXRpb24oY29vcmQsIHVUeXBlLCByYWRpYW5zKHVBbmdsZSkpO1xcblxcbiAgLy8gY2hlY2sgZ3JhZGllbnQgYm91bmRzXFxuICB2YXIgb2Zmc2V0TWluOiBmMzIgPSBzdG9wc1VuaWZvcm1zLnVTdG9wc1swXVswXTtcXG4gIHZhciBvZmZzZXRNYXg6IGYzMiA9IDAuMDtcXG5cXG4gIGxldCBudW1TdG9wczogaTMyID0gdU51bVN0b3BzO1xcblxcbiAgZm9yICh2YXIgaTogaTMyID0gMDsgaSA8IE1BWF9TVE9QUzsgaSA9IGkgKyAxKSB7XFxuICAgICAgaWYgKGkgPT0gbnVtU3RvcHMgLSAxKSB7IC8vIGxhc3QgaW5kZXhcXG4gICAgICAgICAgb2Zmc2V0TWF4ID0gc3RvcHNVbmlmb3Jtcy51U3RvcHNbaV1bMF07XFxuICAgICAgfVxcbiAgfVxcblxcbiAgaWYgKHkgIDwgb2Zmc2V0TWluIHx8IHkgPiBvZmZzZXRNYXgpIHsgcmV0dXJuIGN1cnJlbnRDb2xvcjsgfVxcblxcbiAgLy8gbGltaXQgY29sb3JzXFxuICBpZiAodU1heENvbG9ycyA+IDAuMCkge1xcbiAgICAgIHZhciBzdGVwU2l6ZTogZjMyID0gMS4wIC8gdU1heENvbG9ycztcXG4gICAgICB2YXIgc3RlcE51bWJlcjogZjMyID0gZmxvb3IoeSAvIHN0ZXBTaXplKTtcXG4gICAgICB5ID0gc3RlcFNpemUgKiAoc3RlcE51bWJlciArIDAuNSk7IC8vIG9mZnNldCBieSAwLjUgdG8gdXNlIGNvbG9yIGZyb20gbWlkZGxlIG9mIHNlZ21lbnRcXG4gIH1cXG5cXG4gIC8vIGZpbmQgY29sb3Igc3RvcHNcXG4gIHZhciBzdG9wRnJvbTogQ29sb3JTdG9wO1xcbiAgdmFyIHN0b3BUbzogQ29sb3JTdG9wO1xcblxcbiAgZm9yICh2YXIgaTogaTMyID0gMDsgaSA8IE1BWF9TVE9QUzsgaSA9IGkgKyAxKSB7XFxuICAgICAgaWYgKHkgPj0gc3RvcHNVbmlmb3Jtcy51U3RvcHNbaV1bMF0pIHtcXG4gICAgICAgICAgc3RvcEZyb20gPSBDb2xvclN0b3Aoc3RvcHNVbmlmb3Jtcy51U3RvcHNbaV1bMF0sIHN0b3BzVW5pZm9ybXMudUNvbG9yc1tpXSwgc3RvcHNVbmlmb3Jtcy51U3RvcHNbaV1bMV0pO1xcbiAgICAgICAgICBzdG9wVG8gPSBDb2xvclN0b3Aoc3RvcHNVbmlmb3Jtcy51U3RvcHNbaSArIDFdWzBdLCBzdG9wc1VuaWZvcm1zLnVDb2xvcnNbaSArIDFdLCBzdG9wc1VuaWZvcm1zLnVTdG9wc1tpICsgMV1bMV0pO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoaSA9PSBudW1TdG9wcyAtIDEpIHsgLy8gbGFzdCBpbmRleFxcbiAgICAgICAgICBicmVhaztcXG4gICAgICB9XFxuICB9XFxuXFxuICAvLyBtaXggY29sb3JzIGZyb20gc3RvcHNcXG4gIHZhciBjb2xvckZyb206IHZlYzQ8ZjMyPiA9IHZlYzQ8ZjMyPihzdG9wRnJvbS5jb2xvciAqIHN0b3BGcm9tLmFscGhhLCBzdG9wRnJvbS5hbHBoYSk7XFxuICB2YXIgY29sb3JUbzogdmVjNDxmMzI+ID0gdmVjNDxmMzI+KHN0b3BUby5jb2xvciAqIHN0b3BUby5hbHBoYSwgc3RvcFRvLmFscGhhKTtcXG5cXG4gIHZhciBzZWdtZW50SGVpZ2h0OiBmMzIgPSBzdG9wVG8ub2Zmc2V0IC0gc3RvcEZyb20ub2Zmc2V0O1xcbiAgdmFyIHJlbGF0aXZlUG9zOiBmMzIgPSB5IC0gc3RvcEZyb20ub2Zmc2V0OyAvLyBwb3NpdGlvbiBmcm9tIDAgdG8gW3NlZ21lbnRIZWlnaHRdXFxuICB2YXIgcmVsYXRpdmVQZXJjZW50OiBmMzIgPSByZWxhdGl2ZVBvcyAvIHNlZ21lbnRIZWlnaHQ7IC8vIHBvc2l0aW9uIGluIHBlcmNlbnQgYmV0d2VlbiBbZnJvbS5vZmZzZXRdIGFuZCBbdG8ub2Zmc2V0XS5cXG5cXG4gIHZhciBncmFkaWVudEFscGhhOiBmMzIgPSB1QWxwaGEgKiBjdXJyZW50Q29sb3IuYTtcXG4gIHZhciBncmFkaWVudENvbG9yOiB2ZWM0PGYzMj4gPSBtaXgoY29sb3JGcm9tLCBjb2xvclRvLCByZWxhdGl2ZVBlcmNlbnQpICogZ3JhZGllbnRBbHBoYTtcXG5cXG4gIGlmICh1UmVwbGFjZSA8IDAuNSkge1xcbiAgICAgIC8vIG1peCByZXN1bHRpbmcgY29sb3Igd2l0aCBjdXJyZW50IGNvbG9yXFxuICAgICAgcmV0dXJuIGdyYWRpZW50Q29sb3IgKyBjdXJyZW50Q29sb3IgKiAoMS4wIC0gZ3JhZGllbnRDb2xvci5hKTtcXG4gIH0gZWxzZSB7XFxuICAgICAgLy8gcmVwbGFjZSB3aXRoIGdyYWRpZW50IGNvbG9yXFxuICAgICAgcmV0dXJuIGdyYWRpZW50Q29sb3I7XFxuICB9XFxufVxcblxcbmNvbnN0IFBJOiBmMzIgPSAzLjE0MTU5MjY1MzU4OTc5MzIzODQ2MjY0O1xcbmNvbnN0IFBJXzI6IGYzMiA9IFBJICogMi4wO1xcblxcbmNvbnN0IFRZUEVfTElORUFSOiBpMzIgPSAwO1xcbmNvbnN0IFRZUEVfUkFESUFMOiBpMzIgPSAxO1xcbmNvbnN0IFRZUEVfQ09OSUM6IGkzMiA9IDI7XFxuY29uc3QgTUFYX1NUT1BTOiBpMzIgPSAzMjtcIjtcblxuZXhwb3J0IHsgc291cmNlIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbG9yLWdyYWRpZW50My5tanMubWFwXG4iLCJpbXBvcnQgeyBGaWx0ZXIsIEdwdVByb2dyYW0sIEdsUHJvZ3JhbSwgQ29sb3IgfSBmcm9tICdwaXhpLmpzJztcbmltcG9ydCBmcmFnbWVudCBmcm9tICcuL2NvbG9yLWdyYWRpZW50Mi5tanMnO1xuaW1wb3J0IHZlcnRleCBmcm9tICcuL2NvbG9yLWdyYWRpZW50Lm1qcyc7XG5pbXBvcnQgc291cmNlIGZyb20gJy4vY29sb3ItZ3JhZGllbnQzLm1qcyc7XG5pbXBvcnQgeyBwYXJzZUNzc0dyYWRpZW50IH0gZnJvbSAnLi9Dc3NHcmFkaWVudFBhcnNlci5tanMnO1xuXG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiB7XG4gIF9fZGVmTm9ybWFsUHJvcChvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5jb25zdCBBTkdMRV9PRkZTRVQgPSA5MDtcbmZ1bmN0aW9uIHNvcnRDb2xvclN0b3BzKHN0b3BzKSB7XG4gIHJldHVybiBbLi4uc3RvcHNdLnNvcnQoKGEsIGIpID0+IGEub2Zmc2V0IC0gYi5vZmZzZXQpO1xufVxuY29uc3QgX0NvbG9yR3JhZGllbnRGaWx0ZXIgPSBjbGFzcyBfQ29sb3JHcmFkaWVudEZpbHRlciBleHRlbmRzIEZpbHRlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIHRoZSBDb2xvckdyYWRpZW50RmlsdGVyIGNvbnN0cnVjdG9yLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zICYmIFwiY3NzXCIgaW4gb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgLi4ucGFyc2VDc3NHcmFkaWVudChvcHRpb25zLmNzcyB8fCBcIlwiKSxcbiAgICAgICAgYWxwaGE6IG9wdGlvbnMuYWxwaGEgPz8gX0NvbG9yR3JhZGllbnRGaWx0ZXIuZGVmYXVsdHMuYWxwaGEsXG4gICAgICAgIG1heENvbG9yczogb3B0aW9ucy5tYXhDb2xvcnMgPz8gX0NvbG9yR3JhZGllbnRGaWx0ZXIuZGVmYXVsdHMubWF4Q29sb3JzXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zID0geyAuLi5fQ29sb3JHcmFkaWVudEZpbHRlci5kZWZhdWx0cywgLi4ub3B0aW9ucyB9O1xuICAgIH1cbiAgICBpZiAoIW9wdGlvbnMuc3RvcHMgfHwgb3B0aW9ucy5zdG9wcy5sZW5ndGggPCAyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb2xvckdyYWRpZW50RmlsdGVyIHJlcXVpcmVzIGF0IGxlYXN0IDIgY29sb3Igc3RvcHMuXCIpO1xuICAgIH1cbiAgICBjb25zdCBncHVQcm9ncmFtID0gR3B1UHJvZ3JhbS5mcm9tKHtcbiAgICAgIHZlcnRleDoge1xuICAgICAgICBzb3VyY2UsXG4gICAgICAgIGVudHJ5UG9pbnQ6IFwibWFpblZlcnRleFwiXG4gICAgICB9LFxuICAgICAgZnJhZ21lbnQ6IHtcbiAgICAgICAgc291cmNlLFxuICAgICAgICBlbnRyeVBvaW50OiBcIm1haW5GcmFnbWVudFwiXG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgZ2xQcm9ncmFtID0gR2xQcm9ncmFtLmZyb20oe1xuICAgICAgdmVydGV4LFxuICAgICAgZnJhZ21lbnQsXG4gICAgICBuYW1lOiBcImNvbG9yLWdyYWRpZW50LWZpbHRlclwiXG4gICAgfSk7XG4gICAgY29uc3QgbWF4U3RvcHMgPSAzMjtcbiAgICBzdXBlcih7XG4gICAgICBncHVQcm9ncmFtLFxuICAgICAgZ2xQcm9ncmFtLFxuICAgICAgcmVzb3VyY2VzOiB7XG4gICAgICAgIGJhc2VVbmlmb3Jtczoge1xuICAgICAgICAgIHVPcHRpb25zOiB7XG4gICAgICAgICAgICB2YWx1ZTogW1xuICAgICAgICAgICAgICAvLyBHcmFkaWVudCBUeXBlXG4gICAgICAgICAgICAgIG9wdGlvbnMudHlwZSxcbiAgICAgICAgICAgICAgLy8gR3JhZGllbnQgQW5nbGVcbiAgICAgICAgICAgICAgb3B0aW9ucy5hbmdsZSA/PyBBTkdMRV9PRkZTRVQsXG4gICAgICAgICAgICAgIC8vIE1hc3RlciBBbHBoYVxuICAgICAgICAgICAgICBvcHRpb25zLmFscGhhLFxuICAgICAgICAgICAgICAvLyBSZXBsYWNlIEJhc2UgQ29sb3JcbiAgICAgICAgICAgICAgb3B0aW9ucy5yZXBsYWNlID8gMSA6IDBcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB0eXBlOiBcInZlYzQ8ZjMyPlwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1Q291bnRzOiB7XG4gICAgICAgICAgICB2YWx1ZTogW1xuICAgICAgICAgICAgICAvLyBOdW1iZXIgb2YgU3RvcHNcbiAgICAgICAgICAgICAgb3B0aW9ucy5zdG9wcy5sZW5ndGgsXG4gICAgICAgICAgICAgIC8vIE1heCBHcmFkaWVudCBDb2xvcnNcbiAgICAgICAgICAgICAgb3B0aW9ucy5tYXhDb2xvcnNcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB0eXBlOiBcInZlYzI8ZjMyPlwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzdG9wc1VuaWZvcm1zOiB7XG4gICAgICAgICAgdUNvbG9yczogeyB2YWx1ZTogbmV3IEZsb2F0MzJBcnJheShtYXhTdG9wcyAqIDMpLCB0eXBlOiBcInZlYzM8ZjMyPlwiLCBzaXplOiBtYXhTdG9wcyB9LFxuICAgICAgICAgIC8vIFdlIG9ubHkgbmVlZCB2ZWMyLCBidXQgd2UgbmVlZCB0byBwYWQgdG8gZWxpbWluYXRlIHRoZSBXR1NMIHdhcm5pbmcsIFRPRE86IEBNYXQgP1xuICAgICAgICAgIHVTdG9wczogeyB2YWx1ZTogbmV3IEZsb2F0MzJBcnJheShtYXhTdG9wcyAqIDQpLCB0eXBlOiBcInZlYzQ8ZjMyPlwiLCBzaXplOiBtYXhTdG9wcyB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiYmFzZVVuaWZvcm1zXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzdG9wc1VuaWZvcm1zXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfc3RvcHNcIiwgW10pO1xuICAgIHRoaXMuYmFzZVVuaWZvcm1zID0gdGhpcy5yZXNvdXJjZXMuYmFzZVVuaWZvcm1zLnVuaWZvcm1zO1xuICAgIHRoaXMuc3RvcHNVbmlmb3JtcyA9IHRoaXMucmVzb3VyY2VzLnN0b3BzVW5pZm9ybXMudW5pZm9ybXM7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBvcHRpb25zKTtcbiAgfVxuICBnZXQgc3RvcHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0b3BzO1xuICB9XG4gIHNldCBzdG9wcyhzdG9wcykge1xuICAgIGNvbnN0IHNvcnRlZFN0b3BzID0gc29ydENvbG9yU3RvcHMoc3RvcHMpO1xuICAgIGNvbnN0IGNvbG9yID0gbmV3IENvbG9yKCk7XG4gICAgbGV0IHI7XG4gICAgbGV0IGc7XG4gICAgbGV0IGI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzb3J0ZWRTdG9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29sb3Iuc2V0VmFsdWUoc29ydGVkU3RvcHNbaV0uY29sb3IpO1xuICAgICAgY29uc3QgaW5kZXhTdGFydCA9IGkgKiAzO1xuICAgICAgW3IsIGcsIGJdID0gY29sb3IudG9BcnJheSgpO1xuICAgICAgdGhpcy5zdG9wc1VuaWZvcm1zLnVDb2xvcnNbaW5kZXhTdGFydF0gPSByO1xuICAgICAgdGhpcy5zdG9wc1VuaWZvcm1zLnVDb2xvcnNbaW5kZXhTdGFydCArIDFdID0gZztcbiAgICAgIHRoaXMuc3RvcHNVbmlmb3Jtcy51Q29sb3JzW2luZGV4U3RhcnQgKyAyXSA9IGI7XG4gICAgICB0aGlzLnN0b3BzVW5pZm9ybXMudVN0b3BzW2kgKiA0XSA9IHNvcnRlZFN0b3BzW2ldLm9mZnNldDtcbiAgICAgIHRoaXMuc3RvcHNVbmlmb3Jtcy51U3RvcHNbaSAqIDQgKyAxXSA9IHNvcnRlZFN0b3BzW2ldLmFscGhhO1xuICAgIH1cbiAgICB0aGlzLmJhc2VVbmlmb3Jtcy51Q291bnRzWzBdID0gc29ydGVkU3RvcHMubGVuZ3RoO1xuICAgIHRoaXMuX3N0b3BzID0gc29ydGVkU3RvcHM7XG4gIH1cbiAgLyoqXG4gICogVGhlIHR5cGUgb2YgZ3JhZGllbnRcbiAgKiBAZGVmYXVsdCBDb2xvckdyYWRpZW50RmlsdGVyLkxJTkVBUlxuICAqL1xuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5iYXNlVW5pZm9ybXMudU9wdGlvbnNbMF07XG4gIH1cbiAgc2V0IHR5cGUodmFsdWUpIHtcbiAgICB0aGlzLmJhc2VVbmlmb3Jtcy51T3B0aW9uc1swXSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAqIFRoZSBhbmdsZSBvZiB0aGUgZ3JhZGllbnQgaW4gZGVncmVlc1xuICAqIEBkZWZhdWx0IDkwXG4gICovXG4gIGdldCBhbmdsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5iYXNlVW5pZm9ybXMudU9wdGlvbnNbMV0gKyBBTkdMRV9PRkZTRVQ7XG4gIH1cbiAgc2V0IGFuZ2xlKHZhbHVlKSB7XG4gICAgdGhpcy5iYXNlVW5pZm9ybXMudU9wdGlvbnNbMV0gPSB2YWx1ZSAtIEFOR0xFX09GRlNFVDtcbiAgfVxuICAvKipcbiAgKiBUaGUgYWxwaGEgdmFsdWUgb2YgdGhlIGdyYWRpZW50ICgwLTEpXG4gICogQGRlZmF1bHQgMVxuICAqL1xuICBnZXQgYWxwaGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmFzZVVuaWZvcm1zLnVPcHRpb25zWzJdO1xuICB9XG4gIHNldCBhbHBoYSh2YWx1ZSkge1xuICAgIHRoaXMuYmFzZVVuaWZvcm1zLnVPcHRpb25zWzJdID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICogVGhlIG1heGltdW0gbnVtYmVyIG9mIGNvbG9ycyB0byByZW5kZXIgKDAgPSBubyBsaW1pdClcbiAgKiBAZGVmYXVsdCAwXG4gICovXG4gIGdldCBtYXhDb2xvcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmFzZVVuaWZvcm1zLnVDb3VudHNbMV07XG4gIH1cbiAgc2V0IG1heENvbG9ycyh2YWx1ZSkge1xuICAgIHRoaXMuYmFzZVVuaWZvcm1zLnVDb3VudHNbMV0gPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogSWYgdHJ1ZSwgdGhlIGdyYWRpZW50IHdpbGwgcmVwbGFjZSB0aGUgZXhpc3RpbmcgY29sb3IsIG90aGVyd2lzZSBpdFxuICAgKiB3aWxsIGJlIG11bHRpcGxpZWQgd2l0aCBpdFxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgZ2V0IHJlcGxhY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmFzZVVuaWZvcm1zLnVPcHRpb25zWzNdID4gMC41O1xuICB9XG4gIHNldCByZXBsYWNlKHZhbHVlKSB7XG4gICAgdGhpcy5iYXNlVW5pZm9ybXMudU9wdGlvbnNbM10gPSB2YWx1ZSA/IDEgOiAwO1xuICB9XG59O1xuLyoqIEdyYWRpZW50IHR5cGVzICovXG5fX3B1YmxpY0ZpZWxkKF9Db2xvckdyYWRpZW50RmlsdGVyLCBcIkxJTkVBUlwiLCAwKTtcbl9fcHVibGljRmllbGQoX0NvbG9yR3JhZGllbnRGaWx0ZXIsIFwiUkFESUFMXCIsIDEpO1xuX19wdWJsaWNGaWVsZChfQ29sb3JHcmFkaWVudEZpbHRlciwgXCJDT05JQ1wiLCAyKTtcbi8qKiBEZWZhdWx0IGNvbnN0cnVjdG9yIG9wdGlvbnMgKi9cbl9fcHVibGljRmllbGQoX0NvbG9yR3JhZGllbnRGaWx0ZXIsIFwiZGVmYXVsdHNcIiwge1xuICB0eXBlOiBfQ29sb3JHcmFkaWVudEZpbHRlci5MSU5FQVIsXG4gIHN0b3BzOiBbXG4gICAgeyBvZmZzZXQ6IDAsIGNvbG9yOiAxNjcxMTY4MCwgYWxwaGE6IDEgfSxcbiAgICB7IG9mZnNldDogMSwgY29sb3I6IDI1NSwgYWxwaGE6IDEgfVxuICBdLFxuICBhbHBoYTogMSxcbiAgYW5nbGU6IDkwLFxuICBtYXhDb2xvcnM6IDAsXG4gIHJlcGxhY2U6IGZhbHNlXG59KTtcbmxldCBDb2xvckdyYWRpZW50RmlsdGVyID0gX0NvbG9yR3JhZGllbnRGaWx0ZXI7XG5cbmV4cG9ydCB7IENvbG9yR3JhZGllbnRGaWx0ZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbG9yR3JhZGllbnRGaWx0ZXIubWpzLm1hcFxuIiwidmFyIHZlcnRleCA9IFwiaW4gdmVjMiBhUG9zaXRpb247XFxub3V0IHZlYzIgdlRleHR1cmVDb29yZDtcXG5vdXQgdmVjMiB2RmlsdGVyQ29vcmQ7XFxuXFxudW5pZm9ybSB2ZWM0IHVJbnB1dFNpemU7XFxudW5pZm9ybSB2ZWM0IHVPdXRwdXRGcmFtZTtcXG51bmlmb3JtIHZlYzQgdU91dHB1dFRleHR1cmU7XFxuXFxudmVjNCBmaWx0ZXJWZXJ0ZXhQb3NpdGlvbiggdm9pZCApXFxue1xcbiAgICB2ZWMyIHBvc2l0aW9uID0gYVBvc2l0aW9uICogdU91dHB1dEZyYW1lLnp3ICsgdU91dHB1dEZyYW1lLnh5O1xcbiAgICBcXG4gICAgcG9zaXRpb24ueCA9IHBvc2l0aW9uLnggKiAoMi4wIC8gdU91dHB1dFRleHR1cmUueCkgLSAxLjA7XFxuICAgIHBvc2l0aW9uLnkgPSBwb3NpdGlvbi55ICogKDIuMCp1T3V0cHV0VGV4dHVyZS56IC8gdU91dHB1dFRleHR1cmUueSkgLSB1T3V0cHV0VGV4dHVyZS56O1xcblxcbiAgICByZXR1cm4gdmVjNChwb3NpdGlvbiwgMC4wLCAxLjApO1xcbn1cXG5cXG52ZWMyIGZpbHRlclRleHR1cmVDb29yZCggdm9pZCApXFxue1xcbiAgICByZXR1cm4gYVBvc2l0aW9uICogKHVPdXRwdXRGcmFtZS56dyAqIHVJbnB1dFNpemUuencpO1xcbn1cXG5cXG52b2lkIG1haW4odm9pZClcXG57XFxuICAgIGdsX1Bvc2l0aW9uID0gZmlsdGVyVmVydGV4UG9zaXRpb24oKTtcXG4gICAgdlRleHR1cmVDb29yZCA9IGZpbHRlclRleHR1cmVDb29yZCgpO1xcbiAgICB2RmlsdGVyQ29vcmQgPSB2VGV4dHVyZUNvb3JkICogdUlucHV0U2l6ZS54eSAvIHVPdXRwdXRGcmFtZS56dztcXG59XFxuXCI7XG5cbmV4cG9ydCB7IHZlcnRleCBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2xvci1ncmFkaWVudC5tanMubWFwXG4iLCJ2YXIgZnJhZ21lbnQgPSBcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5pbiB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxuaW4gdmVjMiB2RmlsdGVyQ29vcmQ7XFxub3V0IHZlYzQgZmluYWxDb2xvcjtcXG5cXG5jb25zdCBpbnQgVFlQRV9MSU5FQVIgPSAwO1xcbmNvbnN0IGludCBUWVBFX1JBRElBTCA9IDE7XFxuY29uc3QgaW50IFRZUEVfQ09OSUMgPSAyO1xcbmNvbnN0IGludCBNQVhfU1RPUFMgPSAzMjtcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG51bmlmb3JtIHZlYzQgdU9wdGlvbnM7XFxudW5pZm9ybSB2ZWMyIHVDb3VudHM7XFxudW5pZm9ybSB2ZWMzIHVDb2xvcnNbTUFYX1NUT1BTXTtcXG51bmlmb3JtIHZlYzQgdVN0b3BzW01BWF9TVE9QU107XFxuXFxuY29uc3QgZmxvYXQgUEkgPSAzLjE0MTU5MjY1Mzg7XFxuY29uc3QgZmxvYXQgUElfMiA9IFBJKjIuO1xcblxcbnN0cnVjdCBDb2xvclN0b3Age1xcbiAgICBmbG9hdCBvZmZzZXQ7XFxuICAgIHZlYzMgY29sb3I7XFxuICAgIGZsb2F0IGFscGhhO1xcbn07XFxuXFxubWF0MiByb3RhdGUyZChmbG9hdCBhbmdsZSl7XFxuICAgIHJldHVybiBtYXQyKGNvcyhhbmdsZSksIC1zaW4oYW5nbGUpLFxcbiAgICBzaW4oYW5nbGUpLCBjb3MoYW5nbGUpKTtcXG59XFxuXFxuZmxvYXQgcHJvamVjdExpbmVhclBvc2l0aW9uKHZlYzIgcG9zLCBmbG9hdCBhbmdsZSl7XFxuICAgIHZlYzIgY2VudGVyID0gdmVjMigwLjUpO1xcbiAgICB2ZWMyIHJlc3VsdCA9IHBvcyAtIGNlbnRlcjtcXG4gICAgcmVzdWx0ID0gcm90YXRlMmQoYW5nbGUpICogcmVzdWx0O1xcbiAgICByZXN1bHQgPSByZXN1bHQgKyBjZW50ZXI7XFxuICAgIHJldHVybiBjbGFtcChyZXN1bHQueCwgMC4sIDEuKTtcXG59XFxuXFxuZmxvYXQgcHJvamVjdFJhZGlhbFBvc2l0aW9uKHZlYzIgcG9zKSB7XFxuICAgIGZsb2F0IHIgPSBkaXN0YW5jZShwb3MsIHZlYzIoMC41KSk7XFxuICAgIHJldHVybiBjbGFtcCgyLipyLCAwLiwgMS4pO1xcbn1cXG5cXG5mbG9hdCBwcm9qZWN0QW5nbGVQb3NpdGlvbih2ZWMyIHBvcywgZmxvYXQgYW5nbGUpIHtcXG4gICAgdmVjMiBjZW50ZXIgPSBwb3MgLSB2ZWMyKDAuNSk7XFxuICAgIGZsb2F0IHBvbGFyQW5nbGU9YXRhbigtY2VudGVyLnksIGNlbnRlci54KTtcXG4gICAgcmV0dXJuIG1vZChwb2xhckFuZ2xlICsgYW5nbGUsIFBJXzIpIC8gUElfMjtcXG59XFxuXFxuZmxvYXQgcHJvamVjdFBvc2l0aW9uKHZlYzIgcG9zLCBpbnQgdHlwZSwgZmxvYXQgYW5nbGUpIHtcXG4gICAgaWYgKHR5cGUgPT0gVFlQRV9MSU5FQVIpIHtcXG4gICAgICAgIHJldHVybiBwcm9qZWN0TGluZWFyUG9zaXRpb24ocG9zLCBhbmdsZSk7XFxuICAgIH0gZWxzZSBpZiAodHlwZSA9PSBUWVBFX1JBRElBTCkge1xcbiAgICAgICAgcmV0dXJuIHByb2plY3RSYWRpYWxQb3NpdGlvbihwb3MpO1xcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT0gVFlQRV9DT05JQykge1xcbiAgICAgICAgcmV0dXJuIHByb2plY3RBbmdsZVBvc2l0aW9uKHBvcywgYW5nbGUpO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBwb3MueTtcXG59XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gICAgaW50IHVUeXBlID0gaW50KHVPcHRpb25zWzBdKTtcXG4gICAgZmxvYXQgdUFuZ2xlID0gdU9wdGlvbnNbMV07XFxuICAgIGZsb2F0IHVBbHBoYSA9IHVPcHRpb25zWzJdO1xcbiAgICBmbG9hdCB1UmVwbGFjZSA9IHVPcHRpb25zWzNdO1xcblxcbiAgICBpbnQgdU51bVN0b3BzID0gaW50KHVDb3VudHNbMF0pO1xcbiAgICBmbG9hdCB1TWF4Q29sb3JzID0gdUNvdW50c1sxXTtcXG5cXG4gICAgLy8gY3VycmVudC9vcmlnaW5hbCBjb2xvclxcbiAgICB2ZWM0IGN1cnJlbnRDb2xvciA9IHRleHR1cmUodVRleHR1cmUsIHZUZXh0dXJlQ29vcmQpO1xcblxcbiAgICAvLyBza2lwIGNhbGN1bGF0aW9ucyBpZiBncmFkaWVudCBhbHBoYSBpcyAwXFxuICAgIGlmICgwLjAgPT0gdUFscGhhKSB7XFxuICAgICAgICBmaW5hbENvbG9yID0gY3VycmVudENvbG9yO1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIC8vIHByb2plY3QgcG9zaXRpb25cXG4gICAgZmxvYXQgeSA9IHByb2plY3RQb3NpdGlvbih2RmlsdGVyQ29vcmQsIGludCh1VHlwZSksIHJhZGlhbnModUFuZ2xlKSk7XFxuXFxuICAgIC8vIGNoZWNrIGdyYWRpZW50IGJvdW5kc1xcbiAgICBmbG9hdCBvZmZzZXRNaW4gPSB1U3RvcHNbMF1bMF07XFxuICAgIGZsb2F0IG9mZnNldE1heCA9IDAuMDtcXG5cXG4gICAgaW50IG51bVN0b3BzID0gaW50KHVOdW1TdG9wcyk7XFxuXFxuICAgIGZvciAoaW50IGkgPSAwOyBpIDwgTUFYX1NUT1BTOyBpKyspIHtcXG4gICAgICAgIGlmIChpID09IG51bVN0b3BzLTEpeyAvLyBsYXN0IGluZGV4XFxuICAgICAgICAgICAgb2Zmc2V0TWF4ID0gdVN0b3BzW2ldWzBdO1xcbiAgICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGlmICh5ICA8IG9mZnNldE1pbiB8fCB5ID4gb2Zmc2V0TWF4KSB7XFxuICAgICAgICBmaW5hbENvbG9yID0gY3VycmVudENvbG9yO1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIC8vIGxpbWl0IGNvbG9yc1xcbiAgICBpZiAodU1heENvbG9ycyA+IDAuKSB7XFxuICAgICAgICBmbG9hdCBzdGVwU2l6ZSA9IDEuL3VNYXhDb2xvcnM7XFxuICAgICAgICBmbG9hdCBzdGVwTnVtYmVyID0gZmxvYXQoZmxvb3IoeS9zdGVwU2l6ZSkpO1xcbiAgICAgICAgeSA9IHN0ZXBTaXplICogKHN0ZXBOdW1iZXIgKyAwLjUpOy8vIG9mZnNldCBieSAwLjUgdG8gdXNlIGNvbG9yIGZyb20gbWlkZGxlIG9mIHNlZ21lbnRcXG4gICAgfVxcblxcbiAgICAvLyBmaW5kIGNvbG9yIHN0b3BzXFxuICAgIENvbG9yU3RvcCBmcm9tO1xcbiAgICBDb2xvclN0b3AgdG87XFxuXFxuICAgIGZvciAoaW50IGkgPSAwOyBpIDwgTUFYX1NUT1BTOyBpKyspIHtcXG4gICAgICAgIGlmICh5ID49IHVTdG9wc1tpXVswXSkge1xcbiAgICAgICAgICAgIGZyb20gPSBDb2xvclN0b3AodVN0b3BzW2ldWzBdLCB1Q29sb3JzW2ldLCB1U3RvcHNbaV1bMV0pO1xcbiAgICAgICAgICAgIHRvID0gQ29sb3JTdG9wKHVTdG9wc1tpKzFdWzBdLCB1Q29sb3JzW2krMV0sIHVTdG9wc1tpKzFdWzFdKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChpID09IG51bVN0b3BzLTEpeyAvLyBsYXN0IGluZGV4XFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICB9XFxuICAgIH1cXG5cXG4gICAgLy8gbWl4IGNvbG9ycyBmcm9tIHN0b3BzXFxuICAgIHZlYzQgY29sb3JGcm9tID0gdmVjNChmcm9tLmNvbG9yICogZnJvbS5hbHBoYSwgZnJvbS5hbHBoYSk7XFxuICAgIHZlYzQgY29sb3JUbyA9IHZlYzQodG8uY29sb3IgKiB0by5hbHBoYSwgdG8uYWxwaGEpO1xcblxcbiAgICBmbG9hdCBzZWdtZW50SGVpZ2h0ID0gdG8ub2Zmc2V0IC0gZnJvbS5vZmZzZXQ7XFxuICAgIGZsb2F0IHJlbGF0aXZlUG9zID0geSAtIGZyb20ub2Zmc2V0Oy8vIHBvc2l0aW9uIGZyb20gMCB0byBbc2VnbWVudEhlaWdodF1cXG4gICAgZmxvYXQgcmVsYXRpdmVQZXJjZW50ID0gcmVsYXRpdmVQb3MgLyBzZWdtZW50SGVpZ2h0Oy8vIHBvc2l0aW9uIGluIHBlcmNlbnQgYmV0d2VlbiBbZnJvbS5vZmZzZXRdIGFuZCBbdG8ub2Zmc2V0XS5cXG5cXG4gICAgZmxvYXQgZ3JhZGllbnRBbHBoYSA9IHVBbHBoYSAqIGN1cnJlbnRDb2xvci5hO1xcbiAgICB2ZWM0IGdyYWRpZW50Q29sb3IgPSBtaXgoY29sb3JGcm9tLCBjb2xvclRvLCByZWxhdGl2ZVBlcmNlbnQpICogZ3JhZGllbnRBbHBoYTtcXG5cXG4gICAgaWYgKHVSZXBsYWNlIDwgMC41KSB7XFxuICAgICAgICAvLyBtaXggcmVzdWx0aW5nIGNvbG9yIHdpdGggY3VycmVudCBjb2xvclxcbiAgICAgICAgZmluYWxDb2xvciA9IGdyYWRpZW50Q29sb3IgKyBjdXJyZW50Q29sb3IqKDEuLWdyYWRpZW50Q29sb3IuYSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICAvLyByZXBsYWNlIHdpdGggZ3JhZGllbnQgY29sb3JcXG4gICAgICAgIGZpbmFsQ29sb3IgPSBncmFkaWVudENvbG9yO1xcbiAgICB9XFxufVxcblwiO1xuXG5leHBvcnQgeyBmcmFnbWVudCBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2xvci1ncmFkaWVudDIubWpzLm1hcFxuIiwiLy8gQ29weXJpZ2h0IChjKSAyMDE0IFJhZmFlbCBDYXJpY2lvLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuLy8gZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZS5cblxudmFyIEdyYWRpZW50UGFyc2VyID0gKEdyYWRpZW50UGFyc2VyIHx8IHt9KTtcblxuR3JhZGllbnRQYXJzZXIuc3RyaW5naWZ5ID0gKGZ1bmN0aW9uKCkge1xuXG4gIHZhciB2aXNpdG9yID0ge1xuXG4gICAgJ3Zpc2l0X2xpbmVhci1ncmFkaWVudCc6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0X2dyYWRpZW50KG5vZGUpO1xuICAgIH0sXG5cbiAgICAndmlzaXRfcmVwZWF0aW5nLWxpbmVhci1ncmFkaWVudCc6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0X2dyYWRpZW50KG5vZGUpO1xuICAgIH0sXG5cbiAgICAndmlzaXRfcmFkaWFsLWdyYWRpZW50JzogZnVuY3Rpb24obm9kZSkge1xuICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRfZ3JhZGllbnQobm9kZSk7XG4gICAgfSxcblxuICAgICd2aXNpdF9yZXBlYXRpbmctcmFkaWFsLWdyYWRpZW50JzogZnVuY3Rpb24obm9kZSkge1xuICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRfZ3JhZGllbnQobm9kZSk7XG4gICAgfSxcblxuICAgICd2aXNpdF9ncmFkaWVudCc6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBvcmllbnRhdGlvbiA9IHZpc2l0b3IudmlzaXQobm9kZS5vcmllbnRhdGlvbik7XG4gICAgICBpZiAob3JpZW50YXRpb24pIHtcbiAgICAgICAgb3JpZW50YXRpb24gKz0gJywgJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5vZGUudHlwZSArICcoJyArIG9yaWVudGF0aW9uICsgdmlzaXRvci52aXNpdChub2RlLmNvbG9yU3RvcHMpICsgJyknO1xuICAgIH0sXG5cbiAgICAndmlzaXRfc2hhcGUnOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbm9kZS52YWx1ZSxcbiAgICAgICAgICBhdCA9IHZpc2l0b3IudmlzaXQobm9kZS5hdCksXG4gICAgICAgICAgc3R5bGUgPSB2aXNpdG9yLnZpc2l0KG5vZGUuc3R5bGUpO1xuXG4gICAgICBpZiAoc3R5bGUpIHtcbiAgICAgICAgcmVzdWx0ICs9ICcgJyArIHN0eWxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXQpIHtcbiAgICAgICAgcmVzdWx0ICs9ICcgYXQgJyArIGF0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAndmlzaXRfZGVmYXVsdC1yYWRpYWwnOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gJycsXG4gICAgICAgICAgYXQgPSB2aXNpdG9yLnZpc2l0KG5vZGUuYXQpO1xuXG4gICAgICBpZiAoYXQpIHtcbiAgICAgICAgcmVzdWx0ICs9IGF0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgJ3Zpc2l0X2V4dGVudC1rZXl3b3JkJzogZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IG5vZGUudmFsdWUsXG4gICAgICAgICAgYXQgPSB2aXNpdG9yLnZpc2l0KG5vZGUuYXQpO1xuXG4gICAgICBpZiAoYXQpIHtcbiAgICAgICAgcmVzdWx0ICs9ICcgYXQgJyArIGF0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAndmlzaXRfcG9zaXRpb24ta2V5d29yZCc6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlLnZhbHVlO1xuICAgIH0sXG5cbiAgICAndmlzaXRfcG9zaXRpb24nOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdChub2RlLnZhbHVlLngpICsgJyAnICsgdmlzaXRvci52aXNpdChub2RlLnZhbHVlLnkpO1xuICAgIH0sXG5cbiAgICAndmlzaXRfJSc6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlLnZhbHVlICsgJyUnO1xuICAgIH0sXG5cbiAgICAndmlzaXRfZW0nOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZS52YWx1ZSArICdlbSc7XG4gICAgfSxcblxuICAgICd2aXNpdF9weCc6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlLnZhbHVlICsgJ3B4JztcbiAgICB9LFxuXG4gICAgJ3Zpc2l0X2xpdGVyYWwnOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdF9jb2xvcihub2RlLnZhbHVlLCBub2RlKTtcbiAgICB9LFxuXG4gICAgJ3Zpc2l0X2hleCc6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0X2NvbG9yKCcjJyArIG5vZGUudmFsdWUsIG5vZGUpO1xuICAgIH0sXG5cbiAgICAndmlzaXRfcmdiJzogZnVuY3Rpb24obm9kZSkge1xuICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRfY29sb3IoJ3JnYignICsgbm9kZS52YWx1ZS5qb2luKCcsICcpICsgJyknLCBub2RlKTtcbiAgICB9LFxuXG4gICAgJ3Zpc2l0X3JnYmEnOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdF9jb2xvcigncmdiYSgnICsgbm9kZS52YWx1ZS5qb2luKCcsICcpICsgJyknLCBub2RlKTtcbiAgICB9LFxuXG4gICAgJ3Zpc2l0X2NvbG9yJzogZnVuY3Rpb24ocmVzdWx0Q29sb3IsIG5vZGUpIHtcbiAgICAgIHZhciByZXN1bHQgPSByZXN1bHRDb2xvcixcbiAgICAgICAgICBsZW5ndGggPSB2aXNpdG9yLnZpc2l0KG5vZGUubGVuZ3RoKTtcblxuICAgICAgaWYgKGxlbmd0aCkge1xuICAgICAgICByZXN1bHQgKz0gJyAnICsgbGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgJ3Zpc2l0X2FuZ3VsYXInOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZS52YWx1ZSArICdkZWcnO1xuICAgIH0sXG5cbiAgICAndmlzaXRfZGlyZWN0aW9uYWwnOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICByZXR1cm4gJ3RvICcgKyBub2RlLnZhbHVlO1xuICAgIH0sXG5cbiAgICAndmlzaXRfYXJyYXknOiBmdW5jdGlvbihlbGVtZW50cykge1xuICAgICAgdmFyIHJlc3VsdCA9ICcnLFxuICAgICAgICAgIHNpemUgPSBlbGVtZW50cy5sZW5ndGg7XG5cbiAgICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCwgaSkge1xuICAgICAgICByZXN1bHQgKz0gdmlzaXRvci52aXNpdChlbGVtZW50KTtcbiAgICAgICAgaWYgKGkgPCBzaXplIC0gMSkge1xuICAgICAgICAgIHJlc3VsdCArPSAnLCAnO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgJ3Zpc2l0JzogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSAnJztcblxuICAgICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdF9hcnJheShlbGVtZW50LCByZXN1bHQpO1xuICAgICAgfSBlbHNlIGlmIChlbGVtZW50LnR5cGUpIHtcbiAgICAgICAgdmFyIG5vZGVWaXNpdG9yID0gdmlzaXRvclsndmlzaXRfJyArIGVsZW1lbnQudHlwZV07XG4gICAgICAgIGlmIChub2RlVmlzaXRvcikge1xuICAgICAgICAgIHJldHVybiBub2RlVmlzaXRvcihlbGVtZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcignTWlzc2luZyB2aXNpdG9yIHZpc2l0XycgKyBlbGVtZW50LnR5cGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBFcnJvcignSW52YWxpZCBub2RlLicpO1xuICAgICAgfVxuICAgIH1cblxuICB9O1xuXG4gIHJldHVybiBmdW5jdGlvbihyb290KSB7XG4gICAgcmV0dXJuIHZpc2l0b3IudmlzaXQocm9vdCk7XG4gIH07XG59KSgpO1xuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTQgUmFmYWVsIENhcmljaW8uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4vLyBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlLlxuXG52YXIgR3JhZGllbnRQYXJzZXIgPSAoR3JhZGllbnRQYXJzZXIgfHwge30pO1xuXG5HcmFkaWVudFBhcnNlci5wYXJzZSA9IChmdW5jdGlvbigpIHtcblxuICB2YXIgdG9rZW5zID0ge1xuICAgIGxpbmVhckdyYWRpZW50OiAvXihcXC0od2Via2l0fG98bXN8bW96KVxcLSk/KGxpbmVhclxcLWdyYWRpZW50KS9pLFxuICAgIHJlcGVhdGluZ0xpbmVhckdyYWRpZW50OiAvXihcXC0od2Via2l0fG98bXN8bW96KVxcLSk/KHJlcGVhdGluZ1xcLWxpbmVhclxcLWdyYWRpZW50KS9pLFxuICAgIHJhZGlhbEdyYWRpZW50OiAvXihcXC0od2Via2l0fG98bXN8bW96KVxcLSk/KHJhZGlhbFxcLWdyYWRpZW50KS9pLFxuICAgIHJlcGVhdGluZ1JhZGlhbEdyYWRpZW50OiAvXihcXC0od2Via2l0fG98bXN8bW96KVxcLSk/KHJlcGVhdGluZ1xcLXJhZGlhbFxcLWdyYWRpZW50KS9pLFxuICAgIHNpZGVPckNvcm5lcjogL150byAobGVmdCAodG9wfGJvdHRvbSl8cmlnaHQgKHRvcHxib3R0b20pfGxlZnR8cmlnaHR8dG9wfGJvdHRvbSkvaSxcbiAgICBleHRlbnRLZXl3b3JkczogL14oY2xvc2VzdFxcLXNpZGV8Y2xvc2VzdFxcLWNvcm5lcnxmYXJ0aGVzdFxcLXNpZGV8ZmFydGhlc3RcXC1jb3JuZXJ8Y29udGFpbnxjb3ZlcikvLFxuICAgIHBvc2l0aW9uS2V5d29yZHM6IC9eKGxlZnR8Y2VudGVyfHJpZ2h0fHRvcHxib3R0b20pL2ksXG4gICAgcGl4ZWxWYWx1ZTogL14oLT8oKFswLTldKlxcLlswLTldKyl8KFswLTldK1xcLj8pKSlweC8sXG4gICAgcGVyY2VudGFnZVZhbHVlOiAvXigtPygoWzAtOV0qXFwuWzAtOV0rKXwoWzAtOV0rXFwuPykpKVxcJS8sXG4gICAgZW1WYWx1ZTogL14oLT8oKFswLTldKlxcLlswLTldKyl8KFswLTldK1xcLj8pKSllbS8sXG4gICAgYW5nbGVWYWx1ZTogL14oLT8oKFswLTldKlxcLlswLTldKyl8KFswLTldK1xcLj8pKSlkZWcvLFxuICAgIHN0YXJ0Q2FsbDogL15cXCgvLFxuICAgIGVuZENhbGw6IC9eXFwpLyxcbiAgICBjb21tYTogL14sLyxcbiAgICBoZXhDb2xvcjogL15cXCMoWzAtOWEtZkEtRl0rKS8sXG4gICAgbGl0ZXJhbENvbG9yOiAvXihbYS16QS1aXSspLyxcbiAgICByZ2JDb2xvcjogL15yZ2IvaSxcbiAgICByZ2JhQ29sb3I6IC9ecmdiYS9pLFxuICAgIG51bWJlcjogL14oKFswLTldKlxcLlswLTldKyl8KFswLTldK1xcLj8pKS9cbiAgfTtcblxuICB2YXIgaW5wdXQgPSAnJztcblxuICBmdW5jdGlvbiBlcnJvcihtc2cpIHtcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKGlucHV0ICsgJzogJyArIG1zZyk7XG4gICAgZXJyLnNvdXJjZSA9IGlucHV0O1xuICAgIHRocm93IGVycjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEFTVCgpIHtcbiAgICB2YXIgYXN0ID0gbWF0Y2hMaXN0RGVmaW5pdGlvbnMoKTtcblxuICAgIGlmIChpbnB1dC5sZW5ndGggPiAwKSB7XG4gICAgICBlcnJvcignSW52YWxpZCBpbnB1dCBub3QgRU9GJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFzdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hdGNoTGlzdERlZmluaXRpb25zKCkge1xuICAgIHJldHVybiBtYXRjaExpc3RpbmcobWF0Y2hEZWZpbml0aW9uKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hdGNoRGVmaW5pdGlvbigpIHtcbiAgICByZXR1cm4gbWF0Y2hHcmFkaWVudChcbiAgICAgICAgICAgICdsaW5lYXItZ3JhZGllbnQnLFxuICAgICAgICAgICAgdG9rZW5zLmxpbmVhckdyYWRpZW50LFxuICAgICAgICAgICAgbWF0Y2hMaW5lYXJPcmllbnRhdGlvbikgfHxcblxuICAgICAgICAgIG1hdGNoR3JhZGllbnQoXG4gICAgICAgICAgICAncmVwZWF0aW5nLWxpbmVhci1ncmFkaWVudCcsXG4gICAgICAgICAgICB0b2tlbnMucmVwZWF0aW5nTGluZWFyR3JhZGllbnQsXG4gICAgICAgICAgICBtYXRjaExpbmVhck9yaWVudGF0aW9uKSB8fFxuXG4gICAgICAgICAgbWF0Y2hHcmFkaWVudChcbiAgICAgICAgICAgICdyYWRpYWwtZ3JhZGllbnQnLFxuICAgICAgICAgICAgdG9rZW5zLnJhZGlhbEdyYWRpZW50LFxuICAgICAgICAgICAgbWF0Y2hMaXN0UmFkaWFsT3JpZW50YXRpb25zKSB8fFxuXG4gICAgICAgICAgbWF0Y2hHcmFkaWVudChcbiAgICAgICAgICAgICdyZXBlYXRpbmctcmFkaWFsLWdyYWRpZW50JyxcbiAgICAgICAgICAgIHRva2Vucy5yZXBlYXRpbmdSYWRpYWxHcmFkaWVudCxcbiAgICAgICAgICAgIG1hdGNoTGlzdFJhZGlhbE9yaWVudGF0aW9ucyk7XG4gIH1cblxuICBmdW5jdGlvbiBtYXRjaEdyYWRpZW50KGdyYWRpZW50VHlwZSwgcGF0dGVybiwgb3JpZW50YXRpb25NYXRjaGVyKSB7XG4gICAgcmV0dXJuIG1hdGNoQ2FsbChwYXR0ZXJuLCBmdW5jdGlvbihjYXB0dXJlcykge1xuXG4gICAgICB2YXIgb3JpZW50YXRpb24gPSBvcmllbnRhdGlvbk1hdGNoZXIoKTtcbiAgICAgIGlmIChvcmllbnRhdGlvbikge1xuICAgICAgICBpZiAoIXNjYW4odG9rZW5zLmNvbW1hKSkge1xuICAgICAgICAgIGVycm9yKCdNaXNzaW5nIGNvbW1hIGJlZm9yZSBjb2xvciBzdG9wcycpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IGdyYWRpZW50VHlwZSxcbiAgICAgICAgb3JpZW50YXRpb246IG9yaWVudGF0aW9uLFxuICAgICAgICBjb2xvclN0b3BzOiBtYXRjaExpc3RpbmcobWF0Y2hDb2xvclN0b3ApXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gbWF0Y2hDYWxsKHBhdHRlcm4sIGNhbGxiYWNrKSB7XG4gICAgdmFyIGNhcHR1cmVzID0gc2NhbihwYXR0ZXJuKTtcblxuICAgIGlmIChjYXB0dXJlcykge1xuICAgICAgaWYgKCFzY2FuKHRva2Vucy5zdGFydENhbGwpKSB7XG4gICAgICAgIGVycm9yKCdNaXNzaW5nICgnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdCA9IGNhbGxiYWNrKGNhcHR1cmVzKTtcblxuICAgICAgaWYgKCFzY2FuKHRva2Vucy5lbmRDYWxsKSkge1xuICAgICAgICBlcnJvcignTWlzc2luZyApJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWF0Y2hMaW5lYXJPcmllbnRhdGlvbigpIHtcbiAgICByZXR1cm4gbWF0Y2hTaWRlT3JDb3JuZXIoKSB8fFxuICAgICAgbWF0Y2hBbmdsZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gbWF0Y2hTaWRlT3JDb3JuZXIoKSB7XG4gICAgcmV0dXJuIG1hdGNoKCdkaXJlY3Rpb25hbCcsIHRva2Vucy5zaWRlT3JDb3JuZXIsIDEpO1xuICB9XG5cbiAgZnVuY3Rpb24gbWF0Y2hBbmdsZSgpIHtcbiAgICByZXR1cm4gbWF0Y2goJ2FuZ3VsYXInLCB0b2tlbnMuYW5nbGVWYWx1ZSwgMSk7XG4gIH1cblxuICBmdW5jdGlvbiBtYXRjaExpc3RSYWRpYWxPcmllbnRhdGlvbnMoKSB7XG4gICAgdmFyIHJhZGlhbE9yaWVudGF0aW9ucyxcbiAgICAgICAgcmFkaWFsT3JpZW50YXRpb24gPSBtYXRjaFJhZGlhbE9yaWVudGF0aW9uKCksXG4gICAgICAgIGxvb2thaGVhZENhY2hlO1xuXG4gICAgaWYgKHJhZGlhbE9yaWVudGF0aW9uKSB7XG4gICAgICByYWRpYWxPcmllbnRhdGlvbnMgPSBbXTtcbiAgICAgIHJhZGlhbE9yaWVudGF0aW9ucy5wdXNoKHJhZGlhbE9yaWVudGF0aW9uKTtcblxuICAgICAgbG9va2FoZWFkQ2FjaGUgPSBpbnB1dDtcbiAgICAgIGlmIChzY2FuKHRva2Vucy5jb21tYSkpIHtcbiAgICAgICAgcmFkaWFsT3JpZW50YXRpb24gPSBtYXRjaFJhZGlhbE9yaWVudGF0aW9uKCk7XG4gICAgICAgIGlmIChyYWRpYWxPcmllbnRhdGlvbikge1xuICAgICAgICAgIHJhZGlhbE9yaWVudGF0aW9ucy5wdXNoKHJhZGlhbE9yaWVudGF0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnB1dCA9IGxvb2thaGVhZENhY2hlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhZGlhbE9yaWVudGF0aW9ucztcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hdGNoUmFkaWFsT3JpZW50YXRpb24oKSB7XG4gICAgdmFyIHJhZGlhbFR5cGUgPSBtYXRjaENpcmNsZSgpIHx8XG4gICAgICBtYXRjaEVsbGlwc2UoKTtcblxuICAgIGlmIChyYWRpYWxUeXBlKSB7XG4gICAgICByYWRpYWxUeXBlLmF0ID0gbWF0Y2hBdFBvc2l0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBleHRlbnQgPSBtYXRjaEV4dGVudEtleXdvcmQoKTtcbiAgICAgIGlmIChleHRlbnQpIHtcbiAgICAgICAgcmFkaWFsVHlwZSA9IGV4dGVudDtcbiAgICAgICAgdmFyIHBvc2l0aW9uQXQgPSBtYXRjaEF0UG9zaXRpb24oKTtcbiAgICAgICAgaWYgKHBvc2l0aW9uQXQpIHtcbiAgICAgICAgICByYWRpYWxUeXBlLmF0ID0gcG9zaXRpb25BdDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGRlZmF1bHRQb3NpdGlvbiA9IG1hdGNoUG9zaXRpb25pbmcoKTtcbiAgICAgICAgaWYgKGRlZmF1bHRQb3NpdGlvbikge1xuICAgICAgICAgIHJhZGlhbFR5cGUgPSB7XG4gICAgICAgICAgICB0eXBlOiAnZGVmYXVsdC1yYWRpYWwnLFxuICAgICAgICAgICAgYXQ6IGRlZmF1bHRQb3NpdGlvblxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmFkaWFsVHlwZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hdGNoQ2lyY2xlKCkge1xuICAgIHZhciBjaXJjbGUgPSBtYXRjaCgnc2hhcGUnLCAvXihjaXJjbGUpL2ksIDApO1xuXG4gICAgaWYgKGNpcmNsZSkge1xuICAgICAgY2lyY2xlLnN0eWxlID0gbWF0Y2hMZW5ndGgoKSB8fCBtYXRjaEV4dGVudEtleXdvcmQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2lyY2xlO1xuICB9XG5cbiAgZnVuY3Rpb24gbWF0Y2hFbGxpcHNlKCkge1xuICAgIHZhciBlbGxpcHNlID0gbWF0Y2goJ3NoYXBlJywgL14oZWxsaXBzZSkvaSwgMCk7XG5cbiAgICBpZiAoZWxsaXBzZSkge1xuICAgICAgZWxsaXBzZS5zdHlsZSA9ICBtYXRjaERpc3RhbmNlKCkgfHwgbWF0Y2hFeHRlbnRLZXl3b3JkKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsbGlwc2U7XG4gIH1cblxuICBmdW5jdGlvbiBtYXRjaEV4dGVudEtleXdvcmQoKSB7XG4gICAgcmV0dXJuIG1hdGNoKCdleHRlbnQta2V5d29yZCcsIHRva2Vucy5leHRlbnRLZXl3b3JkcywgMSk7XG4gIH1cblxuICBmdW5jdGlvbiBtYXRjaEF0UG9zaXRpb24oKSB7XG4gICAgaWYgKG1hdGNoKCdwb3NpdGlvbicsIC9eYXQvLCAwKSkge1xuICAgICAgdmFyIHBvc2l0aW9uaW5nID0gbWF0Y2hQb3NpdGlvbmluZygpO1xuXG4gICAgICBpZiAoIXBvc2l0aW9uaW5nKSB7XG4gICAgICAgIGVycm9yKCdNaXNzaW5nIHBvc2l0aW9uaW5nIHZhbHVlJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwb3NpdGlvbmluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtYXRjaFBvc2l0aW9uaW5nKCkge1xuICAgIHZhciBsb2NhdGlvbiA9IG1hdGNoQ29vcmRpbmF0ZXMoKTtcblxuICAgIGlmIChsb2NhdGlvbi54IHx8IGxvY2F0aW9uLnkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdwb3NpdGlvbicsXG4gICAgICAgIHZhbHVlOiBsb2NhdGlvblxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtYXRjaENvb3JkaW5hdGVzKCkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiBtYXRjaERpc3RhbmNlKCksXG4gICAgICB5OiBtYXRjaERpc3RhbmNlKClcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gbWF0Y2hMaXN0aW5nKG1hdGNoZXIpIHtcbiAgICB2YXIgY2FwdHVyZXMgPSBtYXRjaGVyKCksXG4gICAgICByZXN1bHQgPSBbXTtcblxuICAgIGlmIChjYXB0dXJlcykge1xuICAgICAgcmVzdWx0LnB1c2goY2FwdHVyZXMpO1xuICAgICAgd2hpbGUgKHNjYW4odG9rZW5zLmNvbW1hKSkge1xuICAgICAgICBjYXB0dXJlcyA9IG1hdGNoZXIoKTtcbiAgICAgICAgaWYgKGNhcHR1cmVzKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goY2FwdHVyZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVycm9yKCdPbmUgZXh0cmEgY29tbWEnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBtYXRjaENvbG9yU3RvcCgpIHtcbiAgICB2YXIgY29sb3IgPSBtYXRjaENvbG9yKCk7XG5cbiAgICBpZiAoIWNvbG9yKSB7XG4gICAgICBlcnJvcignRXhwZWN0ZWQgY29sb3IgZGVmaW5pdGlvbicpO1xuICAgIH1cblxuICAgIGNvbG9yLmxlbmd0aCA9IG1hdGNoRGlzdGFuY2UoKTtcbiAgICByZXR1cm4gY29sb3I7XG4gIH1cblxuICBmdW5jdGlvbiBtYXRjaENvbG9yKCkge1xuICAgIHJldHVybiBtYXRjaEhleENvbG9yKCkgfHxcbiAgICAgIG1hdGNoUkdCQUNvbG9yKCkgfHxcbiAgICAgIG1hdGNoUkdCQ29sb3IoKSB8fFxuICAgICAgbWF0Y2hMaXRlcmFsQ29sb3IoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hdGNoTGl0ZXJhbENvbG9yKCkge1xuICAgIHJldHVybiBtYXRjaCgnbGl0ZXJhbCcsIHRva2Vucy5saXRlcmFsQ29sb3IsIDApO1xuICB9XG5cbiAgZnVuY3Rpb24gbWF0Y2hIZXhDb2xvcigpIHtcbiAgICByZXR1cm4gbWF0Y2goJ2hleCcsIHRva2Vucy5oZXhDb2xvciwgMSk7XG4gIH1cblxuICBmdW5jdGlvbiBtYXRjaFJHQkNvbG9yKCkge1xuICAgIHJldHVybiBtYXRjaENhbGwodG9rZW5zLnJnYkNvbG9yLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAge1xuICAgICAgICB0eXBlOiAncmdiJyxcbiAgICAgICAgdmFsdWU6IG1hdGNoTGlzdGluZyhtYXRjaE51bWJlcilcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBtYXRjaFJHQkFDb2xvcigpIHtcbiAgICByZXR1cm4gbWF0Y2hDYWxsKHRva2Vucy5yZ2JhQ29sb3IsIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICB7XG4gICAgICAgIHR5cGU6ICdyZ2JhJyxcbiAgICAgICAgdmFsdWU6IG1hdGNoTGlzdGluZyhtYXRjaE51bWJlcilcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBtYXRjaE51bWJlcigpIHtcbiAgICByZXR1cm4gc2Nhbih0b2tlbnMubnVtYmVyKVsxXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hdGNoRGlzdGFuY2UoKSB7XG4gICAgcmV0dXJuIG1hdGNoKCclJywgdG9rZW5zLnBlcmNlbnRhZ2VWYWx1ZSwgMSkgfHxcbiAgICAgIG1hdGNoUG9zaXRpb25LZXl3b3JkKCkgfHxcbiAgICAgIG1hdGNoTGVuZ3RoKCk7XG4gIH1cblxuICBmdW5jdGlvbiBtYXRjaFBvc2l0aW9uS2V5d29yZCgpIHtcbiAgICByZXR1cm4gbWF0Y2goJ3Bvc2l0aW9uLWtleXdvcmQnLCB0b2tlbnMucG9zaXRpb25LZXl3b3JkcywgMSk7XG4gIH1cblxuICBmdW5jdGlvbiBtYXRjaExlbmd0aCgpIHtcbiAgICByZXR1cm4gbWF0Y2goJ3B4JywgdG9rZW5zLnBpeGVsVmFsdWUsIDEpIHx8XG4gICAgICBtYXRjaCgnZW0nLCB0b2tlbnMuZW1WYWx1ZSwgMSk7XG4gIH1cblxuICBmdW5jdGlvbiBtYXRjaCh0eXBlLCBwYXR0ZXJuLCBjYXB0dXJlSW5kZXgpIHtcbiAgICB2YXIgY2FwdHVyZXMgPSBzY2FuKHBhdHRlcm4pO1xuICAgIGlmIChjYXB0dXJlcykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgdmFsdWU6IGNhcHR1cmVzW2NhcHR1cmVJbmRleF1cbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2NhbihyZWdleHApIHtcbiAgICB2YXIgY2FwdHVyZXMsXG4gICAgICAgIGJsYW5rQ2FwdHVyZXM7XG5cbiAgICBibGFua0NhcHR1cmVzID0gL15bXFxuXFxyXFx0XFxzXSsvLmV4ZWMoaW5wdXQpO1xuICAgIGlmIChibGFua0NhcHR1cmVzKSB7XG4gICAgICAgIGNvbnN1bWUoYmxhbmtDYXB0dXJlc1swXS5sZW5ndGgpO1xuICAgIH1cblxuICAgIGNhcHR1cmVzID0gcmVnZXhwLmV4ZWMoaW5wdXQpO1xuICAgIGlmIChjYXB0dXJlcykge1xuICAgICAgICBjb25zdW1lKGNhcHR1cmVzWzBdLmxlbmd0aCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNhcHR1cmVzO1xuICB9XG5cbiAgZnVuY3Rpb24gY29uc3VtZShzaXplKSB7XG4gICAgaW5wdXQgPSBpbnB1dC5zdWJzdHIoc2l6ZSk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24oY29kZSkge1xuICAgIGlucHV0ID0gY29kZS50b1N0cmluZygpO1xuICAgIHJldHVybiBnZXRBU1QoKTtcbiAgfTtcbn0pKCk7XG5cbnZhciBwYXJzZSA9IEdyYWRpZW50UGFyc2VyLnBhcnNlO1xuR3JhZGllbnRQYXJzZXIuc3RyaW5naWZ5O1xuXG5leHBvcnQgeyBwYXJzZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bm9kZS5tanMubWFwXG4iLCJpbXBvcnQgeyBwYXJzZSB9IGZyb20gJy4uL2V4dGVybmFsL2dyYWRpZW50LXBhcnNlci9idWlsZC9ub2RlLm1qcyc7XG5pbXBvcnQgeyBDb2xvciB9IGZyb20gJ3BpeGkuanMnO1xuXG5mdW5jdGlvbiBwYXJzZUNzc0dyYWRpZW50KGNzc0dyYWRpZW50KSB7XG4gIGNvbnN0IGNzc0dyYWRpZW50Tm9kZXMgPSBwYXJzZSh0cmltQ3NzR3JhZGllbnQoY3NzR3JhZGllbnQpKTtcbiAgaWYgKGNzc0dyYWRpZW50Tm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBDU1MgZ3JhZGllbnQuXCIpO1xuICB9IGVsc2UgaWYgKGNzc0dyYWRpZW50Tm9kZXMubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgQ1NTIGdyYWRpZW50IChtdWx0aXBsZSBncmFkaWVudHMgaXMgbm90IHN1cHBvcnRlZCkuXCIpO1xuICB9XG4gIGNvbnN0IGNzc0dyYWRpZW50Tm9kZSA9IGNzc0dyYWRpZW50Tm9kZXNbMF07XG4gIGNvbnN0IHR5cGUgPSB0eXBlRnJvbUNzc1R5cGUoY3NzR3JhZGllbnROb2RlLnR5cGUpO1xuICBjb25zdCBzdG9wcyA9IHN0b3BzRnJvbUNzc1N0b3BzKGNzc0dyYWRpZW50Tm9kZS5jb2xvclN0b3BzKTtcbiAgY29uc3QgYW5nbGUgPSBhbmdsZUZyb21Dc3NPcmllbnRhdGlvbihjc3NHcmFkaWVudE5vZGUub3JpZW50YXRpb24pO1xuICByZXR1cm4ge1xuICAgIHR5cGUsXG4gICAgc3RvcHMsXG4gICAgYW5nbGVcbiAgfTtcbn1cbmZ1bmN0aW9uIHR5cGVGcm9tQ3NzVHlwZSh0eXBlKSB7XG4gIGNvbnN0IHN1cHBvcnRlZFR5cGVzID0ge1xuICAgIFwibGluZWFyLWdyYWRpZW50XCI6IDAsXG4gICAgXCJyYWRpYWwtZ3JhZGllbnRcIjogMVxuICB9O1xuICBpZiAoISh0eXBlIGluIHN1cHBvcnRlZFR5cGVzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZ3JhZGllbnQgdHlwZSBcIiR7dHlwZX1cImApO1xuICB9XG4gIHJldHVybiBzdXBwb3J0ZWRUeXBlc1t0eXBlXTtcbn1cbmZ1bmN0aW9uIHN0b3BzRnJvbUNzc1N0b3BzKHN0b3BzKSB7XG4gIGNvbnN0IG9mZnNldHMgPSBvZmZzZXRzRnJvbUNzc0NvbG9yU3RvcHMoc3RvcHMpO1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgY29uc3QgY29sb3IgPSBuZXcgQ29sb3IoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdG9wcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNvbG9yU3RyaW5nID0gY29sb3JBc1N0cmluZ0Zyb21Dc3NTdG9wKHN0b3BzW2ldKTtcbiAgICBjb25zdCByZ2JhQ29sb3IgPSBjb2xvci5zZXRWYWx1ZShjb2xvclN0cmluZykudG9BcnJheSgpO1xuICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgIG9mZnNldDogb2Zmc2V0c1tpXSxcbiAgICAgIGNvbG9yOiByZ2JhQ29sb3Iuc2xpY2UoMCwgMyksXG4gICAgICBhbHBoYTogcmdiYUNvbG9yWzNdXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGNvbG9yQXNTdHJpbmdGcm9tQ3NzU3RvcChzdG9wKSB7XG4gIHN3aXRjaCAoc3RvcC50eXBlKSB7XG4gICAgY2FzZSBcImhleFwiOlxuICAgICAgcmV0dXJuIGAjJHtzdG9wLnZhbHVlfWA7XG4gICAgY2FzZSBcImxpdGVyYWxcIjpcbiAgICAgIHJldHVybiBzdG9wLnZhbHVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gYCR7c3RvcC50eXBlfSgke3N0b3AudmFsdWUuam9pbihcIixcIil9KWA7XG4gIH1cbn1cbmZ1bmN0aW9uIG9mZnNldHNGcm9tQ3NzQ29sb3JTdG9wcyhzdG9wcykge1xuICBjb25zdCBvZmZzZXRzID0gW107XG4gIGNvbnN0IGR5bmFtaWNPZmZzZXQgPSAtMTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdG9wcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNzc1N0b3AgPSBzdG9wc1tpXTtcbiAgICBsZXQgc3RvcE9mZnNldCA9IGR5bmFtaWNPZmZzZXQ7XG4gICAgaWYgKGNzc1N0b3AudHlwZSA9PT0gXCJsaXRlcmFsXCIpIHtcbiAgICAgIGlmIChjc3NTdG9wLmxlbmd0aCAmJiBcInR5cGVcIiBpbiBjc3NTdG9wLmxlbmd0aCAmJiBjc3NTdG9wLmxlbmd0aC50eXBlID09PSBcIiVcIiAmJiBcInZhbHVlXCIgaW4gY3NzU3RvcC5sZW5ndGgpIHtcbiAgICAgICAgc3RvcE9mZnNldCA9IHBhcnNlRmxvYXQoY3NzU3RvcC5sZW5ndGgudmFsdWUpIC8gMTAwO1xuICAgICAgfVxuICAgIH1cbiAgICBvZmZzZXRzLnB1c2goc3RvcE9mZnNldCk7XG4gIH1cbiAgY29uc3QgZmluZE5leHRGaXhlZFN0b3AgPSAoZnJvbUluZGV4KSA9PiB7XG4gICAgZm9yIChsZXQgayA9IGZyb21JbmRleDsgayA8IG9mZnNldHMubGVuZ3RoOyBrKyspIHtcbiAgICAgIGlmIChvZmZzZXRzW2tdICE9PSBkeW5hbWljT2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaW5kZXhEZWx0YTogayAtIGZyb21JbmRleCxcbiAgICAgICAgICBvZmZzZXQ6IG9mZnNldHNba11cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGluZGV4RGVsdGE6IG9mZnNldHMubGVuZ3RoIC0gMSAtIGZyb21JbmRleCxcbiAgICAgIG9mZnNldDogMVxuICAgIH07XG4gIH07XG4gIGxldCBwcmV2Rml4ZWRPZmZzZXQgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG9mZnNldHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBvZmZzZXQgPSBvZmZzZXRzW2ldO1xuICAgIGlmIChvZmZzZXQgIT09IGR5bmFtaWNPZmZzZXQpIHtcbiAgICAgIHByZXZGaXhlZE9mZnNldCA9IG9mZnNldDtcbiAgICB9IGVsc2UgaWYgKGkgPT09IDApIHtcbiAgICAgIG9mZnNldHNbaV0gPSAwO1xuICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IG9mZnNldHMubGVuZ3RoKSB7XG4gICAgICBvZmZzZXRzW2ldID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbmV4dEZpeGVkID0gZmluZE5leHRGaXhlZFN0b3AoaSk7XG4gICAgICBjb25zdCBvZmZzZXREZWx0YSA9IG5leHRGaXhlZC5vZmZzZXQgLSBwcmV2Rml4ZWRPZmZzZXQ7XG4gICAgICBjb25zdCBzdGVwU2l6ZSA9IG9mZnNldERlbHRhIC8gKDEgKyBuZXh0Rml4ZWQuaW5kZXhEZWx0YSk7XG4gICAgICBmb3IgKGxldCBzID0gMDsgcyA8PSBuZXh0Rml4ZWQuaW5kZXhEZWx0YTsgcysrKSB7XG4gICAgICAgIG9mZnNldHNbaSArIHNdID0gcHJldkZpeGVkT2Zmc2V0ICsgKHMgKyAxKSAqIHN0ZXBTaXplO1xuICAgICAgfVxuICAgICAgaSArPSBuZXh0Rml4ZWQuaW5kZXhEZWx0YTtcbiAgICAgIHByZXZGaXhlZE9mZnNldCA9IG9mZnNldHNbaV07XG4gICAgfVxuICB9XG4gIHJldHVybiBvZmZzZXRzLm1hcChmaXhGbG9hdFJvdW5kaW5nKTtcbn1cbmZ1bmN0aW9uIGZpeEZsb2F0Um91bmRpbmcodmFsdWUpIHtcbiAgY29uc3QgbWF4TGVuZ3RoID0gNjtcbiAgaWYgKHZhbHVlLnRvU3RyaW5nKCkubGVuZ3RoID4gbWF4TGVuZ3RoKSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUudG9TdHJpbmcoKS5zdWJzdHJpbmcoMCwgbWF4TGVuZ3RoKSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gYW5nbGVGcm9tQ3NzT3JpZW50YXRpb24ob3JpZW50YXRpb24pIHtcbiAgaWYgKHR5cGVvZiBvcmllbnRhdGlvbiA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGlmIChcInR5cGVcIiBpbiBvcmllbnRhdGlvbiAmJiBcInZhbHVlXCIgaW4gb3JpZW50YXRpb24pIHtcbiAgICBzd2l0Y2ggKG9yaWVudGF0aW9uLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJhbmd1bGFyXCI6XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KG9yaWVudGF0aW9uLnZhbHVlKTtcbiAgICAgIGNhc2UgXCJkaXJlY3Rpb25hbFwiOlxuICAgICAgICByZXR1cm4gYW5nbGVGcm9tRGlyZWN0aW9uYWxWYWx1ZShvcmllbnRhdGlvbi52YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufVxuZnVuY3Rpb24gYW5nbGVGcm9tRGlyZWN0aW9uYWxWYWx1ZSh2YWx1ZSkge1xuICBjb25zdCBzdXBwb3J0ZWRWYWx1ZXMgPSB7XG4gICAgbGVmdDogMjcwLFxuICAgIHRvcDogMCxcbiAgICBib3R0b206IDE4MCxcbiAgICByaWdodDogOTAsXG4gICAgXCJsZWZ0IHRvcFwiOiAzMTUsXG4gICAgXCJ0b3AgbGVmdFwiOiAzMTUsXG4gICAgXCJsZWZ0IGJvdHRvbVwiOiAyMjUsXG4gICAgXCJib3R0b20gbGVmdFwiOiAyMjUsXG4gICAgXCJyaWdodCB0b3BcIjogNDUsXG4gICAgXCJ0b3AgcmlnaHRcIjogNDUsXG4gICAgXCJyaWdodCBib3R0b21cIjogMTM1LFxuICAgIFwiYm90dG9tIHJpZ2h0XCI6IDEzNVxuICB9O1xuICBpZiAoISh2YWx1ZSBpbiBzdXBwb3J0ZWRWYWx1ZXMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBkaXJlY3Rpb25hbCB2YWx1ZSBcIiR7dmFsdWV9XCJgKTtcbiAgfVxuICByZXR1cm4gc3VwcG9ydGVkVmFsdWVzW3ZhbHVlXTtcbn1cbmZ1bmN0aW9uIHRyaW1Dc3NHcmFkaWVudCh2YWx1ZSkge1xuICBsZXQgdmFsdWVfID0gdmFsdWUucmVwbGFjZSgvXFxzezIsfS9ndSwgXCIgXCIpO1xuICB2YWx1ZV8gPSB2YWx1ZV8ucmVwbGFjZSgvOy9nLCBcIlwiKTtcbiAgdmFsdWVfID0gdmFsdWVfLnJlcGxhY2UoLyAsL2csIFwiLFwiKTtcbiAgdmFsdWVfID0gdmFsdWVfLnJlcGxhY2UoL1xcKCAvZywgXCIoXCIpO1xuICB2YWx1ZV8gPSB2YWx1ZV8ucmVwbGFjZSgvIFxcKS9nLCBcIilcIik7XG4gIHJldHVybiB2YWx1ZV8udHJpbSgpO1xufVxuXG5leHBvcnQgeyBhbmdsZUZyb21Dc3NPcmllbnRhdGlvbiwgYW5nbGVGcm9tRGlyZWN0aW9uYWxWYWx1ZSwgY29sb3JBc1N0cmluZ0Zyb21Dc3NTdG9wLCBvZmZzZXRzRnJvbUNzc0NvbG9yU3RvcHMsIHBhcnNlQ3NzR3JhZGllbnQsIHN0b3BzRnJvbUNzc1N0b3BzLCB0cmltQ3NzR3JhZGllbnQsIHR5cGVGcm9tQ3NzVHlwZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q3NzR3JhZGllbnRQYXJzZXIubWpzLm1hcFxuIiwiaW1wb3J0IHsgVGV4dHVyZSwgRmlsdGVyLCBUZXh0dXJlU291cmNlLCBkZXByZWNhdGlvbiwgR3B1UHJvZ3JhbSwgR2xQcm9ncmFtIH0gZnJvbSAncGl4aS5qcyc7XG5pbXBvcnQgdmVydGV4IGZyb20gJy4uL2RlZmF1bHRzL2RlZmF1bHQyLm1qcyc7XG5pbXBvcnQgd2dzbFZlcnRleCBmcm9tICcuLi9kZWZhdWx0cy9kZWZhdWx0Lm1qcyc7XG5pbXBvcnQgZnJhZ21lbnQgZnJvbSAnLi9jb2xvci1tYXAyLm1qcyc7XG5pbXBvcnQgc291cmNlIGZyb20gJy4vY29sb3ItbWFwLm1qcyc7XG5cbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbmNvbnN0IF9Db2xvck1hcEZpbHRlciA9IGNsYXNzIF9Db2xvck1hcEZpbHRlciBleHRlbmRzIEZpbHRlciB7XG4gIC8qKiBAaWdub3JlICovXG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3NbMF0gPz8ge307XG4gICAgaWYgKG9wdGlvbnMgaW5zdGFuY2VvZiBUZXh0dXJlIHx8IG9wdGlvbnMgaW5zdGFuY2VvZiBUZXh0dXJlU291cmNlKSB7XG4gICAgICBkZXByZWNhdGlvbihcIjYuMC4wXCIsIFwiQ29sb3JNYXBGaWx0ZXIgY29uc3RydWN0b3IgcGFyYW1zIGFyZSBub3cgb3B0aW9ucyBvYmplY3QuIFNlZSBwYXJhbXM6IHsgY29sb3JNYXAsIG5lYXJlc3QsIG1peCB9XCIpO1xuICAgICAgb3B0aW9ucyA9IHsgY29sb3JNYXA6IG9wdGlvbnMgfTtcbiAgICAgIGlmIChhcmdzWzFdICE9PSB2b2lkIDApXG4gICAgICAgIG9wdGlvbnMubmVhcmVzdCA9IGFyZ3NbMV07XG4gICAgICBpZiAoYXJnc1syXSAhPT0gdm9pZCAwKVxuICAgICAgICBvcHRpb25zLm1peCA9IGFyZ3NbMl07XG4gICAgfVxuICAgIG9wdGlvbnMgPSB7IC4uLl9Db2xvck1hcEZpbHRlci5ERUZBVUxUX09QVElPTlMsIC4uLm9wdGlvbnMgfTtcbiAgICBpZiAoIW9wdGlvbnMuY29sb3JNYXApXG4gICAgICB0aHJvdyBFcnJvcihcIk5vIGNvbG9yIG1hcCB0ZXh0dXJlIHNvdXJjZSB3YXMgcHJvdmlkZWQgdG8gQ29sb3JNYXBGaWx0ZXJcIik7XG4gICAgY29uc3QgZ3B1UHJvZ3JhbSA9IEdwdVByb2dyYW0uZnJvbSh7XG4gICAgICB2ZXJ0ZXg6IHtcbiAgICAgICAgc291cmNlOiB3Z3NsVmVydGV4LFxuICAgICAgICBlbnRyeVBvaW50OiBcIm1haW5WZXJ0ZXhcIlxuICAgICAgfSxcbiAgICAgIGZyYWdtZW50OiB7XG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgZW50cnlQb2ludDogXCJtYWluRnJhZ21lbnRcIlxuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGdsUHJvZ3JhbSA9IEdsUHJvZ3JhbS5mcm9tKHtcbiAgICAgIHZlcnRleCxcbiAgICAgIGZyYWdtZW50LFxuICAgICAgbmFtZTogXCJjb2xvci1tYXAtZmlsdGVyXCJcbiAgICB9KTtcbiAgICBzdXBlcih7XG4gICAgICBncHVQcm9ncmFtLFxuICAgICAgZ2xQcm9ncmFtLFxuICAgICAgcmVzb3VyY2VzOiB7XG4gICAgICAgIGNvbG9yTWFwVW5pZm9ybXM6IHtcbiAgICAgICAgICB1TWl4OiB7IHZhbHVlOiBvcHRpb25zLm1peCwgdHlwZTogXCJmMzJcIiB9LFxuICAgICAgICAgIHVTaXplOiB7IHZhbHVlOiAwLCB0eXBlOiBcImYzMlwiIH0sXG4gICAgICAgICAgdVNsaWNlU2l6ZTogeyB2YWx1ZTogMCwgdHlwZTogXCJmMzJcIiB9LFxuICAgICAgICAgIHVTbGljZVBpeGVsU2l6ZTogeyB2YWx1ZTogMCwgdHlwZTogXCJmMzJcIiB9LFxuICAgICAgICAgIHVTbGljZUlubmVyU2l6ZTogeyB2YWx1ZTogMCwgdHlwZTogXCJmMzJcIiB9XG4gICAgICAgIH0sXG4gICAgICAgIHVNYXBUZXh0dXJlOiBvcHRpb25zLmNvbG9yTWFwLnNvdXJjZSxcbiAgICAgICAgdU1hcFNhbXBsZXI6IG9wdGlvbnMuY29sb3JNYXAuc291cmNlLnN0eWxlXG4gICAgICB9XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInVuaWZvcm1zXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfc2l6ZVwiLCAwKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX3NsaWNlU2l6ZVwiLCAwKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX3NsaWNlUGl4ZWxTaXplXCIsIDApO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfc2xpY2VJbm5lclNpemVcIiwgMCk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9uZWFyZXN0XCIsIGZhbHNlKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX3NjYWxlTW9kZVwiLCBcImxpbmVhclwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX2NvbG9yTWFwXCIpO1xuICAgIHRoaXMudW5pZm9ybXMgPSB0aGlzLnJlc291cmNlcy5jb2xvck1hcFVuaWZvcm1zLnVuaWZvcm1zO1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywgb3B0aW9ucyk7XG4gIH1cbiAgLyoqIFRoZSBtaXggZnJvbSAwIHRvIDEsIHdoZXJlIDAgaXMgdGhlIG9yaWdpbmFsIGltYWdlIGFuZCAxIGlzIHRoZSBjb2xvciBtYXBwZWQgaW1hZ2UuICovXG4gIGdldCBtaXgoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMudU1peDtcbiAgfVxuICBzZXQgbWl4KHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy51TWl4ID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBzaXplIG9mIG9uZSBjb2xvciBzbGljZS5cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgY29sb3JTaXplKCkge1xuICAgIHJldHVybiB0aGlzLl9zaXplO1xuICB9XG4gIC8qKiBUaGUgY29sb3JNYXAgdGV4dHVyZS4gKi9cbiAgZ2V0IGNvbG9yTWFwKCkge1xuICAgIHJldHVybiB0aGlzLl9jb2xvck1hcDtcbiAgfVxuICBzZXQgY29sb3JNYXAodmFsdWUpIHtcbiAgICBpZiAoIXZhbHVlIHx8IHZhbHVlID09PSB0aGlzLmNvbG9yTWFwKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHNvdXJjZTIgPSB2YWx1ZSBpbnN0YW5jZW9mIFRleHR1cmUgPyB2YWx1ZS5zb3VyY2UgOiB2YWx1ZTtcbiAgICBzb3VyY2UyLnN0eWxlLnNjYWxlTW9kZSA9IHRoaXMuX3NjYWxlTW9kZTtcbiAgICBzb3VyY2UyLmF1dG9HZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcbiAgICB0aGlzLl9zaXplID0gc291cmNlMi5oZWlnaHQ7XG4gICAgdGhpcy5fc2xpY2VTaXplID0gMSAvIHRoaXMuX3NpemU7XG4gICAgdGhpcy5fc2xpY2VQaXhlbFNpemUgPSB0aGlzLl9zbGljZVNpemUgLyB0aGlzLl9zaXplO1xuICAgIHRoaXMuX3NsaWNlSW5uZXJTaXplID0gdGhpcy5fc2xpY2VQaXhlbFNpemUgKiAodGhpcy5fc2l6ZSAtIDEpO1xuICAgIHRoaXMudW5pZm9ybXMudVNpemUgPSB0aGlzLl9zaXplO1xuICAgIHRoaXMudW5pZm9ybXMudVNsaWNlU2l6ZSA9IHRoaXMuX3NsaWNlU2l6ZTtcbiAgICB0aGlzLnVuaWZvcm1zLnVTbGljZVBpeGVsU2l6ZSA9IHRoaXMuX3NsaWNlUGl4ZWxTaXplO1xuICAgIHRoaXMudW5pZm9ybXMudVNsaWNlSW5uZXJTaXplID0gdGhpcy5fc2xpY2VJbm5lclNpemU7XG4gICAgdGhpcy5yZXNvdXJjZXMudU1hcFRleHR1cmUgPSBzb3VyY2UyO1xuICAgIHRoaXMuX2NvbG9yTWFwID0gdmFsdWU7XG4gIH1cbiAgLyoqIFdoZXRoZXIgdXNlIE5FQVJFU1QgZm9yIGNvbG9yTWFwIHRleHR1cmUuICovXG4gIGdldCBuZWFyZXN0KCkge1xuICAgIHJldHVybiB0aGlzLl9uZWFyZXN0O1xuICB9XG4gIHNldCBuZWFyZXN0KG5lYXJlc3QpIHtcbiAgICB0aGlzLl9uZWFyZXN0ID0gbmVhcmVzdDtcbiAgICB0aGlzLl9zY2FsZU1vZGUgPSBuZWFyZXN0ID8gXCJuZWFyZXN0XCIgOiBcImxpbmVhclwiO1xuICAgIGNvbnN0IHRleHR1cmUgPSB0aGlzLl9jb2xvck1hcDtcbiAgICBpZiAodGV4dHVyZSAmJiB0ZXh0dXJlLnNvdXJjZSkge1xuICAgICAgdGV4dHVyZS5zb3VyY2Uuc2NhbGVNb2RlID0gdGhpcy5fc2NhbGVNb2RlO1xuICAgICAgdGV4dHVyZS5zb3VyY2UuYXV0b0dlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuICAgICAgdGV4dHVyZS5zb3VyY2Uuc3R5bGUudXBkYXRlKCk7XG4gICAgICB0ZXh0dXJlLnNvdXJjZS51cGRhdGUoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIElmIHRoZSBjb2xvck1hcCBpcyBiYXNlZCBvbiBjYW52YXMsXG4gICAqIGFuZCB0aGUgY29udGVudCBvZiBjYW52YXMgaGFzIGNoYW5nZWQsIHRoZW4gY2FsbCBgdXBkYXRlQ29sb3JNYXBgIGZvciB1cGRhdGUgdGV4dHVyZS5cbiAgICovXG4gIHVwZGF0ZUNvbG9yTWFwKCkge1xuICAgIGNvbnN0IHRleHR1cmUgPSB0aGlzLl9jb2xvck1hcDtcbiAgICBpZiAodGV4dHVyZT8uc291cmNlKSB7XG4gICAgICB0ZXh0dXJlLnNvdXJjZS51cGRhdGUoKTtcbiAgICAgIHRoaXMuY29sb3JNYXAgPSB0ZXh0dXJlO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRGVzdHJveXMgdGhpcyBmaWx0ZXJcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fY29sb3JNYXA/LmRlc3Ryb3koXG4gICAgICAvKiogdHJ1ZSB8IFRPRE86IFNob3VsZCBiYXNlIHRleHR1cmUgYmUgZGVzdHJveWVkPyAqKi9cbiAgICApO1xuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgfVxufTtcbi8qKiBEZWZhdWx0IHZhbHVlcyBmb3Igb3B0aW9ucy4gKi9cbl9fcHVibGljRmllbGQoX0NvbG9yTWFwRmlsdGVyLCBcIkRFRkFVTFRfT1BUSU9OU1wiLCB7XG4gIGNvbG9yTWFwOiBUZXh0dXJlLldISVRFLFxuICBuZWFyZXN0OiBmYWxzZSxcbiAgbWl4OiAxXG59KTtcbmxldCBDb2xvck1hcEZpbHRlciA9IF9Db2xvck1hcEZpbHRlcjtcblxuZXhwb3J0IHsgQ29sb3JNYXBGaWx0ZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbG9yTWFwRmlsdGVyLm1qcy5tYXBcbiIsInZhciBzb3VyY2UgPSBcInN0cnVjdCBDb2xvck1hcFVuaWZvcm1zIHtcXG4gIHVNaXg6IGYzMixcXG4gIHVTaXplOiBmMzIsXFxuICB1U2xpY2VTaXplOiBmMzIsXFxuICB1U2xpY2VQaXhlbFNpemU6IGYzMixcXG4gIHVTbGljZUlubmVyU2l6ZTogZjMyLFxcbn07XFxuXFxuQGdyb3VwKDApIEBiaW5kaW5nKDEpIHZhciB1VGV4dHVyZTogdGV4dHVyZV8yZDxmMzI+OyBcXG5AZ3JvdXAoMCkgQGJpbmRpbmcoMikgdmFyIHVTYW1wbGVyOiBzYW1wbGVyO1xcbkBncm91cCgxKSBAYmluZGluZygwKSB2YXI8dW5pZm9ybT4gY29sb3JNYXBVbmlmb3JtcyA6IENvbG9yTWFwVW5pZm9ybXM7XFxuQGdyb3VwKDEpIEBiaW5kaW5nKDEpIHZhciB1TWFwVGV4dHVyZTogdGV4dHVyZV8yZDxmMzI+O1xcbkBncm91cCgxKSBAYmluZGluZygyKSB2YXIgdU1hcFNhbXBsZXI6IHNhbXBsZXI7XFxuXFxuQGZyYWdtZW50XFxuZm4gbWFpbkZyYWdtZW50KFxcbiAgQGJ1aWx0aW4ocG9zaXRpb24pIHBvc2l0aW9uOiB2ZWM0PGYzMj4sXFxuICBAbG9jYXRpb24oMCkgdXYgOiB2ZWMyPGYzMj5cXG4pIC0+IEBsb2NhdGlvbigwKSB2ZWM0PGYzMj4ge1xcbiAgdmFyIGNvbG9yOnZlYzQ8ZjMyPiA9IHRleHR1cmVTYW1wbGUodVRleHR1cmUsIHVTYW1wbGVyLCB1dik7XFxuXFxuICB2YXIgYWRqdXN0ZWQ6IHZlYzQ8ZjMyPjtcXG5cXG4gIHZhciBhbHRDb2xvcjogdmVjNDxmMzI+ID0gdmVjNDxmMzI+KGNvbG9yLnJnYiAvIGNvbG9yLmEsIGNvbG9yLmEpO1xcbiAgbGV0IGlubmVyV2lkdGg6IGYzMiA9IGNvbG9yTWFwVW5pZm9ybXMudVNpemUgLSAxLjA7XFxuICBsZXQgelNsaWNlMDogZjMyID0gbWluKGZsb29yKGNvbG9yLmIgKiBpbm5lcldpZHRoKSwgaW5uZXJXaWR0aCk7XFxuICBsZXQgelNsaWNlMTogZjMyID0gbWluKHpTbGljZTAgKyAxLjAsIGlubmVyV2lkdGgpO1xcbiAgbGV0IHhPZmZzZXQ6IGYzMiA9IGNvbG9yTWFwVW5pZm9ybXMudVNsaWNlUGl4ZWxTaXplICogMC41ICsgY29sb3IuciAqIGNvbG9yTWFwVW5pZm9ybXMudVNsaWNlSW5uZXJTaXplO1xcbiAgbGV0IHMwOiBmMzIgPSB4T2Zmc2V0ICsgKHpTbGljZTAgKiBjb2xvck1hcFVuaWZvcm1zLnVTbGljZVNpemUpO1xcbiAgbGV0IHMxOiBmMzIgPSB4T2Zmc2V0ICsgKHpTbGljZTEgKiBjb2xvck1hcFVuaWZvcm1zLnVTbGljZVNpemUpO1xcbiAgbGV0IHlPZmZzZXQ6IGYzMiA9IGNvbG9yTWFwVW5pZm9ybXMudVNsaWNlU2l6ZSAqIDAuNSArIGNvbG9yLmcgKiAoMS4wIC0gY29sb3JNYXBVbmlmb3Jtcy51U2xpY2VTaXplKTtcXG4gIGxldCBzbGljZTBDb2xvcjogdmVjNDxmMzI+ID0gdGV4dHVyZVNhbXBsZSh1TWFwVGV4dHVyZSwgdU1hcFNhbXBsZXIsIHZlYzIoczAseU9mZnNldCkpO1xcbiAgbGV0IHNsaWNlMUNvbG9yOiB2ZWM0PGYzMj4gPSB0ZXh0dXJlU2FtcGxlKHVNYXBUZXh0dXJlLCB1TWFwU2FtcGxlciwgdmVjMihzMSx5T2Zmc2V0KSk7XFxuICBsZXQgek9mZnNldDogZjMyID0gZnJhY3QoY29sb3IuYiAqIGlubmVyV2lkdGgpO1xcbiAgYWRqdXN0ZWQgPSBtaXgoc2xpY2UwQ29sb3IsIHNsaWNlMUNvbG9yLCB6T2Zmc2V0KTtcXG4gIGFsdENvbG9yID0gdmVjNDxmMzI+KGNvbG9yLnJnYiAqIGNvbG9yLmEsIGNvbG9yLmEpO1xcblxcbiAgbGV0IHJlYWxDb2xvcjogdmVjNDxmMzI+ID0gc2VsZWN0KGNvbG9yLCBhbHRDb2xvciwgY29sb3IuYSA+IDAuMCk7XFxuXFxuICByZXR1cm4gdmVjNDxmMzI+KG1peChyZWFsQ29sb3IsIGFkanVzdGVkLCBjb2xvck1hcFVuaWZvcm1zLnVNaXgpLnJnYiwgcmVhbENvbG9yLmEpO1xcbn1cIjtcblxuZXhwb3J0IHsgc291cmNlIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbG9yLW1hcC5tanMubWFwXG4iLCJ2YXIgZnJhZ21lbnQgPSBcImluIHZlYzIgdlRleHR1cmVDb29yZDtcXG5vdXQgdmVjNCBmaW5hbENvbG9yO1xcblxcbnVuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVNYXBUZXh0dXJlO1xcbnVuaWZvcm0gZmxvYXQgdU1peDtcXG51bmlmb3JtIGZsb2F0IHVTaXplO1xcbnVuaWZvcm0gZmxvYXQgdVNsaWNlU2l6ZTtcXG51bmlmb3JtIGZsb2F0IHVTbGljZVBpeGVsU2l6ZTtcXG51bmlmb3JtIGZsb2F0IHVTbGljZUlubmVyU2l6ZTtcXG5cXG52b2lkIG1haW4oKSB7XFxuICAgIHZlYzQgY29sb3IgPSB0ZXh0dXJlKHVUZXh0dXJlLCB2VGV4dHVyZUNvb3JkLnh5KTtcXG4gICAgdmVjNCBhZGp1c3RlZDtcXG5cXG4gICAgaWYgKGNvbG9yLmEgPiAwLjApIHtcXG4gICAgICAgIGNvbG9yLnJnYiAvPSBjb2xvci5hO1xcbiAgICAgICAgZmxvYXQgaW5uZXJXaWR0aCA9IHVTaXplIC0gMS4wO1xcbiAgICAgICAgZmxvYXQgelNsaWNlMCA9IG1pbihmbG9vcihjb2xvci5iICogaW5uZXJXaWR0aCksIGlubmVyV2lkdGgpO1xcbiAgICAgICAgZmxvYXQgelNsaWNlMSA9IG1pbih6U2xpY2UwICsgMS4wLCBpbm5lcldpZHRoKTtcXG4gICAgICAgIGZsb2F0IHhPZmZzZXQgPSB1U2xpY2VQaXhlbFNpemUgKiAwLjUgKyBjb2xvci5yICogdVNsaWNlSW5uZXJTaXplO1xcbiAgICAgICAgZmxvYXQgczAgPSB4T2Zmc2V0ICsgKHpTbGljZTAgKiB1U2xpY2VTaXplKTtcXG4gICAgICAgIGZsb2F0IHMxID0geE9mZnNldCArICh6U2xpY2UxICogdVNsaWNlU2l6ZSk7XFxuICAgICAgICBmbG9hdCB5T2Zmc2V0ID0gdVNsaWNlU2l6ZSAqIDAuNSArIGNvbG9yLmcgKiAoMS4wIC0gdVNsaWNlU2l6ZSk7XFxuICAgICAgICB2ZWM0IHNsaWNlMENvbG9yID0gdGV4dHVyZSh1TWFwVGV4dHVyZSwgdmVjMihzMCx5T2Zmc2V0KSk7XFxuICAgICAgICB2ZWM0IHNsaWNlMUNvbG9yID0gdGV4dHVyZSh1TWFwVGV4dHVyZSwgdmVjMihzMSx5T2Zmc2V0KSk7XFxuICAgICAgICBmbG9hdCB6T2Zmc2V0ID0gZnJhY3QoY29sb3IuYiAqIGlubmVyV2lkdGgpO1xcbiAgICAgICAgYWRqdXN0ZWQgPSBtaXgoc2xpY2UwQ29sb3IsIHNsaWNlMUNvbG9yLCB6T2Zmc2V0KTtcXG5cXG4gICAgICAgIGNvbG9yLnJnYiAqPSBjb2xvci5hO1xcbiAgICB9XFxuXFxuICAgIGZpbmFsQ29sb3IgPSB2ZWM0KG1peChjb2xvciwgYWRqdXN0ZWQsIHVNaXgpLnJnYiwgY29sb3IuYSk7XFxuXFxufVwiO1xuXG5leHBvcnQgeyBmcmFnbWVudCBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2xvci1tYXAyLm1qcy5tYXBcbiIsImltcG9ydCB7IEZpbHRlciwgZGVwcmVjYXRpb24sIEdwdVByb2dyYW0sIEdsUHJvZ3JhbSwgQ29sb3IgfSBmcm9tICdwaXhpLmpzJztcbmltcG9ydCB2ZXJ0ZXggZnJvbSAnLi4vZGVmYXVsdHMvZGVmYXVsdDIubWpzJztcbmltcG9ydCB3Z3NsVmVydGV4IGZyb20gJy4uL2RlZmF1bHRzL2RlZmF1bHQubWpzJztcbmltcG9ydCBmcmFnbWVudCBmcm9tICcuL2NvbG9yLW92ZXJsYXkyLm1qcyc7XG5pbXBvcnQgc291cmNlIGZyb20gJy4vY29sb3Itb3ZlcmxheS5tanMnO1xuXG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiB7XG4gIF9fZGVmTm9ybWFsUHJvcChvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5jb25zdCBfQ29sb3JPdmVybGF5RmlsdGVyID0gY2xhc3MgX0NvbG9yT3ZlcmxheUZpbHRlciBleHRlbmRzIEZpbHRlciB7XG4gIC8qKiBAaWdub3JlICovXG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3NbMF0gPz8ge307XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcIm51bWJlclwiIHx8IEFycmF5LmlzQXJyYXkob3B0aW9ucykgfHwgb3B0aW9ucyBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSkge1xuICAgICAgZGVwcmVjYXRpb24oXCI2LjAuMFwiLCBcIkNvbG9yT3ZlcmxheUZpbHRlciBjb25zdHJ1Y3RvciBwYXJhbXMgYXJlIG5vdyBvcHRpb25zIG9iamVjdC4gU2VlIHBhcmFtczogeyBjb2xvciwgYWxwaGEgfVwiKTtcbiAgICAgIG9wdGlvbnMgPSB7IGNvbG9yOiBvcHRpb25zIH07XG4gICAgICBpZiAoYXJnc1sxXSAhPT0gdm9pZCAwKVxuICAgICAgICBvcHRpb25zLmFscGhhID0gYXJnc1sxXTtcbiAgICB9XG4gICAgb3B0aW9ucyA9IHsgLi4uX0NvbG9yT3ZlcmxheUZpbHRlci5ERUZBVUxUX09QVElPTlMsIC4uLm9wdGlvbnMgfTtcbiAgICBjb25zdCBncHVQcm9ncmFtID0gR3B1UHJvZ3JhbS5mcm9tKHtcbiAgICAgIHZlcnRleDoge1xuICAgICAgICBzb3VyY2U6IHdnc2xWZXJ0ZXgsXG4gICAgICAgIGVudHJ5UG9pbnQ6IFwibWFpblZlcnRleFwiXG4gICAgICB9LFxuICAgICAgZnJhZ21lbnQ6IHtcbiAgICAgICAgc291cmNlLFxuICAgICAgICBlbnRyeVBvaW50OiBcIm1haW5GcmFnbWVudFwiXG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgZ2xQcm9ncmFtID0gR2xQcm9ncmFtLmZyb20oe1xuICAgICAgdmVydGV4LFxuICAgICAgZnJhZ21lbnQsXG4gICAgICBuYW1lOiBcImNvbG9yLW92ZXJsYXktZmlsdGVyXCJcbiAgICB9KTtcbiAgICBzdXBlcih7XG4gICAgICBncHVQcm9ncmFtLFxuICAgICAgZ2xQcm9ncmFtLFxuICAgICAgcmVzb3VyY2VzOiB7XG4gICAgICAgIGNvbG9yT3ZlcmxheVVuaWZvcm1zOiB7XG4gICAgICAgICAgdUNvbG9yOiB7IHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KDMpLCB0eXBlOiBcInZlYzM8ZjMyPlwiIH0sXG4gICAgICAgICAgdUFscGhhOiB7IHZhbHVlOiBvcHRpb25zLmFscGhhLCB0eXBlOiBcImYzMlwiIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ1bmlmb3Jtc1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX2NvbG9yXCIpO1xuICAgIHRoaXMudW5pZm9ybXMgPSB0aGlzLnJlc291cmNlcy5jb2xvck92ZXJsYXlVbmlmb3Jtcy51bmlmb3JtcztcbiAgICB0aGlzLl9jb2xvciA9IG5ldyBDb2xvcigpO1xuICAgIHRoaXMuY29sb3IgPSBvcHRpb25zLmNvbG9yID8/IDA7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBvdmVyIGNvbG9yIHNvdXJjZVxuICAgKiBAbWVtYmVyIHtudW1iZXJ8QXJyYXk8bnVtYmVyPnxGbG9hdDMyQXJyYXl9XG4gICAqIEBkZWZhdWx0IDB4MDAwMDAwXG4gICAqL1xuICBnZXQgY29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbG9yLnZhbHVlO1xuICB9XG4gIHNldCBjb2xvcih2YWx1ZSkge1xuICAgIHRoaXMuX2NvbG9yLnNldFZhbHVlKHZhbHVlKTtcbiAgICBjb25zdCBbciwgZywgYl0gPSB0aGlzLl9jb2xvci50b0FycmF5KCk7XG4gICAgdGhpcy51bmlmb3Jtcy51Q29sb3JbMF0gPSByO1xuICAgIHRoaXMudW5pZm9ybXMudUNvbG9yWzFdID0gZztcbiAgICB0aGlzLnVuaWZvcm1zLnVDb2xvclsyXSA9IGI7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBhbHBoYSB2YWx1ZSBvZiB0aGUgY29sb3JcbiAgICogQGRlZmF1bHQgMVxuICAgKi9cbiAgZ2V0IGFscGhhKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnVBbHBoYTtcbiAgfVxuICBzZXQgYWxwaGEodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnVBbHBoYSA9IHZhbHVlO1xuICB9XG59O1xuLyoqIERlZmF1bHQgc2hvY2t3YXZlIGZpbHRlciBvcHRpb25zICovXG5fX3B1YmxpY0ZpZWxkKF9Db2xvck92ZXJsYXlGaWx0ZXIsIFwiREVGQVVMVF9PUFRJT05TXCIsIHtcbiAgLyoqIFRoZSBjb2xvciBvZiB0aGUgb3ZlcmxheSAqL1xuICBjb2xvcjogMCxcbiAgLyoqIFRoZSBhbHBoYSBvZiB0aGUgb3ZlcmxheSAqL1xuICBhbHBoYTogMVxufSk7XG5sZXQgQ29sb3JPdmVybGF5RmlsdGVyID0gX0NvbG9yT3ZlcmxheUZpbHRlcjtcblxuZXhwb3J0IHsgQ29sb3JPdmVybGF5RmlsdGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db2xvck92ZXJsYXlGaWx0ZXIubWpzLm1hcFxuIiwidmFyIHNvdXJjZSA9IFwic3RydWN0IENvbG9yT3ZlcmxheVVuaWZvcm1zIHtcXG4gICAgdUNvbG9yOiB2ZWMzPGYzMj4sXFxuICAgIHVBbHBoYTogZjMyLFxcbn07XFxuXFxuQGdyb3VwKDApIEBiaW5kaW5nKDEpIHZhciB1VGV4dHVyZTogdGV4dHVyZV8yZDxmMzI+OyBcXG5AZ3JvdXAoMCkgQGJpbmRpbmcoMikgdmFyIHVTYW1wbGVyOiBzYW1wbGVyO1xcbkBncm91cCgxKSBAYmluZGluZygwKSB2YXI8dW5pZm9ybT4gY29sb3JPdmVybGF5VW5pZm9ybXMgOiBDb2xvck92ZXJsYXlVbmlmb3JtcztcXG5cXG5AZnJhZ21lbnRcXG5mbiBtYWluRnJhZ21lbnQoXFxuICAgIEBidWlsdGluKHBvc2l0aW9uKSBwb3NpdGlvbjogdmVjNDxmMzI+LFxcbiAgICBAbG9jYXRpb24oMCkgdXYgOiB2ZWMyPGYzMj5cXG4pIC0+IEBsb2NhdGlvbigwKSB2ZWM0PGYzMj4ge1xcbiAgICBsZXQgYyA9IHRleHR1cmVTYW1wbGUodVRleHR1cmUsIHVTYW1wbGVyLCB1dik7XFxuICAgIHJldHVybiB2ZWM0PGYzMj4obWl4KGMucmdiLCBjb2xvck92ZXJsYXlVbmlmb3Jtcy51Q29sb3IucmdiLCBjLmEgKiBjb2xvck92ZXJsYXlVbmlmb3Jtcy51QWxwaGEpLCBjLmEpO1xcbn1cXG5cIjtcblxuZXhwb3J0IHsgc291cmNlIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbG9yLW92ZXJsYXkubWpzLm1hcFxuIiwidmFyIGZyYWdtZW50ID0gXCJpbiB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxub3V0IHZlYzQgZmluYWxDb2xvcjtcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG51bmlmb3JtIHZlYzMgdUNvbG9yO1xcbnVuaWZvcm0gZmxvYXQgdUFscGhhO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAgIHZlYzQgYyA9IHRleHR1cmUodVRleHR1cmUsIHZUZXh0dXJlQ29vcmQpO1xcbiAgICBmaW5hbENvbG9yID0gdmVjNChtaXgoYy5yZ2IsIHVDb2xvci5yZ2IsIGMuYSAqIHVBbHBoYSksIGMuYSk7XFxufVxcblwiO1xuXG5leHBvcnQgeyBmcmFnbWVudCBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2xvci1vdmVybGF5Mi5tanMubWFwXG4iLCJpbXBvcnQgeyBGaWx0ZXIsIGRlcHJlY2F0aW9uLCBHcHVQcm9ncmFtLCBHbFByb2dyYW0sIENvbG9yIH0gZnJvbSAncGl4aS5qcyc7XG5pbXBvcnQgdmVydGV4IGZyb20gJy4uL2RlZmF1bHRzL2RlZmF1bHQyLm1qcyc7XG5pbXBvcnQgd2dzbFZlcnRleCBmcm9tICcuLi9kZWZhdWx0cy9kZWZhdWx0Lm1qcyc7XG5pbXBvcnQgZnJhZ21lbnQgZnJvbSAnLi9jb2xvci1yZXBsYWNlMi5tanMnO1xuaW1wb3J0IHNvdXJjZSBmcm9tICcuL2NvbG9yLXJlcGxhY2UubWpzJztcblxudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuY29uc3QgX0NvbG9yUmVwbGFjZUZpbHRlciA9IGNsYXNzIF9Db2xvclJlcGxhY2VGaWx0ZXIgZXh0ZW5kcyBGaWx0ZXIge1xuICAvKiogQGlnbm9yZSAqL1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmdzWzBdID8/IHt9O1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJudW1iZXJcIiB8fCBBcnJheS5pc0FycmF5KG9wdGlvbnMpIHx8IG9wdGlvbnMgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpIHtcbiAgICAgIGRlcHJlY2F0aW9uKFwiNi4wLjBcIiwgXCJDb2xvclJlcGxhY2VGaWx0ZXIgY29uc3RydWN0b3IgcGFyYW1zIGFyZSBub3cgb3B0aW9ucyBvYmplY3QuIFNlZSBwYXJhbXM6IHsgb3JpZ2luYWxDb2xvciwgdGFyZ2V0Q29sb3IsIHRvbGVyYW5jZSB9XCIpO1xuICAgICAgb3B0aW9ucyA9IHsgb3JpZ2luYWxDb2xvcjogb3B0aW9ucyB9O1xuICAgICAgaWYgKGFyZ3NbMV0gIT09IHZvaWQgMClcbiAgICAgICAgb3B0aW9ucy50YXJnZXRDb2xvciA9IGFyZ3NbMV07XG4gICAgICBpZiAoYXJnc1syXSAhPT0gdm9pZCAwKVxuICAgICAgICBvcHRpb25zLnRvbGVyYW5jZSA9IGFyZ3NbMl07XG4gICAgfVxuICAgIG9wdGlvbnMgPSB7IC4uLl9Db2xvclJlcGxhY2VGaWx0ZXIuREVGQVVMVF9PUFRJT05TLCAuLi5vcHRpb25zIH07XG4gICAgY29uc3QgZ3B1UHJvZ3JhbSA9IEdwdVByb2dyYW0uZnJvbSh7XG4gICAgICB2ZXJ0ZXg6IHtcbiAgICAgICAgc291cmNlOiB3Z3NsVmVydGV4LFxuICAgICAgICBlbnRyeVBvaW50OiBcIm1haW5WZXJ0ZXhcIlxuICAgICAgfSxcbiAgICAgIGZyYWdtZW50OiB7XG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgZW50cnlQb2ludDogXCJtYWluRnJhZ21lbnRcIlxuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGdsUHJvZ3JhbSA9IEdsUHJvZ3JhbS5mcm9tKHtcbiAgICAgIHZlcnRleCxcbiAgICAgIGZyYWdtZW50LFxuICAgICAgbmFtZTogXCJjb2xvci1yZXBsYWNlLWZpbHRlclwiXG4gICAgfSk7XG4gICAgc3VwZXIoe1xuICAgICAgZ3B1UHJvZ3JhbSxcbiAgICAgIGdsUHJvZ3JhbSxcbiAgICAgIHJlc291cmNlczoge1xuICAgICAgICBjb2xvclJlcGxhY2VVbmlmb3Jtczoge1xuICAgICAgICAgIHVPcmlnaW5hbENvbG9yOiB7IHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KDMpLCB0eXBlOiBcInZlYzM8ZjMyPlwiIH0sXG4gICAgICAgICAgdVRhcmdldENvbG9yOiB7IHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KDMpLCB0eXBlOiBcInZlYzM8ZjMyPlwiIH0sXG4gICAgICAgICAgdVRvbGVyYW5jZTogeyB2YWx1ZTogb3B0aW9ucy50b2xlcmFuY2UsIHR5cGU6IFwiZjMyXCIgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInVuaWZvcm1zXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfb3JpZ2luYWxDb2xvclwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX3RhcmdldENvbG9yXCIpO1xuICAgIHRoaXMudW5pZm9ybXMgPSB0aGlzLnJlc291cmNlcy5jb2xvclJlcGxhY2VVbmlmb3Jtcy51bmlmb3JtcztcbiAgICB0aGlzLl9vcmlnaW5hbENvbG9yID0gbmV3IENvbG9yKCk7XG4gICAgdGhpcy5fdGFyZ2V0Q29sb3IgPSBuZXcgQ29sb3IoKTtcbiAgICB0aGlzLm9yaWdpbmFsQ29sb3IgPSBvcHRpb25zLm9yaWdpbmFsQ29sb3IgPz8gMTY3MTE2ODA7XG4gICAgdGhpcy50YXJnZXRDb2xvciA9IG9wdGlvbnMudGFyZ2V0Q29sb3IgPz8gMDtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgY29sb3IgdGhhdCB3aWxsIGJlIGNoYW5nZWQuXG4gICAqIEBleGFtcGxlIFsxLjAsIDEuMCwgMS4wXSA9IDB4ZmZmZmZmXG4gICAqIEBkZWZhdWx0IDB4ZmYwMDAwXG4gICAqL1xuICBnZXQgb3JpZ2luYWxDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5fb3JpZ2luYWxDb2xvci52YWx1ZTtcbiAgfVxuICBzZXQgb3JpZ2luYWxDb2xvcih2YWx1ZSkge1xuICAgIHRoaXMuX29yaWdpbmFsQ29sb3Iuc2V0VmFsdWUodmFsdWUpO1xuICAgIGNvbnN0IFtyLCBnLCBiXSA9IHRoaXMuX29yaWdpbmFsQ29sb3IudG9BcnJheSgpO1xuICAgIHRoaXMudW5pZm9ybXMudU9yaWdpbmFsQ29sb3JbMF0gPSByO1xuICAgIHRoaXMudW5pZm9ybXMudU9yaWdpbmFsQ29sb3JbMV0gPSBnO1xuICAgIHRoaXMudW5pZm9ybXMudU9yaWdpbmFsQ29sb3JbMl0gPSBiO1xuICB9XG4gIC8qKlxuICAgICogVGhlIHJlc3VsdGluZyBjb2xvci5cbiAgICAqIEBleGFtcGxlIFsxLjAsIDEuMCwgMS4wXSA9IDB4ZmZmZmZmXG4gICAgKiBAZGVmYXVsdCAweDAwMDAwMFxuICAgICovXG4gIGdldCB0YXJnZXRDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5fdGFyZ2V0Q29sb3IudmFsdWU7XG4gIH1cbiAgc2V0IHRhcmdldENvbG9yKHZhbHVlKSB7XG4gICAgdGhpcy5fdGFyZ2V0Q29sb3Iuc2V0VmFsdWUodmFsdWUpO1xuICAgIGNvbnN0IFtyLCBnLCBiXSA9IHRoaXMuX3RhcmdldENvbG9yLnRvQXJyYXkoKTtcbiAgICB0aGlzLnVuaWZvcm1zLnVUYXJnZXRDb2xvclswXSA9IHI7XG4gICAgdGhpcy51bmlmb3Jtcy51VGFyZ2V0Q29sb3JbMV0gPSBnO1xuICAgIHRoaXMudW5pZm9ybXMudVRhcmdldENvbG9yWzJdID0gYjtcbiAgfVxuICAvKipcbiAgICAqIFRvbGVyYW5jZS9zZW5zaXRpdml0eSBvZiB0aGUgZmxvYXRpbmctcG9pbnQgY29tcGFyaXNvbiBiZXR3ZWVuIGNvbG9ycyAobG93ZXIgPSBtb3JlIGV4YWN0LCBoaWdoZXIgPSBtb3JlIGluY2x1c2l2ZSlcbiAgICAqIEBkZWZhdWx0IDAuNFxuICAgICovXG4gIGdldCB0b2xlcmFuY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMudVRvbGVyYW5jZTtcbiAgfVxuICBzZXQgdG9sZXJhbmNlKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy51VG9sZXJhbmNlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIDYuMC4wXG4gICAqXG4gICAqIFRoZSByZXN1bHRpbmcgY29sb3IsIGFzIGEgMyBjb21wb25lbnQgUkdCIGUuZy4gWzEuMCwgMC41LCAxLjBdXG4gICAqIEBtZW1iZXIge251bWJlcnxBcnJheTxudW1iZXI+fEZsb2F0MzJBcnJheX1cbiAgICogQGRlZmF1bHQgMHgwMDAwMDBcbiAgICogQHNlZSBDb2xvclJlcGxhY2VGaWx0ZXIjdGFyZ2V0Q29sb3JcbiAgICovXG4gIHNldCBuZXdDb2xvcih2YWx1ZSkge1xuICAgIGRlcHJlY2F0aW9uKFwiNi4wLjBcIiwgXCJDb2xvclJlcGxhY2VGaWx0ZXIubmV3Q29sb3IgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBDb2xvclJlcGxhY2VGaWx0ZXIudGFyZ2V0Q29sb3IgaW5zdGVhZFwiKTtcbiAgICB0aGlzLnRhcmdldENvbG9yID0gdmFsdWU7XG4gIH1cbiAgZ2V0IG5ld0NvbG9yKCkge1xuICAgIGRlcHJlY2F0aW9uKFwiNi4wLjBcIiwgXCJDb2xvclJlcGxhY2VGaWx0ZXIubmV3Q29sb3IgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBDb2xvclJlcGxhY2VGaWx0ZXIudGFyZ2V0Q29sb3IgaW5zdGVhZFwiKTtcbiAgICByZXR1cm4gdGhpcy50YXJnZXRDb2xvcjtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgNi4wLjBcbiAgICpcbiAgICogVG9sZXJhbmNlL3NlbnNpdGl2aXR5IG9mIHRoZSBmbG9hdGluZy1wb2ludCBjb21wYXJpc29uIGJldHdlZW4gY29sb3JzIChsb3dlciA9IG1vcmUgZXhhY3QsIGhpZ2hlciA9IG1vcmUgaW5jbHVzaXZlKVxuICAgKiBAZGVmYXVsdCAwLjRcbiAgICogQHNlZSBDb2xvclJlcGxhY2VGaWx0ZXIjdG9sZXJhbmNlXG4gICAqL1xuICBzZXQgZXBzaWxvbih2YWx1ZSkge1xuICAgIGRlcHJlY2F0aW9uKFwiNi4wLjBcIiwgXCJDb2xvclJlcGxhY2VGaWx0ZXIuZXBzaWxvbiBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIENvbG9yUmVwbGFjZUZpbHRlci50b2xlcmFuY2UgaW5zdGVhZFwiKTtcbiAgICB0aGlzLnRvbGVyYW5jZSA9IHZhbHVlO1xuICB9XG4gIGdldCBlcHNpbG9uKCkge1xuICAgIGRlcHJlY2F0aW9uKFwiNi4wLjBcIiwgXCJDb2xvclJlcGxhY2VGaWx0ZXIuZXBzaWxvbiBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIENvbG9yUmVwbGFjZUZpbHRlci50b2xlcmFuY2UgaW5zdGVhZFwiKTtcbiAgICByZXR1cm4gdGhpcy50b2xlcmFuY2U7XG4gIH1cbn07XG4vKiogRGVmYXVsdCB2YWx1ZXMgZm9yIG9wdGlvbnMuICovXG5fX3B1YmxpY0ZpZWxkKF9Db2xvclJlcGxhY2VGaWx0ZXIsIFwiREVGQVVMVF9PUFRJT05TXCIsIHtcbiAgb3JpZ2luYWxDb2xvcjogMTY3MTE2ODAsXG4gIHRhcmdldENvbG9yOiAwLFxuICB0b2xlcmFuY2U6IDAuNFxufSk7XG5sZXQgQ29sb3JSZXBsYWNlRmlsdGVyID0gX0NvbG9yUmVwbGFjZUZpbHRlcjtcblxuZXhwb3J0IHsgQ29sb3JSZXBsYWNlRmlsdGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db2xvclJlcGxhY2VGaWx0ZXIubWpzLm1hcFxuIiwidmFyIHNvdXJjZSA9IFwic3RydWN0IENvbG9yUmVwbGFjZVVuaWZvcm1zIHtcXG4gIHVPcmlnaW5hbENvbG9yOiB2ZWMzPGYzMj4sXFxuICB1VGFyZ2V0Q29sb3I6IHZlYzM8ZjMyPixcXG4gIHVUb2xlcmFuY2U6IGYzMixcXG59O1xcblxcbkBncm91cCgwKSBAYmluZGluZygxKSB2YXIgdVRleHR1cmU6IHRleHR1cmVfMmQ8ZjMyPjsgXFxuQGdyb3VwKDApIEBiaW5kaW5nKDIpIHZhciB1U2FtcGxlcjogc2FtcGxlcjtcXG5AZ3JvdXAoMSkgQGJpbmRpbmcoMCkgdmFyPHVuaWZvcm0+IGNvbG9yUmVwbGFjZVVuaWZvcm1zIDogQ29sb3JSZXBsYWNlVW5pZm9ybXM7XFxuXFxuQGZyYWdtZW50XFxuZm4gbWFpbkZyYWdtZW50KFxcbiAgIEBidWlsdGluKHBvc2l0aW9uKSBwb3NpdGlvbjogdmVjNDxmMzI+LFxcbiAgICBAbG9jYXRpb24oMCkgdXYgOiB2ZWMyPGYzMj5cXG4pIC0+IEBsb2NhdGlvbigwKSB2ZWM0PGYzMj4ge1xcbiAgbGV0IHNhbXBsZTogdmVjNDxmMzI+ID0gdGV4dHVyZVNhbXBsZSh1VGV4dHVyZSwgdVNhbXBsZXIsIHV2KTtcXG5cXG4gIGxldCBjb2xvckRpZmY6IHZlYzM8ZjMyPiA9IGNvbG9yUmVwbGFjZVVuaWZvcm1zLnVPcmlnaW5hbENvbG9yIC0gKHNhbXBsZS5yZ2IgLyBtYXgoc2FtcGxlLmEsIDAuMDAwMDAwMDAwMSkpO1xcbiAgbGV0IGNvbG9yRGlzdGFuY2U6IGYzMiA9IGxlbmd0aChjb2xvckRpZmYpO1xcbiAgbGV0IGRvUmVwbGFjZTogZjMyID0gc3RlcChjb2xvckRpc3RhbmNlLCBjb2xvclJlcGxhY2VVbmlmb3Jtcy51VG9sZXJhbmNlKTtcXG5cXG4gIHJldHVybiB2ZWM0PGYzMj4obWl4KHNhbXBsZS5yZ2IsIChjb2xvclJlcGxhY2VVbmlmb3Jtcy51VGFyZ2V0Q29sb3IgKyBjb2xvckRpZmYpICogc2FtcGxlLmEsIGRvUmVwbGFjZSksIHNhbXBsZS5hKTtcXG59XCI7XG5cbmV4cG9ydCB7IHNvdXJjZSBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2xvci1yZXBsYWNlLm1qcy5tYXBcbiIsInZhciBmcmFnbWVudCA9IFwiaW4gdmVjMiB2VGV4dHVyZUNvb3JkO1xcbm91dCB2ZWM0IGZpbmFsQ29sb3I7XFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxudW5pZm9ybSB2ZWMzIHVPcmlnaW5hbENvbG9yO1xcbnVuaWZvcm0gdmVjMyB1VGFyZ2V0Q29sb3I7XFxudW5pZm9ybSBmbG9hdCB1VG9sZXJhbmNlO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAgIHZlYzQgYyA9IHRleHR1cmUodVRleHR1cmUsIHZUZXh0dXJlQ29vcmQpO1xcbiAgICB2ZWMzIGNvbG9yRGlmZiA9IHVPcmlnaW5hbENvbG9yIC0gKGMucmdiIC8gbWF4KGMuYSwgMC4wMDAwMDAwMDAxKSk7XFxuICAgIGZsb2F0IGNvbG9yRGlzdGFuY2UgPSBsZW5ndGgoY29sb3JEaWZmKTtcXG4gICAgZmxvYXQgZG9SZXBsYWNlID0gc3RlcChjb2xvckRpc3RhbmNlLCB1VG9sZXJhbmNlKTtcXG4gICAgZmluYWxDb2xvciA9IHZlYzQobWl4KGMucmdiLCAodVRhcmdldENvbG9yICsgY29sb3JEaWZmKSAqIGMuYSwgZG9SZXBsYWNlKSwgYy5hKTtcXG59XFxuXCI7XG5cbmV4cG9ydCB7IGZyYWdtZW50IGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbG9yLXJlcGxhY2UyLm1qcy5tYXBcbiIsImltcG9ydCB7IEZpbHRlciwgZGVwcmVjYXRpb24sIEdwdVByb2dyYW0sIEdsUHJvZ3JhbSB9IGZyb20gJ3BpeGkuanMnO1xuaW1wb3J0IHZlcnRleCBmcm9tICcuLi9kZWZhdWx0cy9kZWZhdWx0Mi5tanMnO1xuaW1wb3J0IHdnc2xWZXJ0ZXggZnJvbSAnLi4vZGVmYXVsdHMvZGVmYXVsdC5tanMnO1xuaW1wb3J0IGZyYWdtZW50IGZyb20gJy4vY29udm9sdXRpb24ubWpzJztcbmltcG9ydCBzb3VyY2UgZnJvbSAnLi9jb252b2x1dGlvbjIubWpzJztcblxudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuY29uc3QgX0NvbnZvbHV0aW9uRmlsdGVyID0gY2xhc3MgX0NvbnZvbHV0aW9uRmlsdGVyIGV4dGVuZHMgRmlsdGVyIHtcbiAgLyoqIEBpZ25vcmUgKi9cbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIGxldCBvcHRpb25zID0gYXJnc1swXSA/PyB7fTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zKSkge1xuICAgICAgZGVwcmVjYXRpb24oXCI2LjAuMFwiLCBcIkNvbnZvbHV0aW9uRmlsdGVyIGNvbnN0cnVjdG9yIHBhcmFtcyBhcmUgbm93IG9wdGlvbnMgb2JqZWN0LiBTZWUgcGFyYW1zOiB7IG1hdHJpeCwgd2lkdGgsIGhlaWdodCB9XCIpO1xuICAgICAgb3B0aW9ucyA9IHsgbWF0cml4OiBvcHRpb25zIH07XG4gICAgICBpZiAoYXJnc1sxXSAhPT0gdm9pZCAwKVxuICAgICAgICBvcHRpb25zLndpZHRoID0gYXJnc1sxXTtcbiAgICAgIGlmIChhcmdzWzJdICE9PSB2b2lkIDApXG4gICAgICAgIG9wdGlvbnMuaGVpZ2h0ID0gYXJnc1syXTtcbiAgICB9XG4gICAgb3B0aW9ucyA9IHsgLi4uX0NvbnZvbHV0aW9uRmlsdGVyLkRFRkFVTFRfT1BUSU9OUywgLi4ub3B0aW9ucyB9O1xuICAgIGNvbnN0IHdpZHRoID0gb3B0aW9ucy53aWR0aCA/PyAyMDA7XG4gICAgY29uc3QgaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQgPz8gMjAwO1xuICAgIGNvbnN0IGdwdVByb2dyYW0gPSBHcHVQcm9ncmFtLmZyb20oe1xuICAgICAgdmVydGV4OiB7XG4gICAgICAgIHNvdXJjZTogd2dzbFZlcnRleCxcbiAgICAgICAgZW50cnlQb2ludDogXCJtYWluVmVydGV4XCJcbiAgICAgIH0sXG4gICAgICBmcmFnbWVudDoge1xuICAgICAgICBzb3VyY2UsXG4gICAgICAgIGVudHJ5UG9pbnQ6IFwibWFpbkZyYWdtZW50XCJcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBnbFByb2dyYW0gPSBHbFByb2dyYW0uZnJvbSh7XG4gICAgICB2ZXJ0ZXgsXG4gICAgICBmcmFnbWVudCxcbiAgICAgIG5hbWU6IFwiY29udm9sdXRpb24tZmlsdGVyXCJcbiAgICB9KTtcbiAgICBzdXBlcih7XG4gICAgICBncHVQcm9ncmFtLFxuICAgICAgZ2xQcm9ncmFtLFxuICAgICAgcmVzb3VyY2VzOiB7XG4gICAgICAgIGNvbnZvbHV0aW9uVW5pZm9ybXM6IHtcbiAgICAgICAgICB1TWF0cml4OiB7IHZhbHVlOiBvcHRpb25zLm1hdHJpeCwgdHlwZTogXCJtYXQzeDM8ZjMyPlwiIH0sXG4gICAgICAgICAgdVRleGVsU2l6ZTogeyB2YWx1ZTogeyB4OiAxIC8gd2lkdGgsIHk6IDEgLyBoZWlnaHQgfSwgdHlwZTogXCJ2ZWMyPGYzMj5cIiB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidW5pZm9ybXNcIik7XG4gICAgdGhpcy51bmlmb3JtcyA9IHRoaXMucmVzb3VyY2VzLmNvbnZvbHV0aW9uVW5pZm9ybXMudW5pZm9ybXM7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICB9XG4gIC8qKlxuICAgKiBBbiBhcnJheSBvZiB2YWx1ZXMgdXNlZCBmb3IgbWF0cml4IHRyYW5zZm9ybWF0aW9uLCBzcGVjaWZpZWQgYXMgYSA5IHBvaW50IEFycmF5XG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IG1hdHJpeCA9IG5ldyBGbG9hdDMyQXJyYXkoOSk7IC8vIDkgZWxlbWVudHMgb2YgdmFsdWUgMFxuICAgKiBjb25zdCBtYXRyaXggPSBbMCwwLjUsMCwwLjUsMSwwLjUsMCwwLjUsMF07XG4gICAqIEBkZWZhdWx0IFswLDAsMCwwLDAsMCwwLDAsMF1cbiAgICovXG4gIGdldCBtYXRyaXgoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMudU1hdHJpeDtcbiAgfVxuICBzZXQgbWF0cml4KG1hdHJpeCkge1xuICAgIG1hdHJpeC5mb3JFYWNoKCh2LCBpKSA9PiB7XG4gICAgICB0aGlzLnVuaWZvcm1zLnVNYXRyaXhbaV0gPSB2O1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBXaWR0aCBvZiB0aGUgb2JqZWN0IHlvdSBhcmUgdHJhbnNmb3JtaW5nXG4gICAqIEBkZWZhdWx0IDIwMFxuICAgKi9cbiAgZ2V0IHdpZHRoKCkge1xuICAgIHJldHVybiAxIC8gdGhpcy51bmlmb3Jtcy51VGV4ZWxTaXplLng7XG4gIH1cbiAgc2V0IHdpZHRoKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy51VGV4ZWxTaXplLnggPSAxIC8gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIEhlaWdodCBvZiB0aGUgb2JqZWN0IHlvdSBhcmUgdHJhbnNmb3JtaW5nXG4gICAqIEBkZWZhdWx0IDIwMFxuICAgKi9cbiAgZ2V0IGhlaWdodCgpIHtcbiAgICByZXR1cm4gMSAvIHRoaXMudW5pZm9ybXMudVRleGVsU2l6ZS55O1xuICB9XG4gIHNldCBoZWlnaHQodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnVUZXhlbFNpemUueSA9IDEgLyB2YWx1ZTtcbiAgfVxufTtcbi8qKiBEZWZhdWx0IHZhbHVlcyBmb3Igb3B0aW9ucy4gKi9cbl9fcHVibGljRmllbGQoX0NvbnZvbHV0aW9uRmlsdGVyLCBcIkRFRkFVTFRfT1BUSU9OU1wiLCB7XG4gIG1hdHJpeDogbmV3IEZsb2F0MzJBcnJheSg5KSxcbiAgd2lkdGg6IDIwMCxcbiAgaGVpZ2h0OiAyMDBcbn0pO1xubGV0IENvbnZvbHV0aW9uRmlsdGVyID0gX0NvbnZvbHV0aW9uRmlsdGVyO1xuXG5leHBvcnQgeyBDb252b2x1dGlvbkZpbHRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29udm9sdXRpb25GaWx0ZXIubWpzLm1hcFxuIiwidmFyIHNvdXJjZSA9IFwic3RydWN0IENvbnZvbHV0aW9uVW5pZm9ybXMge1xcbiAgICB1TWF0cml4OiBtYXQzeDM8ZjMyPixcXG4gICAgdVRleGVsU2l6ZTogdmVjMjxmMzI+LFxcbn07XFxuXFxuQGdyb3VwKDApIEBiaW5kaW5nKDEpIHZhciB1VGV4dHVyZTogdGV4dHVyZV8yZDxmMzI+OyBcXG5AZ3JvdXAoMCkgQGJpbmRpbmcoMikgdmFyIHVTYW1wbGVyOiBzYW1wbGVyO1xcbkBncm91cCgxKSBAYmluZGluZygwKSB2YXI8dW5pZm9ybT4gY29udm9sdXRpb25Vbmlmb3JtcyA6IENvbnZvbHV0aW9uVW5pZm9ybXM7XFxuXFxuQGZyYWdtZW50XFxuZm4gbWFpbkZyYWdtZW50KFxcbiAgICBAbG9jYXRpb24oMCkgdXY6IHZlYzI8ZjMyPixcXG4gICAgQGJ1aWx0aW4ocG9zaXRpb24pIHBvc2l0aW9uOiB2ZWM0PGYzMj5cXG4pIC0+IEBsb2NhdGlvbigwKSB2ZWM0PGYzMj4ge1xcbiAgICBsZXQgdGV4ZWxTaXplID0gY29udm9sdXRpb25Vbmlmb3Jtcy51VGV4ZWxTaXplO1xcbiAgICBsZXQgbWF0cml4ID0gY29udm9sdXRpb25Vbmlmb3Jtcy51TWF0cml4O1xcblxcbiAgICBsZXQgYzExOiB2ZWM0PGYzMj4gPSB0ZXh0dXJlU2FtcGxlKHVUZXh0dXJlLCB1U2FtcGxlciwgdXYgLSB0ZXhlbFNpemUpOyAvLyB0b3AgbGVmdFxcbiAgICBsZXQgYzEyOiB2ZWM0PGYzMj4gPSB0ZXh0dXJlU2FtcGxlKHVUZXh0dXJlLCB1U2FtcGxlciwgdmVjMjxmMzI+KHV2LngsIHV2LnkgLSB0ZXhlbFNpemUueSkpOyAvLyB0b3AgY2VudGVyXFxuICAgIGxldCBjMTM6IHZlYzQ8ZjMyPiA9IHRleHR1cmVTYW1wbGUodVRleHR1cmUsIHVTYW1wbGVyLCB2ZWMyPGYzMj4odXYueCArIHRleGVsU2l6ZS54LCB1di55IC0gdGV4ZWxTaXplLnkpKTsgLy8gdG9wIHJpZ2h0XFxuXFxuICAgIGxldCBjMjE6IHZlYzQ8ZjMyPiA9IHRleHR1cmVTYW1wbGUodVRleHR1cmUsIHVTYW1wbGVyLCB2ZWMyPGYzMj4odXYueCAtIHRleGVsU2l6ZS54LCB1di55KSk7IC8vIG1pZCBsZWZ0XFxuICAgIGxldCBjMjI6IHZlYzQ8ZjMyPiA9IHRleHR1cmVTYW1wbGUodVRleHR1cmUsIHVTYW1wbGVyLCB1dik7IC8vIG1pZCBjZW50ZXJcXG4gICAgbGV0IGMyMzogdmVjNDxmMzI+ID0gdGV4dHVyZVNhbXBsZSh1VGV4dHVyZSwgdVNhbXBsZXIsIHZlYzI8ZjMyPih1di54ICsgdGV4ZWxTaXplLngsIHV2LnkpKTsgLy8gbWlkIHJpZ2h0XFxuXFxuICAgIGxldCBjMzE6IHZlYzQ8ZjMyPiA9IHRleHR1cmVTYW1wbGUodVRleHR1cmUsIHVTYW1wbGVyLCB2ZWMyPGYzMj4odXYueCAtIHRleGVsU2l6ZS54LCB1di55ICsgdGV4ZWxTaXplLnkpKTsgLy8gYm90dG9tIGxlZnRcXG4gICAgbGV0IGMzMjogdmVjNDxmMzI+ID0gdGV4dHVyZVNhbXBsZSh1VGV4dHVyZSwgdVNhbXBsZXIsIHZlYzI8ZjMyPih1di54LCB1di55ICsgdGV4ZWxTaXplLnkpKTsgLy8gYm90dG9tIGNlbnRlclxcbiAgICBsZXQgYzMzOiB2ZWM0PGYzMj4gPSB0ZXh0dXJlU2FtcGxlKHVUZXh0dXJlLCB1U2FtcGxlciwgdXYgKyB0ZXhlbFNpemUpOyAvLyBib3R0b20gcmlnaHRcXG5cXG4gICAgdmFyIGZpbmFsQ29sb3I6IHZlYzQ8ZjMyPiA9IHZlYzQ8ZjMyPihcXG4gICAgICAgIGMxMSAqIG1hdHJpeFswXVswXSArIGMxMiAqIG1hdHJpeFswXVsxXSArIGMxMyAqIG1hdHJpeFswXVsyXSArXFxuICAgICAgICBjMjEgKiBtYXRyaXhbMV1bMF0gKyBjMjIgKiBtYXRyaXhbMV1bMV0gKyBjMjMgKiBtYXRyaXhbMV1bMl0gK1xcbiAgICAgICAgYzMxICogbWF0cml4WzJdWzBdICsgYzMyICogbWF0cml4WzJdWzFdICsgYzMzICogbWF0cml4WzJdWzJdXFxuICAgICk7XFxuXFxuICAgIGZpbmFsQ29sb3IuYSA9IGMyMi5hO1xcblxcbiAgICByZXR1cm4gZmluYWxDb2xvcjtcXG59XCI7XG5cbmV4cG9ydCB7IHNvdXJjZSBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb252b2x1dGlvbjIubWpzLm1hcFxuIiwidmFyIGZyYWdtZW50ID0gXCJpbiB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxub3V0IHZlYzQgZmluYWxDb2xvcjtcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG51bmlmb3JtIHZlYzIgdVRleGVsU2l6ZTtcXG51bmlmb3JtIG1hdDMgdU1hdHJpeDtcXG5cXG52b2lkIG1haW4odm9pZClcXG57XFxuICAgIHZlYzQgYzExID0gdGV4dHVyZSh1VGV4dHVyZSwgdlRleHR1cmVDb29yZCAtIHVUZXhlbFNpemUpOyAvLyB0b3AgbGVmdFxcbiAgICB2ZWM0IGMxMiA9IHRleHR1cmUodVRleHR1cmUsIHZlYzIodlRleHR1cmVDb29yZC54LCB2VGV4dHVyZUNvb3JkLnkgLSB1VGV4ZWxTaXplLnkpKTsgLy8gdG9wIGNlbnRlclxcbiAgICB2ZWM0IGMxMyA9IHRleHR1cmUodVRleHR1cmUsIHZlYzIodlRleHR1cmVDb29yZC54ICsgdVRleGVsU2l6ZS54LCB2VGV4dHVyZUNvb3JkLnkgLSB1VGV4ZWxTaXplLnkpKTsgLy8gdG9wIHJpZ2h0XFxuXFxuICAgIHZlYzQgYzIxID0gdGV4dHVyZSh1VGV4dHVyZSwgdmVjMih2VGV4dHVyZUNvb3JkLnggLSB1VGV4ZWxTaXplLngsIHZUZXh0dXJlQ29vcmQueSkpOyAvLyBtaWQgbGVmdFxcbiAgICB2ZWM0IGMyMiA9IHRleHR1cmUodVRleHR1cmUsIHZUZXh0dXJlQ29vcmQpOyAvLyBtaWQgY2VudGVyXFxuICAgIHZlYzQgYzIzID0gdGV4dHVyZSh1VGV4dHVyZSwgdmVjMih2VGV4dHVyZUNvb3JkLnggKyB1VGV4ZWxTaXplLngsIHZUZXh0dXJlQ29vcmQueSkpOyAvLyBtaWQgcmlnaHRcXG5cXG4gICAgdmVjNCBjMzEgPSB0ZXh0dXJlKHVUZXh0dXJlLCB2ZWMyKHZUZXh0dXJlQ29vcmQueCAtIHVUZXhlbFNpemUueCwgdlRleHR1cmVDb29yZC55ICsgdVRleGVsU2l6ZS55KSk7IC8vIGJvdHRvbSBsZWZ0XFxuICAgIHZlYzQgYzMyID0gdGV4dHVyZSh1VGV4dHVyZSwgdmVjMih2VGV4dHVyZUNvb3JkLngsIHZUZXh0dXJlQ29vcmQueSArIHVUZXhlbFNpemUueSkpOyAvLyBib3R0b20gY2VudGVyXFxuICAgIHZlYzQgYzMzID0gdGV4dHVyZSh1VGV4dHVyZSwgdlRleHR1cmVDb29yZCArIHVUZXhlbFNpemUpOyAvLyBib3R0b20gcmlnaHRcXG5cXG4gICAgZmluYWxDb2xvciA9XFxuICAgICAgICBjMTEgKiB1TWF0cml4WzBdWzBdICsgYzEyICogdU1hdHJpeFswXVsxXSArIGMxMyAqIHVNYXRyaXhbMF1bMl0gK1xcbiAgICAgICAgYzIxICogdU1hdHJpeFsxXVswXSArIGMyMiAqIHVNYXRyaXhbMV1bMV0gKyBjMjMgKiB1TWF0cml4WzFdWzJdICtcXG4gICAgICAgIGMzMSAqIHVNYXRyaXhbMl1bMF0gKyBjMzIgKiB1TWF0cml4WzJdWzFdICsgYzMzICogdU1hdHJpeFsyXVsyXTtcXG5cXG4gICAgZmluYWxDb2xvci5hID0gYzIyLmE7XFxufVwiO1xuXG5leHBvcnQgeyBmcmFnbWVudCBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb252b2x1dGlvbi5tanMubWFwXG4iLCJpbXBvcnQgeyBGaWx0ZXIsIEdwdVByb2dyYW0sIEdsUHJvZ3JhbSB9IGZyb20gJ3BpeGkuanMnO1xuaW1wb3J0IHZlcnRleCBmcm9tICcuLi9kZWZhdWx0cy9kZWZhdWx0Mi5tanMnO1xuaW1wb3J0IHdnc2xWZXJ0ZXggZnJvbSAnLi4vZGVmYXVsdHMvZGVmYXVsdC5tanMnO1xuaW1wb3J0IGZyYWdtZW50IGZyb20gJy4vY3Jvc3NoYXRjaC5tanMnO1xuaW1wb3J0IHNvdXJjZSBmcm9tICcuL2Nyb3NzaGF0Y2gyLm1qcyc7XG5cbmNsYXNzIENyb3NzSGF0Y2hGaWx0ZXIgZXh0ZW5kcyBGaWx0ZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBjb25zdCBncHVQcm9ncmFtID0gR3B1UHJvZ3JhbS5mcm9tKHtcbiAgICAgIHZlcnRleDoge1xuICAgICAgICBzb3VyY2U6IHdnc2xWZXJ0ZXgsXG4gICAgICAgIGVudHJ5UG9pbnQ6IFwibWFpblZlcnRleFwiXG4gICAgICB9LFxuICAgICAgZnJhZ21lbnQ6IHtcbiAgICAgICAgc291cmNlLFxuICAgICAgICBlbnRyeVBvaW50OiBcIm1haW5GcmFnbWVudFwiXG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgZ2xQcm9ncmFtID0gR2xQcm9ncmFtLmZyb20oe1xuICAgICAgdmVydGV4LFxuICAgICAgZnJhZ21lbnQsXG4gICAgICBuYW1lOiBcImNyb3NzLWhhdGNoLWZpbHRlclwiXG4gICAgfSk7XG4gICAgc3VwZXIoe1xuICAgICAgZ3B1UHJvZ3JhbSxcbiAgICAgIGdsUHJvZ3JhbSxcbiAgICAgIHJlc291cmNlczoge31cbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgeyBDcm9zc0hhdGNoRmlsdGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Dcm9zc0hhdGNoRmlsdGVyLm1qcy5tYXBcbiIsImltcG9ydCB7IEZpbHRlciwgR3B1UHJvZ3JhbSwgR2xQcm9ncmFtIH0gZnJvbSAncGl4aS5qcyc7XG5pbXBvcnQgdmVydGV4IGZyb20gJy4uL2RlZmF1bHRzL2RlZmF1bHQyLm1qcyc7XG5pbXBvcnQgd2dzbFZlcnRleCBmcm9tICcuLi9kZWZhdWx0cy9kZWZhdWx0Lm1qcyc7XG5pbXBvcnQgZnJhZ21lbnQgZnJvbSAnLi9jcnQubWpzJztcbmltcG9ydCBzb3VyY2UgZnJvbSAnLi9jcnQyLm1qcyc7XG5cbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbmNvbnN0IF9DUlRGaWx0ZXIgPSBjbGFzcyBfQ1JURmlsdGVyIGV4dGVuZHMgRmlsdGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgdGhlIENSVEZpbHRlciBjb25zdHJ1Y3Rvci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0geyAuLi5fQ1JURmlsdGVyLkRFRkFVTFRfT1BUSU9OUywgLi4ub3B0aW9ucyB9O1xuICAgIGNvbnN0IGdwdVByb2dyYW0gPSBHcHVQcm9ncmFtLmZyb20oe1xuICAgICAgdmVydGV4OiB7XG4gICAgICAgIHNvdXJjZTogd2dzbFZlcnRleCxcbiAgICAgICAgZW50cnlQb2ludDogXCJtYWluVmVydGV4XCJcbiAgICAgIH0sXG4gICAgICBmcmFnbWVudDoge1xuICAgICAgICBzb3VyY2UsXG4gICAgICAgIGVudHJ5UG9pbnQ6IFwibWFpbkZyYWdtZW50XCJcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBnbFByb2dyYW0gPSBHbFByb2dyYW0uZnJvbSh7XG4gICAgICB2ZXJ0ZXgsXG4gICAgICBmcmFnbWVudCxcbiAgICAgIG5hbWU6IFwiY3J0LWZpbHRlclwiXG4gICAgfSk7XG4gICAgc3VwZXIoe1xuICAgICAgZ3B1UHJvZ3JhbSxcbiAgICAgIGdsUHJvZ3JhbSxcbiAgICAgIHJlc291cmNlczoge1xuICAgICAgICBjcnRVbmlmb3Jtczoge1xuICAgICAgICAgIHVMaW5lOiB7IHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KDQpLCB0eXBlOiBcInZlYzQ8ZjMyPlwiIH0sXG4gICAgICAgICAgdU5vaXNlOiB7IHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KDIpLCB0eXBlOiBcInZlYzI8ZjMyPlwiIH0sXG4gICAgICAgICAgdVZpZ25ldHRlOiB7IHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KDMpLCB0eXBlOiBcInZlYzM8ZjMyPlwiIH0sXG4gICAgICAgICAgdVNlZWQ6IHsgdmFsdWU6IG9wdGlvbnMuc2VlZCwgdHlwZTogXCJmMzJcIiB9LFxuICAgICAgICAgIHVUaW1lOiB7IHZhbHVlOiBvcHRpb25zLnRpbWUsIHR5cGU6IFwiZjMyXCIgfSxcbiAgICAgICAgICB1RGltZW5zaW9uczogeyB2YWx1ZTogbmV3IEZsb2F0MzJBcnJheSgyKSwgdHlwZTogXCJ2ZWMyPGYzMj5cIiB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidW5pZm9ybXNcIik7XG4gICAgLyoqXG4gICAgICogQSBzZWVkIHZhbHVlIHRvIGFwcGx5IHRvIHRoZSByYW5kb20gbm9pc2UgZ2VuZXJhdGlvblxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic2VlZFwiKTtcbiAgICAvKipcbiAgICAgKiBPcGFjaXR5L2ludGVuc2l0eSBvZiB0aGUgbm9pc2UgZWZmZWN0IGJldHdlZW4gYDBgIGFuZCBgMWBcbiAgICAgKiBAZGVmYXVsdCAwLjNcbiAgICAgKi9cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidGltZVwiKTtcbiAgICB0aGlzLnVuaWZvcm1zID0gdGhpcy5yZXNvdXJjZXMuY3J0VW5pZm9ybXMudW5pZm9ybXM7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogT3ZlcnJpZGUgZXhpc3RpbmcgYXBwbHkgbWV0aG9kIGluIGBGaWx0ZXJgXG4gICAqIEBvdmVycmlkZVxuICAgKiBAaWdub3JlXG4gICAqL1xuICBhcHBseShmaWx0ZXJNYW5hZ2VyLCBpbnB1dCwgb3V0cHV0LCBjbGVhck1vZGUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnVEaW1lbnNpb25zWzBdID0gaW5wdXQuZnJhbWUud2lkdGg7XG4gICAgdGhpcy51bmlmb3Jtcy51RGltZW5zaW9uc1sxXSA9IGlucHV0LmZyYW1lLmhlaWdodDtcbiAgICB0aGlzLnVuaWZvcm1zLnVTZWVkID0gdGhpcy5zZWVkO1xuICAgIHRoaXMudW5pZm9ybXMudVRpbWUgPSB0aGlzLnRpbWU7XG4gICAgZmlsdGVyTWFuYWdlci5hcHBseUZpbHRlcih0aGlzLCBpbnB1dCwgb3V0cHV0LCBjbGVhck1vZGUpO1xuICB9XG4gIC8qKlxuICAgKiBCZW5kIG9mIGludGVybGFjZWQgbGluZXMsIGhpZ2hlciB2YWx1ZSBtZWFucyBtb3JlIGJlbmRcbiAgICogQGRlZmF1bHQgMVxuICAgKi9cbiAgZ2V0IGN1cnZhdHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy51TGluZVswXTtcbiAgfVxuICBzZXQgY3VydmF0dXJlKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy51TGluZVswXSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBXaWR0aCBvZiBpbnRlcmxhY2VkIGxpbmVzXG4gICAqIEBkZWZhdWx0IDFcbiAgICovXG4gIGdldCBsaW5lV2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMudUxpbmVbMV07XG4gIH1cbiAgc2V0IGxpbmVXaWR0aCh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMudUxpbmVbMV0gPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogQ29udHJhc3Qgb2YgaW50ZXJsYWNlZCBsaW5lc1xuICAgKiBAZGVmYXVsdCAwLjI1XG4gICAqL1xuICBnZXQgbGluZUNvbnRyYXN0KCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnVMaW5lWzJdO1xuICB9XG4gIHNldCBsaW5lQ29udHJhc3QodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnVMaW5lWzJdID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBvcmllbnRhdGlvbiBvZiB0aGUgbGluZTpcbiAgICpcbiAgICogYHRydWVgIGNyZWF0ZSB2ZXJ0aWNhbCBsaW5lcywgYGZhbHNlYCBjcmVhdGVzIGhvcml6b250YWwgbGluZXNcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGdldCB2ZXJ0aWNhbExpbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMudUxpbmVbM10gPiAwLjU7XG4gIH1cbiAgc2V0IHZlcnRpY2FsTGluZSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMudUxpbmVbM10gPSB2YWx1ZSA/IDEgOiAwO1xuICB9XG4gIC8qKlxuICAgKiBPcGFjaXR5L2ludGVuc2l0eSBvZiB0aGUgbm9pc2UgZWZmZWN0IGJldHdlZW4gYDBgIGFuZCBgMWBcbiAgICogQGRlZmF1bHQgMC4zXG4gICAqL1xuICBnZXQgbm9pc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMudU5vaXNlWzBdO1xuICB9XG4gIHNldCBub2lzZSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMudU5vaXNlWzBdID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBzaXplIG9mIHRoZSBub2lzZSBwYXJ0aWNsZXNcbiAgICogQGRlZmF1bHQgMFxuICAgKi9cbiAgZ2V0IG5vaXNlU2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy51Tm9pc2VbMV07XG4gIH1cbiAgc2V0IG5vaXNlU2l6ZSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMudU5vaXNlWzFdID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSByYWRpdXMgb2YgdGhlIHZpZ25ldHRlIGVmZmVjdCwgc21hbGxlciB2YWx1ZXMgcHJvZHVjZXMgYSBzbWFsbGVyIHZpZ25ldHRlXG4gICAqIEBkZWZhdWx0IDAuM1xuICAgKi9cbiAgZ2V0IHZpZ25ldHRpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMudVZpZ25ldHRlWzBdO1xuICB9XG4gIHNldCB2aWduZXR0aW5nKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy51VmlnbmV0dGVbMF0gPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogQW1vdW50IG9mIG9wYWNpdHkgb2YgdmlnbmV0dGVcbiAgICogQGRlZmF1bHQgMVxuICAgKi9cbiAgZ2V0IHZpZ25ldHRpbmdBbHBoYSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy51VmlnbmV0dGVbMV07XG4gIH1cbiAgc2V0IHZpZ25ldHRpbmdBbHBoYSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMudVZpZ25ldHRlWzFdID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIEJsdXIgaW50ZW5zaXR5IG9mIHRoZSB2aWduZXR0ZVxuICAgKiBAZGVmYXVsdCAwLjNcbiAgICovXG4gIGdldCB2aWduZXR0aW5nQmx1cigpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy51VmlnbmV0dGVbMl07XG4gIH1cbiAgc2V0IHZpZ25ldHRpbmdCbHVyKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy51VmlnbmV0dGVbMl0gPSB2YWx1ZTtcbiAgfVxufTtcbi8qKiBEZWZhdWx0IHZhbHVlcyBmb3Igb3B0aW9ucy4gKi9cbl9fcHVibGljRmllbGQoX0NSVEZpbHRlciwgXCJERUZBVUxUX09QVElPTlNcIiwge1xuICBjdXJ2YXR1cmU6IDEsXG4gIGxpbmVXaWR0aDogMSxcbiAgbGluZUNvbnRyYXN0OiAwLjI1LFxuICB2ZXJ0aWNhbExpbmU6IGZhbHNlLFxuICBub2lzZTogMCxcbiAgbm9pc2VTaXplOiAxLFxuICB2aWduZXR0aW5nOiAwLjMsXG4gIHZpZ25ldHRpbmdBbHBoYTogMSxcbiAgdmlnbmV0dGluZ0JsdXI6IDAuMyxcbiAgdGltZTogMCxcbiAgc2VlZDogMFxufSk7XG5sZXQgQ1JURmlsdGVyID0gX0NSVEZpbHRlcjtcblxuZXhwb3J0IHsgQ1JURmlsdGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DUlRGaWx0ZXIubWpzLm1hcFxuIiwidmFyIHNvdXJjZSA9IFwic3RydWN0IENSVFVuaWZvcm1zIHtcXG4gICAgdUxpbmU6IHZlYzQ8ZjMyPixcXG4gICAgdU5vaXNlOiB2ZWMyPGYzMj4sXFxuICAgIHVWaWduZXR0ZTogdmVjMzxmMzI+LFxcbiAgICB1U2VlZDogZjMyLFxcbiAgICB1VGltZTogZjMyLFxcbiAgICB1RGltZW5zaW9uczogdmVjMjxmMzI+LFxcbn07XFxuXFxuc3RydWN0IEdsb2JhbEZpbHRlclVuaWZvcm1zIHtcXG4gIHVJbnB1dFNpemU6dmVjNDxmMzI+LFxcbiAgdUlucHV0UGl4ZWw6dmVjNDxmMzI+LFxcbiAgdUlucHV0Q2xhbXA6dmVjNDxmMzI+LFxcbiAgdU91dHB1dEZyYW1lOnZlYzQ8ZjMyPixcXG4gIHVHbG9iYWxGcmFtZTp2ZWM0PGYzMj4sXFxuICB1T3V0cHV0VGV4dHVyZTp2ZWM0PGYzMj4sXFxufTtcXG5cXG5AZ3JvdXAoMCkgQGJpbmRpbmcoMCkgdmFyPHVuaWZvcm0+IGdmdTogR2xvYmFsRmlsdGVyVW5pZm9ybXM7XFxuXFxuQGdyb3VwKDApIEBiaW5kaW5nKDEpIHZhciB1VGV4dHVyZTogdGV4dHVyZV8yZDxmMzI+OyBcXG5AZ3JvdXAoMCkgQGJpbmRpbmcoMikgdmFyIHVTYW1wbGVyOiBzYW1wbGVyO1xcbkBncm91cCgxKSBAYmluZGluZygwKSB2YXI8dW5pZm9ybT4gY3J0VW5pZm9ybXMgOiBDUlRVbmlmb3JtcztcXG5cXG5AZnJhZ21lbnRcXG5mbiBtYWluRnJhZ21lbnQoXFxuICBAYnVpbHRpbihwb3NpdGlvbikgcG9zaXRpb246IHZlYzQ8ZjMyPixcXG4gIEBsb2NhdGlvbigwKSB1diA6IHZlYzI8ZjMyPlxcbikgLT4gQGxvY2F0aW9uKDApIHZlYzQ8ZjMyPiB7XFxuICAgIFxcbiAgdmFyIGNvbG9yOiB2ZWM0PGYzMj4gPSB0ZXh0dXJlU2FtcGxlKHVUZXh0dXJlLCB1U2FtcGxlciwgdXYpO1xcbiAgbGV0IGNvb3JkOiB2ZWMyPGYzMj4gPSB1diAqIGdmdS51SW5wdXRTaXplLnh5IC8gY3J0VW5pZm9ybXMudURpbWVuc2lvbnM7XFxuXFxuICBsZXQgdU5vaXNlID0gY3J0VW5pZm9ybXMudU5vaXNlO1xcblxcbiAgaWYgKHVOb2lzZVswXSA+IDAuMCAmJiB1Tm9pc2VbMV0gPiAwLjApXFxuICB7XFxuICAgIGNvbG9yICs9IHZlYzQ8ZjMyPih2ZWMzPGYzMj4obm9pc2UodXYpKSwgY29sb3IuYSk7XFxuICB9XFxuXFxuICBpZiAoY3J0VW5pZm9ybXMudVZpZ25ldHRlWzBdID4gMC4pXFxuICB7XFxuICAgIGNvbG9yICo9IHZlYzQ8ZjMyPih2ZWMzPGYzMj4odmlnbmV0dGUoY29sb3IucmdiLCBjb29yZCkpLCBjb2xvci5hKTtcXG4gIH1cXG5cXG4gIGlmIChjcnRVbmlmb3Jtcy51TGluZVsxXSA+IDAuMClcXG4gIHtcXG4gICAgY29sb3IgPSB2ZWM0PGYzMj4odmVjMzxmMzI+KGludGVybGFjZUxpbmVzKGNvbG9yLnJnYiwgdXYpKSwgY29sb3IuYSk7ICBcXG4gIH1cXG5cXG4gIHJldHVybiBjb2xvcjtcXG59XFxuXFxuY29uc3QgU1FSVF8yOiBmMzIgPSAxLjQxNDIxMztcXG5cXG5mbiBtb2R1bG8oeDogZjMyLCB5OiBmMzIpIC0+IGYzMlxcbntcXG4gIHJldHVybiB4IC0geSAqIGZsb29yKHgveSk7XFxufVxcblxcbmZuIHJhbmQoY286IHZlYzI8ZjMyPikgLT4gZjMyXFxue1xcbiAgcmV0dXJuIGZyYWN0KHNpbihkb3QoY28sIHZlYzI8ZjMyPigxMi45ODk4LCA3OC4yMzMpKSkgKiA0Mzc1OC41NDUzKTtcXG59XFxuXFxuZm4gdmlnbmV0dGUoY286IHZlYzM8ZjMyPiwgY29vcmQ6IHZlYzI8ZjMyPikgLT4gZjMyXFxue1xcbiAgbGV0IHVWaWduZXR0ZSA9IGNydFVuaWZvcm1zLnVWaWduZXR0ZTtcXG4gIGxldCB1RGltZW5zaW9ucyA9IGNydFVuaWZvcm1zLnVEaW1lbnNpb25zO1xcbiAgXFxuICBsZXQgb3V0dGVyOiBmMzIgPSBTUVJUXzIgLSB1VmlnbmV0dGVbMF0gKiBTUVJUXzI7XFxuICB2YXIgZGlyOiB2ZWMyPGYzMj4gPSB2ZWMyPGYzMj4oMC41KSAtIGNvb3JkO1xcbiAgZGlyLnkgKj0gdURpbWVuc2lvbnMueSAvIHVEaW1lbnNpb25zLng7XFxuICBsZXQgZGFya2VyOiBmMzIgPSBjbGFtcCgob3V0dGVyIC0gbGVuZ3RoKGRpcikgKiBTUVJUXzIpIC8gKCAwLjAwMDAxICsgdVZpZ25ldHRlWzJdICogU1FSVF8yKSwgMC4wLCAxLjApO1xcbiAgcmV0dXJuIGRhcmtlciArICgxLjAgLSBkYXJrZXIpICogKDEuMCAtIHVWaWduZXR0ZVsxXSk7XFxufVxcblxcbmZuIG5vaXNlKGNvb3JkOiB2ZWMyPGYzMj4pIC0+IGYzMlxcbntcXG4gIGxldCB1Tm9pc2UgPSBjcnRVbmlmb3Jtcy51Tm9pc2U7XFxuICBsZXQgdVNlZWQgPSBjcnRVbmlmb3Jtcy51U2VlZDtcXG5cXG4gIHZhciBwaXhlbENvb3JkOiB2ZWMyPGYzMj4gPSBjb29yZCAqIGdmdS51SW5wdXRTaXplLnh5O1xcbiAgcGl4ZWxDb29yZC54ID0gZmxvb3IocGl4ZWxDb29yZC54IC8gdU5vaXNlWzFdKTtcXG4gIHBpeGVsQ29vcmQueSA9IGZsb29yKHBpeGVsQ29vcmQueSAvIHVOb2lzZVsxXSk7XFxuICByZXR1cm4gKHJhbmQocGl4ZWxDb29yZCAqIHVOb2lzZVsxXSAqIHVTZWVkKSAtIDAuNSkgKiB1Tm9pc2VbMF07XFxufVxcblxcbmZuIGludGVybGFjZUxpbmVzKGNvOiB2ZWMzPGYzMj4sIGNvb3JkOiB2ZWMyPGYzMj4pIC0+IHZlYzM8ZjMyPlxcbntcXG4gIHZhciBjb2xvciA9IGNvO1xcblxcbiAgbGV0IHVEaW1lbnNpb25zID0gY3J0VW5pZm9ybXMudURpbWVuc2lvbnM7XFxuXFxuICBsZXQgY3VydmF0dXJlOiBmMzIgPSBjcnRVbmlmb3Jtcy51TGluZVswXTtcXG4gIGxldCBsaW5lV2lkdGg6IGYzMiA9IGNydFVuaWZvcm1zLnVMaW5lWzFdO1xcbiAgbGV0IGxpbmVDb250cmFzdDogZjMyID0gY3J0VW5pZm9ybXMudUxpbmVbMl07XFxuICBsZXQgdmVydGljYWxMaW5lOiBmMzIgPSBjcnRVbmlmb3Jtcy51TGluZVszXTtcXG5cXG4gIGxldCBkaXI6IHZlYzI8ZjMyPiA9IHZlYzI8ZjMyPihjb29yZCAqIGdmdS51SW5wdXRTaXplLnh5IC8gdURpbWVuc2lvbnMgLSAwLjUpO1xcblxcbiAgbGV0IF9jOiBmMzIgPSBzZWxlY3QoMS4sIGN1cnZhdHVyZSwgY3VydmF0dXJlID4gMC4pO1xcbiAgbGV0IGs6IGYzMiA9IHNlbGVjdCgxLiwgKGxlbmd0aChkaXIgKiBkaXIpICogMC4yNSAqIF9jICogX2MgKyAwLjkzNSAqIF9jKSwgY3VydmF0dXJlID4gMC4pO1xcbiAgbGV0IHV2OiB2ZWMyPGYzMj4gPSBkaXIgKiBrO1xcbiAgbGV0IHY6IGYzMiA9IHNlbGVjdCh1di55ICogdURpbWVuc2lvbnMueSwgdXYueCAqIHVEaW1lbnNpb25zLngsIHZlcnRpY2FsTGluZSA+IDAuNSkgKiBtaW4oMS4wLCAyLjAgLyBsaW5lV2lkdGggKSAvIF9jO1xcbiAgbGV0IGo6IGYzMiA9IDEuICsgY29zKHYgKiAxLjIgLSBjcnRVbmlmb3Jtcy51VGltZSkgKiAwLjUgKiBsaW5lQ29udHJhc3Q7XFxuICBjb2xvciAqPSBqO1xcblxcbiAgbGV0IHNlZ21lbnQ6IGYzMiA9IHNlbGVjdChtb2R1bG8oKGRpci55ICsgLjUpICogdURpbWVuc2lvbnMueSwgNC4pLCBtb2R1bG8oKGRpci54ICsgLjUpICogdURpbWVuc2lvbnMueCwgNC4pLCB2ZXJ0aWNhbExpbmUgPiAwLjUpO1xcbiAgY29sb3IgKj0gMC45OSArIGNlaWwoc2VnbWVudCkgKiAwLjAxNTtcXG5cXG4gIHJldHVybiBjb2xvcjtcXG59XCI7XG5cbmV4cG9ydCB7IHNvdXJjZSBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcnQyLm1qcy5tYXBcbiIsInZhciBmcmFnbWVudCA9IFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbmluIHZlYzIgdlRleHR1cmVDb29yZDtcXG5vdXQgdmVjNCBmaW5hbENvbG9yO1xcblxcbnVuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbnVuaWZvcm0gdmVjNCB1TGluZTtcXG51bmlmb3JtIHZlYzIgdU5vaXNlO1xcbnVuaWZvcm0gdmVjMyB1VmlnbmV0dGU7XFxudW5pZm9ybSBmbG9hdCB1U2VlZDtcXG51bmlmb3JtIGZsb2F0IHVUaW1lO1xcbnVuaWZvcm0gdmVjMiB1RGltZW5zaW9ucztcXG5cXG51bmlmb3JtIHZlYzQgdUlucHV0U2l6ZTtcXG5cXG5jb25zdCBmbG9hdCBTUVJUXzIgPSAxLjQxNDIxMztcXG5cXG5mbG9hdCByYW5kKHZlYzIgY28pIHtcXG4gICAgcmV0dXJuIGZyYWN0KHNpbihkb3QoY28ueHksIHZlYzIoMTIuOTg5OCwgNzguMjMzKSkpICogNDM3NTguNTQ1Myk7XFxufVxcblxcbmZsb2F0IHZpZ25ldHRlKHZlYzMgY28sIHZlYzIgY29vcmQpXFxue1xcbiAgICBmbG9hdCBvdXR0ZXIgPSBTUVJUXzIgLSB1VmlnbmV0dGVbMF0gKiBTUVJUXzI7XFxuICAgIHZlYzIgZGlyID0gdmVjMigwLjUpIC0gY29vcmQ7XFxuICAgIGRpci55ICo9IHVEaW1lbnNpb25zLnkgLyB1RGltZW5zaW9ucy54O1xcbiAgICBmbG9hdCBkYXJrZXIgPSBjbGFtcCgob3V0dGVyIC0gbGVuZ3RoKGRpcikgKiBTUVJUXzIpIC8gKCAwLjAwMDAxICsgdVZpZ25ldHRlWzJdICogU1FSVF8yKSwgMC4wLCAxLjApO1xcbiAgICByZXR1cm4gZGFya2VyICsgKDEuMCAtIGRhcmtlcikgKiAoMS4wIC0gdVZpZ25ldHRlWzFdKTtcXG59XFxuXFxuZmxvYXQgbm9pc2UodmVjMiBjb29yZClcXG57XFxuICAgIHZlYzIgcGl4ZWxDb29yZCA9IGNvb3JkICogdUlucHV0U2l6ZS54eTtcXG4gICAgcGl4ZWxDb29yZC54ID0gZmxvb3IocGl4ZWxDb29yZC54IC8gdU5vaXNlWzFdKTtcXG4gICAgcGl4ZWxDb29yZC55ID0gZmxvb3IocGl4ZWxDb29yZC55IC8gdU5vaXNlWzFdKTtcXG4gICAgcmV0dXJuIChyYW5kKHBpeGVsQ29vcmQgKiB1Tm9pc2VbMV0gKiB1U2VlZCkgLSAwLjUpICogdU5vaXNlWzBdO1xcbn1cXG5cXG52ZWMzIGludGVybGFjZUxpbmVzKHZlYzMgY28sIHZlYzIgY29vcmQpXFxue1xcbiAgICB2ZWMzIGNvbG9yID0gY287XFxuXFxuICAgIGZsb2F0IGN1cnZhdHVyZSA9IHVMaW5lWzBdO1xcbiAgICBmbG9hdCBsaW5lV2lkdGggPSB1TGluZVsxXTtcXG4gICAgZmxvYXQgbGluZUNvbnRyYXN0ID0gdUxpbmVbMl07XFxuICAgIGZsb2F0IHZlcnRpY2FsTGluZSA9IHVMaW5lWzNdO1xcblxcbiAgICB2ZWMyIGRpciA9IHZlYzIoY29vcmQgKiB1SW5wdXRTaXplLnh5IC8gdURpbWVuc2lvbnMgLSAwLjUpO1xcblxcbiAgICBmbG9hdCBfYyA9IGN1cnZhdHVyZSA+IDAuID8gY3VydmF0dXJlIDogMS47XFxuICAgIGZsb2F0IGsgPSBjdXJ2YXR1cmUgPiAwLiA/IChsZW5ndGgoZGlyICogZGlyKSAqIDAuMjUgKiBfYyAqIF9jICsgMC45MzUgKiBfYykgOiAxLjtcXG4gICAgdmVjMiB1diA9IGRpciAqIGs7XFxuICAgIGZsb2F0IHYgPSB2ZXJ0aWNhbExpbmUgPiAwLjUgPyB1di54ICogdURpbWVuc2lvbnMueCA6IHV2LnkgKiB1RGltZW5zaW9ucy55O1xcbiAgICB2ICo9IG1pbigxLjAsIDIuMCAvIGxpbmVXaWR0aCApIC8gX2M7XFxuICAgIGZsb2F0IGogPSAxLiArIGNvcyh2ICogMS4yIC0gdVRpbWUpICogMC41ICogbGluZUNvbnRyYXN0O1xcbiAgICBjb2xvciAqPSBqO1xcblxcbiAgICBmbG9hdCBzZWdtZW50ID0gdmVydGljYWxMaW5lID4gMC41ID8gbW9kKChkaXIueCArIC41KSAqIHVEaW1lbnNpb25zLngsIDQuKSA6IG1vZCgoZGlyLnkgKyAuNSkgKiB1RGltZW5zaW9ucy55LCA0Lik7XFxuICAgIGNvbG9yICo9IDAuOTkgKyBjZWlsKHNlZ21lbnQpICogMC4wMTU7XFxuXFxuICAgIHJldHVybiBjb2xvcjtcXG59XFxuXFxudm9pZCBtYWluKHZvaWQpXFxue1xcbiAgICBmaW5hbENvbG9yID0gdGV4dHVyZSh1VGV4dHVyZSwgdlRleHR1cmVDb29yZCk7XFxuICAgIHZlYzIgY29vcmQgPSB2VGV4dHVyZUNvb3JkICogdUlucHV0U2l6ZS54eSAvIHVEaW1lbnNpb25zO1xcblxcbiAgICBpZiAodU5vaXNlWzBdID4gMC4wICYmIHVOb2lzZVsxXSA+IDAuMClcXG4gICAge1xcbiAgICAgICAgZmxvYXQgbiA9IG5vaXNlKHZUZXh0dXJlQ29vcmQpO1xcbiAgICAgICAgZmluYWxDb2xvciArPSB2ZWM0KG4sIG4sIG4sIGZpbmFsQ29sb3IuYSk7XFxuICAgIH1cXG5cXG4gICAgaWYgKHVWaWduZXR0ZVswXSA+IDAuKVxcbiAgICB7XFxuICAgICAgICBmbG9hdCB2ID0gdmlnbmV0dGUoZmluYWxDb2xvci5yZ2IsIGNvb3JkKTtcXG4gICAgICAgIGZpbmFsQ29sb3IgKj0gdmVjNCh2LCB2LCB2LCBmaW5hbENvbG9yLmEpO1xcbiAgICB9XFxuXFxuICAgIGlmICh1TGluZVsxXSA+IDAuMClcXG4gICAge1xcbiAgICAgICAgZmluYWxDb2xvciA9IHZlYzQoaW50ZXJsYWNlTGluZXMoZmluYWxDb2xvci5yZ2IsIHZUZXh0dXJlQ29vcmQpLCBmaW5hbENvbG9yLmEpOyAgXFxuICAgIH1cXG59XFxuXCI7XG5cbmV4cG9ydCB7IGZyYWdtZW50IGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNydC5tanMubWFwXG4iLCJ2YXIgd2dzbFZlcnRleCA9IFwic3RydWN0IEdsb2JhbEZpbHRlclVuaWZvcm1zIHtcXG4gIHVJbnB1dFNpemU6dmVjNDxmMzI+LFxcbiAgdUlucHV0UGl4ZWw6dmVjNDxmMzI+LFxcbiAgdUlucHV0Q2xhbXA6dmVjNDxmMzI+LFxcbiAgdU91dHB1dEZyYW1lOnZlYzQ8ZjMyPixcXG4gIHVHbG9iYWxGcmFtZTp2ZWM0PGYzMj4sXFxuICB1T3V0cHV0VGV4dHVyZTp2ZWM0PGYzMj4sXFxufTtcXG5cXG5AZ3JvdXAoMCkgQGJpbmRpbmcoMCkgdmFyPHVuaWZvcm0+IGdmdTogR2xvYmFsRmlsdGVyVW5pZm9ybXM7XFxuXFxuc3RydWN0IFZTT3V0cHV0IHtcXG4gICAgQGJ1aWx0aW4ocG9zaXRpb24pIHBvc2l0aW9uOiB2ZWM0PGYzMj4sXFxuICAgIEBsb2NhdGlvbigwKSB1diA6IHZlYzI8ZjMyPlxcbiAgfTtcXG5cXG5mbiBmaWx0ZXJWZXJ0ZXhQb3NpdGlvbihhUG9zaXRpb246dmVjMjxmMzI+KSAtPiB2ZWM0PGYzMj5cXG57XFxuICAgIHZhciBwb3NpdGlvbiA9IGFQb3NpdGlvbiAqIGdmdS51T3V0cHV0RnJhbWUuencgKyBnZnUudU91dHB1dEZyYW1lLnh5O1xcblxcbiAgICBwb3NpdGlvbi54ID0gcG9zaXRpb24ueCAqICgyLjAgLyBnZnUudU91dHB1dFRleHR1cmUueCkgLSAxLjA7XFxuICAgIHBvc2l0aW9uLnkgPSBwb3NpdGlvbi55ICogKDIuMCpnZnUudU91dHB1dFRleHR1cmUueiAvIGdmdS51T3V0cHV0VGV4dHVyZS55KSAtIGdmdS51T3V0cHV0VGV4dHVyZS56O1xcblxcbiAgICByZXR1cm4gdmVjNChwb3NpdGlvbiwgMC4wLCAxLjApO1xcbn1cXG5cXG5mbiBmaWx0ZXJUZXh0dXJlQ29vcmQoIGFQb3NpdGlvbjp2ZWMyPGYzMj4gKSAtPiB2ZWMyPGYzMj5cXG57XFxuICAgIHJldHVybiBhUG9zaXRpb24gKiAoZ2Z1LnVPdXRwdXRGcmFtZS56dyAqIGdmdS51SW5wdXRTaXplLnp3KTtcXG59XFxuXFxuZm4gZ2xvYmFsVGV4dHVyZUNvb3JkKCBhUG9zaXRpb246dmVjMjxmMzI+ICkgLT4gdmVjMjxmMzI+XFxue1xcbiAgcmV0dXJuICAoYVBvc2l0aW9uLnh5IC8gZ2Z1LnVHbG9iYWxGcmFtZS56dykgKyAoZ2Z1LnVHbG9iYWxGcmFtZS54eSAvIGdmdS51R2xvYmFsRnJhbWUuencpOyAgXFxufVxcblxcbmZuIGdldFNpemUoKSAtPiB2ZWMyPGYzMj5cXG57XFxuICByZXR1cm4gZ2Z1LnVHbG9iYWxGcmFtZS56dztcXG59XFxuICBcXG5AdmVydGV4XFxuZm4gbWFpblZlcnRleChcXG4gIEBsb2NhdGlvbigwKSBhUG9zaXRpb24gOiB2ZWMyPGYzMj4sIFxcbikgLT4gVlNPdXRwdXQge1xcbiAgcmV0dXJuIFZTT3V0cHV0KFxcbiAgIGZpbHRlclZlcnRleFBvc2l0aW9uKGFQb3NpdGlvbiksXFxuICAgZmlsdGVyVGV4dHVyZUNvb3JkKGFQb3NpdGlvbilcXG4gICk7XFxufVwiO1xuXG5leHBvcnQgeyB3Z3NsVmVydGV4IGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlZmF1bHQubWpzLm1hcFxuIiwidmFyIHZlcnRleCA9IFwiaW4gdmVjMiBhUG9zaXRpb247XFxub3V0IHZlYzIgdlRleHR1cmVDb29yZDtcXG5cXG51bmlmb3JtIHZlYzQgdUlucHV0U2l6ZTtcXG51bmlmb3JtIHZlYzQgdU91dHB1dEZyYW1lO1xcbnVuaWZvcm0gdmVjNCB1T3V0cHV0VGV4dHVyZTtcXG5cXG52ZWM0IGZpbHRlclZlcnRleFBvc2l0aW9uKCB2b2lkIClcXG57XFxuICAgIHZlYzIgcG9zaXRpb24gPSBhUG9zaXRpb24gKiB1T3V0cHV0RnJhbWUuencgKyB1T3V0cHV0RnJhbWUueHk7XFxuICAgIFxcbiAgICBwb3NpdGlvbi54ID0gcG9zaXRpb24ueCAqICgyLjAgLyB1T3V0cHV0VGV4dHVyZS54KSAtIDEuMDtcXG4gICAgcG9zaXRpb24ueSA9IHBvc2l0aW9uLnkgKiAoMi4wKnVPdXRwdXRUZXh0dXJlLnogLyB1T3V0cHV0VGV4dHVyZS55KSAtIHVPdXRwdXRUZXh0dXJlLno7XFxuXFxuICAgIHJldHVybiB2ZWM0KHBvc2l0aW9uLCAwLjAsIDEuMCk7XFxufVxcblxcbnZlYzIgZmlsdGVyVGV4dHVyZUNvb3JkKCB2b2lkIClcXG57XFxuICAgIHJldHVybiBhUG9zaXRpb24gKiAodU91dHB1dEZyYW1lLnp3ICogdUlucHV0U2l6ZS56dyk7XFxufVxcblxcbnZvaWQgbWFpbih2b2lkKVxcbntcXG4gICAgZ2xfUG9zaXRpb24gPSBmaWx0ZXJWZXJ0ZXhQb3NpdGlvbigpO1xcbiAgICB2VGV4dHVyZUNvb3JkID0gZmlsdGVyVGV4dHVyZUNvb3JkKCk7XFxufVxcblwiO1xuXG5leHBvcnQgeyB2ZXJ0ZXggYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVmYXVsdDIubWpzLm1hcFxuIiwiaW1wb3J0IHsgRmlsdGVyLCBkZXByZWNhdGlvbiwgR3B1UHJvZ3JhbSwgR2xQcm9ncmFtIH0gZnJvbSAncGl4aS5qcyc7XG5pbXBvcnQgdmVydGV4IGZyb20gJy4uL2RlZmF1bHRzL2RlZmF1bHQyLm1qcyc7XG5pbXBvcnQgd2dzbFZlcnRleCBmcm9tICcuLi9kZWZhdWx0cy9kZWZhdWx0Lm1qcyc7XG5pbXBvcnQgZnJhZ21lbnQgZnJvbSAnLi9kb3QyLm1qcyc7XG5pbXBvcnQgc291cmNlIGZyb20gJy4vZG90Lm1qcyc7XG5cbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbmNvbnN0IF9Eb3RGaWx0ZXIgPSBjbGFzcyBfRG90RmlsdGVyIGV4dGVuZHMgRmlsdGVyIHtcbiAgLyoqIEBpZ25vcmUgKi9cbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIGxldCBvcHRpb25zID0gYXJnc1swXSA/PyB7fTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGRlcHJlY2F0aW9uKFwiNi4wLjBcIiwgXCJEb3RGaWx0ZXIgY29uc3RydWN0b3IgcGFyYW1zIGFyZSBub3cgb3B0aW9ucyBvYmplY3QuIFNlZSBwYXJhbXM6IHsgc2NhbGUsIGFuZ2xlLCBncmF5c2NhbGUgfVwiKTtcbiAgICAgIG9wdGlvbnMgPSB7IHNjYWxlOiBvcHRpb25zIH07XG4gICAgICBpZiAoYXJnc1sxXSAhPT0gdm9pZCAwKVxuICAgICAgICBvcHRpb25zLmFuZ2xlID0gYXJnc1sxXTtcbiAgICAgIGlmIChhcmdzWzJdICE9PSB2b2lkIDApXG4gICAgICAgIG9wdGlvbnMuZ3JheXNjYWxlID0gYXJnc1syXTtcbiAgICB9XG4gICAgb3B0aW9ucyA9IHsgLi4uX0RvdEZpbHRlci5ERUZBVUxUX09QVElPTlMsIC4uLm9wdGlvbnMgfTtcbiAgICBjb25zdCBkb3RVbmlmb3JtcyA9IHtcbiAgICAgIHVTY2FsZTogeyB2YWx1ZTogb3B0aW9ucy5zY2FsZSwgdHlwZTogXCJmMzJcIiB9LFxuICAgICAgdUFuZ2xlOiB7IHZhbHVlOiBvcHRpb25zLmFuZ2xlLCB0eXBlOiBcImYzMlwiIH0sXG4gICAgICB1R3JheVNjYWxlOiB7IHZhbHVlOiBvcHRpb25zLmdyYXlzY2FsZSA/IDEgOiAwLCB0eXBlOiBcImYzMlwiIH1cbiAgICB9O1xuICAgIGNvbnN0IGdwdVByb2dyYW0gPSBHcHVQcm9ncmFtLmZyb20oe1xuICAgICAgdmVydGV4OiB7XG4gICAgICAgIHNvdXJjZTogd2dzbFZlcnRleCxcbiAgICAgICAgZW50cnlQb2ludDogXCJtYWluVmVydGV4XCJcbiAgICAgIH0sXG4gICAgICBmcmFnbWVudDoge1xuICAgICAgICBzb3VyY2UsXG4gICAgICAgIGVudHJ5UG9pbnQ6IFwibWFpbkZyYWdtZW50XCJcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBnbFByb2dyYW0gPSBHbFByb2dyYW0uZnJvbSh7XG4gICAgICB2ZXJ0ZXgsXG4gICAgICBmcmFnbWVudCxcbiAgICAgIG5hbWU6IFwiZG90LWZpbHRlclwiXG4gICAgfSk7XG4gICAgc3VwZXIoe1xuICAgICAgZ3B1UHJvZ3JhbSxcbiAgICAgIGdsUHJvZ3JhbSxcbiAgICAgIHJlc291cmNlczoge1xuICAgICAgICBkb3RVbmlmb3Jtc1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgc2NhbGUgb2YgdGhlIGVmZmVjdC5cbiAgICogQGRlZmF1bHQgMVxuICAgKi9cbiAgZ2V0IHNjYWxlKCkge1xuICAgIHJldHVybiB0aGlzLnJlc291cmNlcy5kb3RVbmlmb3Jtcy51bmlmb3Jtcy51U2NhbGU7XG4gIH1cbiAgc2V0IHNjYWxlKHZhbHVlKSB7XG4gICAgdGhpcy5yZXNvdXJjZXMuZG90VW5pZm9ybXMudW5pZm9ybXMudVNjYWxlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICogVGhlIHJhZGl1cyBvZiB0aGUgZWZmZWN0LlxuICAqIEBkZWZhdWx0IDVcbiAgKi9cbiAgZ2V0IGFuZ2xlKCkge1xuICAgIHJldHVybiB0aGlzLnJlc291cmNlcy5kb3RVbmlmb3Jtcy51bmlmb3Jtcy51QW5nbGU7XG4gIH1cbiAgc2V0IGFuZ2xlKHZhbHVlKSB7XG4gICAgdGhpcy5yZXNvdXJjZXMuZG90VW5pZm9ybXMudW5pZm9ybXMudUFuZ2xlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICogV2hldGhlciB0byByZW5kZXJpbmcgaXQgaW4gZ3JheSBzY2FsZS5cbiAgKiBAZGVmYXVsdCB0cnVlXG4gICovXG4gIGdldCBncmF5c2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb3VyY2VzLmRvdFVuaWZvcm1zLnVuaWZvcm1zLnVHcmF5U2NhbGUgPT09IDE7XG4gIH1cbiAgc2V0IGdyYXlzY2FsZSh2YWx1ZSkge1xuICAgIHRoaXMucmVzb3VyY2VzLmRvdFVuaWZvcm1zLnVuaWZvcm1zLnVHcmF5U2NhbGUgPSB2YWx1ZSA/IDEgOiAwO1xuICB9XG59O1xuLyoqIERlZmF1bHQgdmFsdWVzIGZvciBvcHRpb25zLiAqL1xuX19wdWJsaWNGaWVsZChfRG90RmlsdGVyLCBcIkRFRkFVTFRfT1BUSU9OU1wiLCB7XG4gIHNjYWxlOiAxLFxuICBhbmdsZTogNSxcbiAgZ3JheXNjYWxlOiB0cnVlXG59KTtcbmxldCBEb3RGaWx0ZXIgPSBfRG90RmlsdGVyO1xuXG5leHBvcnQgeyBEb3RGaWx0ZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURvdEZpbHRlci5tanMubWFwXG4iLCJ2YXIgc291cmNlID0gXCJzdHJ1Y3QgRG90VW5pZm9ybXMge1xcbiAgdVNjYWxlOmYzMixcXG4gIHVBbmdsZTpmMzIsXFxuICB1R3JheVNjYWxlOmYzMixcXG59O1xcblxcbnN0cnVjdCBHbG9iYWxGaWx0ZXJVbmlmb3JtcyB7XFxuICB1SW5wdXRTaXplOnZlYzQ8ZjMyPixcXG4gIHVJbnB1dFBpeGVsOnZlYzQ8ZjMyPixcXG4gIHVJbnB1dENsYW1wOnZlYzQ8ZjMyPixcXG4gIHVPdXRwdXRGcmFtZTp2ZWM0PGYzMj4sXFxuICB1R2xvYmFsRnJhbWU6dmVjNDxmMzI+LFxcbiAgdU91dHB1dFRleHR1cmU6dmVjNDxmMzI+LFxcbn07XFxuXFxuQGdyb3VwKDApIEBiaW5kaW5nKDApIHZhcjx1bmlmb3JtPiBnZnU6IEdsb2JhbEZpbHRlclVuaWZvcm1zO1xcblxcbkBncm91cCgwKSBAYmluZGluZygxKSB2YXIgdVRleHR1cmU6IHRleHR1cmVfMmQ8ZjMyPjsgXFxuQGdyb3VwKDApIEBiaW5kaW5nKDIpIHZhciB1U2FtcGxlcjogc2FtcGxlcjtcXG5AZ3JvdXAoMSkgQGJpbmRpbmcoMCkgdmFyPHVuaWZvcm0+IGRvdFVuaWZvcm1zIDogRG90VW5pZm9ybXM7XFxuXFxuQGZyYWdtZW50XFxuZm4gbWFpbkZyYWdtZW50KFxcbiAgQGxvY2F0aW9uKDApIHV2OiB2ZWMyPGYzMj4sXFxuICBAYnVpbHRpbihwb3NpdGlvbikgcG9zaXRpb246IHZlYzQ8ZjMyPlxcbikgLT4gQGxvY2F0aW9uKDApIHZlYzQ8ZjMyPiB7XFxuICBsZXQgY29sb3I6IHZlYzQ8ZjMyPiA9IHRleHR1cmVTYW1wbGUodVRleHR1cmUsIHVTYW1wbGVyLCB1dik7XFxuICBsZXQgZ3JheTogdmVjMzxmMzI+ID0gdmVjMzxmMzI+KGRvdChjb2xvci5yZ2IsIHZlYzM8ZjMyPigwLjI5OSwgMC41ODcsIDAuMTE0KSkpO1xcbiAgLy8gZG90VW5pZm9ybXMudUdyYXlTY2FsZSA9PSAxIGRvZXNuJ3QgZXZlciBwYXNzIHNvIGl0IGlzIGNvbnZlcnRlZCB0byBhIGZsb2F0IGFuZCBjb21wYXJlZCB0byAwLjUgaW5zdGVhZCBcXG4gIGxldCBmaW5hbENvbG9yOiB2ZWMzPGYzMj4gPSBzZWxlY3QoY29sb3IucmdiLCBncmF5LCBmMzIoZG90VW5pZm9ybXMudUdyYXlTY2FsZSkgPj0gMC41KTtcXG5cXG4gIHJldHVybiB2ZWM0PGYzMj4oZmluYWxDb2xvciAqIDEwLjAgLSA1LjAgKyBwYXR0ZXJuKHV2KSwgY29sb3IuYSk7XFxufVxcblxcbmZuIHBhdHRlcm4odXY6IHZlYzI8ZjMyPikgLT4gZjMyXFxue1xcbiAgbGV0IHM6IGYzMiA9IHNpbihkb3RVbmlmb3Jtcy51QW5nbGUpO1xcbiAgbGV0IGM6IGYzMiA9IGNvcyhkb3RVbmlmb3Jtcy51QW5nbGUpO1xcbiAgXFxuICBsZXQgdGV4OiB2ZWMyPGYzMj4gPSB1diAqIGdmdS51SW5wdXRTaXplLnh5O1xcbiAgXFxuICBsZXQgcDogdmVjMjxmMzI+ID0gdmVjMjxmMzI+KFxcbiAgICAgIGMgKiB0ZXgueCAtIHMgKiB0ZXgueSxcXG4gICAgICBzICogdGV4LnggKyBjICogdGV4LnlcXG4gICkgKiBkb3RVbmlmb3Jtcy51U2NhbGU7XFxuXFxuICByZXR1cm4gKHNpbihwLngpICogc2luKHAueSkpICogNC4wO1xcbn1cIjtcblxuZXhwb3J0IHsgc291cmNlIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRvdC5tanMubWFwXG4iLCJ2YXIgZnJhZ21lbnQgPSBcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5pbiB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxub3V0IHZlYzQgZmluYWxDb2xvcjtcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG51bmlmb3JtIGZsb2F0IHVBbmdsZTtcXG51bmlmb3JtIGZsb2F0IHVTY2FsZTtcXG51bmlmb3JtIGJvb2wgdUdyYXlTY2FsZTtcXG5cXG51bmlmb3JtIHZlYzQgdUlucHV0U2l6ZTtcXG5cXG5mbG9hdCBwYXR0ZXJuKClcXG57XFxuICAgIGZsb2F0IHMgPSBzaW4odUFuZ2xlKSwgYyA9IGNvcyh1QW5nbGUpO1xcbiAgICB2ZWMyIHRleCA9IHZUZXh0dXJlQ29vcmQgKiB1SW5wdXRTaXplLnh5O1xcbiAgICB2ZWMyIHBvaW50ID0gdmVjMihcXG4gICAgICAgIGMgKiB0ZXgueCAtIHMgKiB0ZXgueSxcXG4gICAgICAgIHMgKiB0ZXgueCArIGMgKiB0ZXgueVxcbiAgICApICogdVNjYWxlO1xcbiAgICByZXR1cm4gKHNpbihwb2ludC54KSAqIHNpbihwb2ludC55KSkgKiA0LjA7XFxuICAgIH1cXG5cXG4gICAgdm9pZCBtYWluKClcXG4gICAge1xcbiAgICB2ZWM0IGNvbG9yID0gdGV4dHVyZSh1VGV4dHVyZSwgdlRleHR1cmVDb29yZCk7XFxuICAgIHZlYzMgY29sb3JSR0IgPSB2ZWMzKGNvbG9yKTtcXG5cXG4gICAgaWYgKHVHcmF5U2NhbGUpXFxuICAgIHtcXG4gICAgICAgIGNvbG9yUkdCID0gdmVjMyhjb2xvci5yICsgY29sb3IuZyArIGNvbG9yLmIpIC8gMy4wO1xcbiAgICB9XFxuXFxuICAgIGZpbmFsQ29sb3IgPSB2ZWM0KGNvbG9yUkdCICogMTAuMCAtIDUuMCArIHBhdHRlcm4oKSwgY29sb3IuYSk7XFxufVxcblwiO1xuXG5leHBvcnQgeyBmcmFnbWVudCBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kb3QyLm1qcy5tYXBcbiIsImltcG9ydCB7IEZpbHRlciwgR3B1UHJvZ3JhbSwgR2xQcm9ncmFtLCBDb2xvciwgVGV4dHVyZVBvb2wgfSBmcm9tICdwaXhpLmpzJztcbmltcG9ydCB2ZXJ0ZXggZnJvbSAnLi4vZGVmYXVsdHMvZGVmYXVsdDIubWpzJztcbmltcG9ydCB3Z3NsVmVydGV4IGZyb20gJy4uL2RlZmF1bHRzL2RlZmF1bHQubWpzJztcbmltcG9ydCB7IEthd2FzZUJsdXJGaWx0ZXIgfSBmcm9tICcuLi9rYXdhc2UtYmx1ci9LYXdhc2VCbHVyRmlsdGVyLm1qcyc7XG5pbXBvcnQgZnJhZ21lbnQgZnJvbSAnLi9kcm9wLXNoYWRvdy5tanMnO1xuaW1wb3J0IHNvdXJjZSBmcm9tICcuL2Ryb3Atc2hhZG93Mi5tanMnO1xuXG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiB7XG4gIF9fZGVmTm9ybWFsUHJvcChvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5jb25zdCBfRHJvcFNoYWRvd0ZpbHRlciA9IGNsYXNzIF9Ecm9wU2hhZG93RmlsdGVyIGV4dGVuZHMgRmlsdGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgdGhlIERyb3BTaGFkb3dGaWx0ZXIgY29uc3RydWN0b3IuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHsgLi4uX0Ryb3BTaGFkb3dGaWx0ZXIuREVGQVVMVF9PUFRJT05TLCAuLi5vcHRpb25zIH07XG4gICAgY29uc3QgZ3B1UHJvZ3JhbSA9IEdwdVByb2dyYW0uZnJvbSh7XG4gICAgICB2ZXJ0ZXg6IHtcbiAgICAgICAgc291cmNlOiB3Z3NsVmVydGV4LFxuICAgICAgICBlbnRyeVBvaW50OiBcIm1haW5WZXJ0ZXhcIlxuICAgICAgfSxcbiAgICAgIGZyYWdtZW50OiB7XG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgZW50cnlQb2ludDogXCJtYWluRnJhZ21lbnRcIlxuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGdsUHJvZ3JhbSA9IEdsUHJvZ3JhbS5mcm9tKHtcbiAgICAgIHZlcnRleCxcbiAgICAgIGZyYWdtZW50LFxuICAgICAgbmFtZTogXCJkcm9wLXNoYWRvdy1maWx0ZXJcIlxuICAgIH0pO1xuICAgIHN1cGVyKHtcbiAgICAgIGdwdVByb2dyYW0sXG4gICAgICBnbFByb2dyYW0sXG4gICAgICByZXNvdXJjZXM6IHtcbiAgICAgICAgZHJvcFNoYWRvd1VuaWZvcm1zOiB7XG4gICAgICAgICAgdUFscGhhOiB7IHZhbHVlOiBvcHRpb25zLmFscGhhLCB0eXBlOiBcImYzMlwiIH0sXG4gICAgICAgICAgdUNvbG9yOiB7IHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KDMpLCB0eXBlOiBcInZlYzM8ZjMyPlwiIH0sXG4gICAgICAgICAgdU9mZnNldDogeyB2YWx1ZTogb3B0aW9ucy5vZmZzZXQsIHR5cGU6IFwidmVjMjxmMzI+XCIgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcmVzb2x1dGlvbjogb3B0aW9ucy5yZXNvbHV0aW9uXG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInVuaWZvcm1zXCIpO1xuICAgIC8qKlxuICAgICAqIEhpZGUgdGhlIGNvbnRlbnRzLCBvbmx5IHNob3cgdGhlIHNoYWRvdy5cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzaGFkb3dPbmx5XCIsIGZhbHNlKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX2NvbG9yXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfYmx1ckZpbHRlclwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX2Jhc2VQYXNzXCIpO1xuICAgIHRoaXMudW5pZm9ybXMgPSB0aGlzLnJlc291cmNlcy5kcm9wU2hhZG93VW5pZm9ybXMudW5pZm9ybXM7XG4gICAgdGhpcy5fY29sb3IgPSBuZXcgQ29sb3IoKTtcbiAgICB0aGlzLmNvbG9yID0gb3B0aW9ucy5jb2xvciA/PyAwO1xuICAgIHRoaXMuX2JsdXJGaWx0ZXIgPSBuZXcgS2F3YXNlQmx1ckZpbHRlcih7XG4gICAgICBzdHJlbmd0aDogb3B0aW9ucy5rZXJuZWxzID8/IG9wdGlvbnMuYmx1cixcbiAgICAgIHF1YWxpdHk6IG9wdGlvbnMua2VybmVscyA/IHZvaWQgMCA6IG9wdGlvbnMucXVhbGl0eVxuICAgIH0pO1xuICAgIHRoaXMuX2Jhc2VQYXNzID0gbmV3IEZpbHRlcih7XG4gICAgICBncHVQcm9ncmFtOiBHcHVQcm9ncmFtLmZyb20oe1xuICAgICAgICB2ZXJ0ZXg6IHtcbiAgICAgICAgICBzb3VyY2U6IHdnc2xWZXJ0ZXgsXG4gICAgICAgICAgZW50cnlQb2ludDogXCJtYWluVmVydGV4XCJcbiAgICAgICAgfSxcbiAgICAgICAgZnJhZ21lbnQ6IHtcbiAgICAgICAgICBzb3VyY2U6IGBcbiAgICAgICAgICAgICAgICAgICAgQGdyb3VwKDApIEBiaW5kaW5nKDEpIHZhciB1VGV4dHVyZTogdGV4dHVyZV8yZDxmMzI+OyBcbiAgICAgICAgICAgICAgICAgICAgQGdyb3VwKDApIEBiaW5kaW5nKDIpIHZhciB1U2FtcGxlcjogc2FtcGxlcjtcbiAgICAgICAgICAgICAgICAgICAgQGZyYWdtZW50XG4gICAgICAgICAgICAgICAgICAgIGZuIG1haW5GcmFnbWVudChcbiAgICAgICAgICAgICAgICAgICAgICAgIEBidWlsdGluKHBvc2l0aW9uKSBwb3NpdGlvbjogdmVjNDxmMzI+LFxuICAgICAgICAgICAgICAgICAgICAgICAgQGxvY2F0aW9uKDApIHV2IDogdmVjMjxmMzI+XG4gICAgICAgICAgICAgICAgICAgICkgLT4gQGxvY2F0aW9uKDApIHZlYzQ8ZjMyPiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGV4dHVyZVNhbXBsZSh1VGV4dHVyZSwgdVNhbXBsZXIsIHV2KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBgLFxuICAgICAgICAgIGVudHJ5UG9pbnQ6IFwibWFpbkZyYWdtZW50XCJcbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICBnbFByb2dyYW06IEdsUHJvZ3JhbS5mcm9tKHtcbiAgICAgICAgdmVydGV4LFxuICAgICAgICBmcmFnbWVudDogYFxuICAgICAgICAgICAgICAgIGluIHZlYzIgdlRleHR1cmVDb29yZDtcbiAgICAgICAgICAgICAgICBvdXQgdmVjNCBmaW5hbENvbG9yO1xuICAgICAgICAgICAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xuXG4gICAgICAgICAgICAgICAgdm9pZCBtYWluKHZvaWQpe1xuICAgICAgICAgICAgICAgICAgICBmaW5hbENvbG9yID0gdGV4dHVyZSh1VGV4dHVyZSwgdlRleHR1cmVDb29yZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGAsXG4gICAgICAgIG5hbWU6IFwiZHJvcC1zaGFkb3ctZmlsdGVyXCJcbiAgICAgIH0pLFxuICAgICAgcmVzb3VyY2VzOiB7fVxuICAgIH0pO1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywgb3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIE92ZXJyaWRlIGV4aXN0aW5nIGFwcGx5IG1ldGhvZCBpbiBgRmlsdGVyYFxuICAgKiBAb3ZlcnJpZGVcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgYXBwbHkoZmlsdGVyTWFuYWdlciwgaW5wdXQsIG91dHB1dCwgY2xlYXJNb2RlKSB7XG4gICAgY29uc3QgcmVuZGVyVGFyZ2V0ID0gVGV4dHVyZVBvb2wuZ2V0U2FtZVNpemVUZXh0dXJlKGlucHV0KTtcbiAgICBmaWx0ZXJNYW5hZ2VyLmFwcGx5RmlsdGVyKHRoaXMsIGlucHV0LCByZW5kZXJUYXJnZXQsIHRydWUpO1xuICAgIHRoaXMuX2JsdXJGaWx0ZXIuYXBwbHkoZmlsdGVyTWFuYWdlciwgcmVuZGVyVGFyZ2V0LCBvdXRwdXQsIGNsZWFyTW9kZSk7XG4gICAgaWYgKCF0aGlzLnNoYWRvd09ubHkpIHtcbiAgICAgIGZpbHRlck1hbmFnZXIuYXBwbHlGaWx0ZXIodGhpcy5fYmFzZVBhc3MsIGlucHV0LCBvdXRwdXQsIGZhbHNlKTtcbiAgICB9XG4gICAgVGV4dHVyZVBvb2wucmV0dXJuVGV4dHVyZShyZW5kZXJUYXJnZXQpO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgdGhlIG9mZnNldCBwb3NpdGlvbiBvZiB0aGUgZHJvcC1zaGFkb3cgcmVsYXRpdmUgdG8gdGhlIG9yaWdpbmFsIGltYWdlLlxuICAgKiBAZGVmYXVsdCBbNCw0XVxuICAgKi9cbiAgZ2V0IG9mZnNldCgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy51T2Zmc2V0O1xuICB9XG4gIHNldCBvZmZzZXQodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnVPZmZzZXQgPSB2YWx1ZTtcbiAgICB0aGlzLl91cGRhdGVQYWRkaW5nKCk7XG4gIH1cbiAgLyoqXG4gICAqIFNldCB0aGUgb2Zmc2V0IHBvc2l0aW9uIG9mIHRoZSBkcm9wLXNoYWRvdyByZWxhdGl2ZSB0byB0aGUgb3JpZ2luYWwgaW1hZ2Ugb24gdGhlIGB4YCBheGlzXG4gICAqIEBkZWZhdWx0IDRcbiAgICovXG4gIGdldCBvZmZzZXRYKCkge1xuICAgIHJldHVybiB0aGlzLm9mZnNldC54O1xuICB9XG4gIHNldCBvZmZzZXRYKHZhbHVlKSB7XG4gICAgdGhpcy5vZmZzZXQueCA9IHZhbHVlO1xuICAgIHRoaXMuX3VwZGF0ZVBhZGRpbmcoKTtcbiAgfVxuICAvKipcbiAgICogU2V0IHRoZSBvZmZzZXQgcG9zaXRpb24gb2YgdGhlIGRyb3Atc2hhZG93IHJlbGF0aXZlIHRvIHRoZSBvcmlnaW5hbCBpbWFnZSBvbiB0aGUgYHlgIGF4aXNcbiAgICogQGRlZmF1bHQgNFxuICAgKi9cbiAgZ2V0IG9mZnNldFkoKSB7XG4gICAgcmV0dXJuIHRoaXMub2Zmc2V0Lnk7XG4gIH1cbiAgc2V0IG9mZnNldFkodmFsdWUpIHtcbiAgICB0aGlzLm9mZnNldC55ID0gdmFsdWU7XG4gICAgdGhpcy5fdXBkYXRlUGFkZGluZygpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgY29sb3IgdmFsdWUgb2Ygc2hhZG93LlxuICAgKiBAZXhhbXBsZSBbMC4wLCAwLjAsIDAuMF0gPSAweDAwMDAwMFxuICAgKiBAZGVmYXVsdCAweDAwMDAwMFxuICAgKi9cbiAgZ2V0IGNvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLl9jb2xvci52YWx1ZTtcbiAgfVxuICBzZXQgY29sb3IodmFsdWUpIHtcbiAgICB0aGlzLl9jb2xvci5zZXRWYWx1ZSh2YWx1ZSk7XG4gICAgY29uc3QgW3IsIGcsIGJdID0gdGhpcy5fY29sb3IudG9BcnJheSgpO1xuICAgIHRoaXMudW5pZm9ybXMudUNvbG9yWzBdID0gcjtcbiAgICB0aGlzLnVuaWZvcm1zLnVDb2xvclsxXSA9IGc7XG4gICAgdGhpcy51bmlmb3Jtcy51Q29sb3JbMl0gPSBiO1xuICB9XG4gIC8qKlxuICAgKiBDb2VmZmljaWVudCBmb3IgYWxwaGEgbXVsdGlwbGljYXRpb25cbiAgICogQGRlZmF1bHQgMVxuICAgKi9cbiAgZ2V0IGFscGhhKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnVBbHBoYTtcbiAgfVxuICBzZXQgYWxwaGEodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnVBbHBoYSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgc3RyZW5ndGggb2YgdGhlIHNoYWRvdydzIGJsdXIuXG4gICAqIEBkZWZhdWx0IDJcbiAgICovXG4gIGdldCBibHVyKCkge1xuICAgIHJldHVybiB0aGlzLl9ibHVyRmlsdGVyLnN0cmVuZ3RoO1xuICB9XG4gIHNldCBibHVyKHZhbHVlKSB7XG4gICAgdGhpcy5fYmx1ckZpbHRlci5zdHJlbmd0aCA9IHZhbHVlO1xuICAgIHRoaXMuX3VwZGF0ZVBhZGRpbmcoKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgcXVhbGl0eSBvZiB0aGUgQmx1ciBGaWx0ZXJcbiAgICogQGRlZmF1bHQgNFxuICAgKi9cbiAgZ2V0IHF1YWxpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JsdXJGaWx0ZXIucXVhbGl0eTtcbiAgfVxuICBzZXQgcXVhbGl0eSh2YWx1ZSkge1xuICAgIHRoaXMuX2JsdXJGaWx0ZXIucXVhbGl0eSA9IHZhbHVlO1xuICAgIHRoaXMuX3VwZGF0ZVBhZGRpbmcoKTtcbiAgfVxuICAvKiogU2V0cyB0aGUga2VybmVscyBvZiB0aGUgQmx1ciBGaWx0ZXIgKi9cbiAgZ2V0IGtlcm5lbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JsdXJGaWx0ZXIua2VybmVscztcbiAgfVxuICBzZXQga2VybmVscyh2YWx1ZSkge1xuICAgIHRoaXMuX2JsdXJGaWx0ZXIua2VybmVscyA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBwaXhlbFNpemUgb2YgdGhlIEthd2FzZSBCbHVyIGZpbHRlclxuICAgKiBAZGVmYXVsdCBbMSwxXVxuICAgKi9cbiAgZ2V0IHBpeGVsU2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYmx1ckZpbHRlci5waXhlbFNpemU7XG4gIH1cbiAgc2V0IHBpeGVsU2l6ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHZhbHVlID0geyB4OiB2YWx1ZSwgeTogdmFsdWUgfTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB2YWx1ZSA9IHsgeDogdmFsdWVbMF0sIHk6IHZhbHVlWzFdIH07XG4gICAgfVxuICAgIHRoaXMuX2JsdXJGaWx0ZXIucGl4ZWxTaXplID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHBpeGVsU2l6ZSBvZiB0aGUgS2F3YXNlIEJsdXIgZmlsdGVyIG9uIHRoZSBgeGAgYXhpc1xuICAgKiBAZGVmYXVsdCAxXG4gICAqL1xuICBnZXQgcGl4ZWxTaXplWCgpIHtcbiAgICByZXR1cm4gdGhpcy5fYmx1ckZpbHRlci5waXhlbFNpemVYO1xuICB9XG4gIHNldCBwaXhlbFNpemVYKHZhbHVlKSB7XG4gICAgdGhpcy5fYmx1ckZpbHRlci5waXhlbFNpemVYID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHBpeGVsU2l6ZSBvZiB0aGUgS2F3YXNlIEJsdXIgZmlsdGVyIG9uIHRoZSBgeWAgYXhpc1xuICAgKiBAZGVmYXVsdCAxXG4gICAqL1xuICBnZXQgcGl4ZWxTaXplWSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYmx1ckZpbHRlci5waXhlbFNpemVZO1xuICB9XG4gIHNldCBwaXhlbFNpemVZKHZhbHVlKSB7XG4gICAgdGhpcy5fYmx1ckZpbHRlci5waXhlbFNpemVZID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJlY2FsY3VsYXRlIHRoZSBwcm9wZXIgcGFkZGluZyBhbW91bnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdXBkYXRlUGFkZGluZygpIHtcbiAgICBjb25zdCBvZmZzZXRQYWRkaW5nID0gTWF0aC5tYXgoXG4gICAgICBNYXRoLmFicyh0aGlzLm9mZnNldFgpLFxuICAgICAgTWF0aC5hYnModGhpcy5vZmZzZXRZKVxuICAgICk7XG4gICAgdGhpcy5wYWRkaW5nID0gb2Zmc2V0UGFkZGluZyArIHRoaXMuYmx1ciAqIDIgKyB0aGlzLnF1YWxpdHkgKiA0O1xuICB9XG59O1xuLyoqIERlZmF1bHQgdmFsdWVzIGZvciBvcHRpb25zLiAqL1xuX19wdWJsaWNGaWVsZChfRHJvcFNoYWRvd0ZpbHRlciwgXCJERUZBVUxUX09QVElPTlNcIiwge1xuICBvZmZzZXQ6IHsgeDogNCwgeTogNCB9LFxuICBjb2xvcjogMCxcbiAgYWxwaGE6IDAuNSxcbiAgc2hhZG93T25seTogZmFsc2UsXG4gIGtlcm5lbHM6IHZvaWQgMCxcbiAgYmx1cjogMixcbiAgcXVhbGl0eTogMyxcbiAgcGl4ZWxTaXplOiB7IHg6IDEsIHk6IDEgfSxcbiAgcmVzb2x1dGlvbjogMVxufSk7XG5sZXQgRHJvcFNoYWRvd0ZpbHRlciA9IF9Ecm9wU2hhZG93RmlsdGVyO1xuXG5leHBvcnQgeyBEcm9wU2hhZG93RmlsdGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Ecm9wU2hhZG93RmlsdGVyLm1qcy5tYXBcbiIsInZhciBzb3VyY2UgPSBcInN0cnVjdCBEcm9wU2hhZG93VW5pZm9ybXMge1xcbiAgdUFscGhhOiBmMzIsXFxuICB1Q29sb3I6IHZlYzM8ZjMyPixcXG4gIHVPZmZzZXQ6IHZlYzI8ZjMyPixcXG59O1xcblxcbnN0cnVjdCBHbG9iYWxGaWx0ZXJVbmlmb3JtcyB7XFxuICB1SW5wdXRTaXplOnZlYzQ8ZjMyPixcXG4gIHVJbnB1dFBpeGVsOnZlYzQ8ZjMyPixcXG4gIHVJbnB1dENsYW1wOnZlYzQ8ZjMyPixcXG4gIHVPdXRwdXRGcmFtZTp2ZWM0PGYzMj4sXFxuICB1R2xvYmFsRnJhbWU6dmVjNDxmMzI+LFxcbiAgdU91dHB1dFRleHR1cmU6dmVjNDxmMzI+LFxcbn07XFxuXFxuQGdyb3VwKDApIEBiaW5kaW5nKDApIHZhcjx1bmlmb3JtPiBnZnU6IEdsb2JhbEZpbHRlclVuaWZvcm1zO1xcblxcbkBncm91cCgwKSBAYmluZGluZygxKSB2YXIgdVRleHR1cmU6IHRleHR1cmVfMmQ8ZjMyPjsgXFxuQGdyb3VwKDApIEBiaW5kaW5nKDIpIHZhciB1U2FtcGxlcjogc2FtcGxlcjtcXG5AZ3JvdXAoMSkgQGJpbmRpbmcoMCkgdmFyPHVuaWZvcm0+IGRyb3BTaGFkb3dVbmlmb3JtcyA6IERyb3BTaGFkb3dVbmlmb3JtcztcXG5cXG5AZnJhZ21lbnRcXG5mbiBtYWluRnJhZ21lbnQoXFxuICBAYnVpbHRpbihwb3NpdGlvbikgcG9zaXRpb246IHZlYzQ8ZjMyPixcXG4gIEBsb2NhdGlvbigwKSB1diA6IHZlYzI8ZjMyPlxcbikgLT4gQGxvY2F0aW9uKDApIHZlYzQ8ZjMyPiB7XFxuICB2YXIgY29sb3I6IHZlYzQ8ZjMyPiA9IHRleHR1cmVTYW1wbGUodVRleHR1cmUsIHVTYW1wbGVyLCB1diAtIGRyb3BTaGFkb3dVbmlmb3Jtcy51T2Zmc2V0ICogZ2Z1LnVJbnB1dFNpemUuencpO1xcblxcbiAgLy8gUHJlbXVsdGlwbHkgYWxwaGFcXG4gIGNvbG9yID0gdmVjNDxmMzI+KHZlYzM8ZjMyPihkcm9wU2hhZG93VW5pZm9ybXMudUNvbG9yLnJnYiAqIGNvbG9yLmEpLCBjb2xvci5hKTtcXG4gIC8vIGFscGhhIHVzZXIgYWxwaGFcXG4gIGNvbG9yICo9IGRyb3BTaGFkb3dVbmlmb3Jtcy51QWxwaGE7XFxuXFxuICByZXR1cm4gY29sb3I7XFxufVwiO1xuXG5leHBvcnQgeyBzb3VyY2UgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZHJvcC1zaGFkb3cyLm1qcy5tYXBcbiIsInZhciBmcmFnbWVudCA9IFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbmluIHZlYzIgdlRleHR1cmVDb29yZDtcXG5vdXQgdmVjNCBmaW5hbENvbG9yO1xcblxcbnVuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbnVuaWZvcm0gZmxvYXQgdUFscGhhO1xcbnVuaWZvcm0gdmVjMyB1Q29sb3I7XFxudW5pZm9ybSB2ZWMyIHVPZmZzZXQ7XFxuXFxudW5pZm9ybSB2ZWM0IHVJbnB1dFNpemU7XFxuXFxudm9pZCBtYWluKHZvaWQpe1xcbiAgICB2ZWM0IHNhbXBsZSA9IHRleHR1cmUodVRleHR1cmUsIHZUZXh0dXJlQ29vcmQgLSB1T2Zmc2V0ICogdUlucHV0U2l6ZS56dyk7XFxuXFxuICAgIC8vIFByZW11bHRpcGx5IGFscGhhXFxuICAgIHNhbXBsZS5yZ2IgPSB1Q29sb3IucmdiICogc2FtcGxlLmE7XFxuXFxuICAgIC8vIGFscGhhIHVzZXIgYWxwaGFcXG4gICAgc2FtcGxlICo9IHVBbHBoYTtcXG5cXG4gICAgZmluYWxDb2xvciA9IHNhbXBsZTtcXG59XCI7XG5cbmV4cG9ydCB7IGZyYWdtZW50IGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRyb3Atc2hhZG93Lm1qcy5tYXBcbiIsImltcG9ydCB7IEZpbHRlciwgR3B1UHJvZ3JhbSwgR2xQcm9ncmFtIH0gZnJvbSAncGl4aS5qcyc7XG5pbXBvcnQgdmVydGV4IGZyb20gJy4uL2RlZmF1bHRzL2RlZmF1bHQyLm1qcyc7XG5pbXBvcnQgd2dzbFZlcnRleCBmcm9tICcuLi9kZWZhdWx0cy9kZWZhdWx0Lm1qcyc7XG5pbXBvcnQgZnJhZ21lbnQgZnJvbSAnLi9lbWJvc3MubWpzJztcbmltcG9ydCBzb3VyY2UgZnJvbSAnLi9lbWJvc3MyLm1qcyc7XG5cbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbmNsYXNzIEVtYm9zc0ZpbHRlciBleHRlbmRzIEZpbHRlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3N0cmVuZ3RoPTVdIC0gU3RyZW5ndGggb2YgdGhlIGVtYm9zcy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHN0cmVuZ3RoID0gNSkge1xuICAgIGNvbnN0IGdwdVByb2dyYW0gPSBHcHVQcm9ncmFtLmZyb20oe1xuICAgICAgdmVydGV4OiB7XG4gICAgICAgIHNvdXJjZTogd2dzbFZlcnRleCxcbiAgICAgICAgZW50cnlQb2ludDogXCJtYWluVmVydGV4XCJcbiAgICAgIH0sXG4gICAgICBmcmFnbWVudDoge1xuICAgICAgICBzb3VyY2UsXG4gICAgICAgIGVudHJ5UG9pbnQ6IFwibWFpbkZyYWdtZW50XCJcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBnbFByb2dyYW0gPSBHbFByb2dyYW0uZnJvbSh7XG4gICAgICB2ZXJ0ZXgsXG4gICAgICBmcmFnbWVudCxcbiAgICAgIG5hbWU6IFwiZW1ib3NzLWZpbHRlclwiXG4gICAgfSk7XG4gICAgc3VwZXIoe1xuICAgICAgZ3B1UHJvZ3JhbSxcbiAgICAgIGdsUHJvZ3JhbSxcbiAgICAgIHJlc291cmNlczoge1xuICAgICAgICBlbWJvc3NVbmlmb3Jtczoge1xuICAgICAgICAgIHVTdHJlbmd0aDogeyB2YWx1ZTogc3RyZW5ndGgsIHR5cGU6IFwiZjMyXCIgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInVuaWZvcm1zXCIpO1xuICAgIHRoaXMudW5pZm9ybXMgPSB0aGlzLnJlc291cmNlcy5lbWJvc3NVbmlmb3Jtcy51bmlmb3JtcztcbiAgfVxuICAvKipcbiAgICogU3RyZW5ndGggb2YgdGhlIGVtYm9zc1xuICAgKiBAZGVmYXVsdCA1XG4gICAqL1xuICBnZXQgc3RyZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMudVN0cmVuZ3RoO1xuICB9XG4gIHNldCBzdHJlbmd0aCh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMudVN0cmVuZ3RoID0gdmFsdWU7XG4gIH1cbn1cblxuZXhwb3J0IHsgRW1ib3NzRmlsdGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FbWJvc3NGaWx0ZXIubWpzLm1hcFxuIiwiaW1wb3J0IHsgRmlsdGVyLCBHcHVQcm9ncmFtLCBHbFByb2dyYW0sIFRleHR1cmUsIEltYWdlU291cmNlLCBERUdfVE9fUkFEIH0gZnJvbSAncGl4aS5qcyc7XG5pbXBvcnQgdmVydGV4IGZyb20gJy4uL2RlZmF1bHRzL2RlZmF1bHQyLm1qcyc7XG5pbXBvcnQgd2dzbFZlcnRleCBmcm9tICcuLi9kZWZhdWx0cy9kZWZhdWx0Lm1qcyc7XG5pbXBvcnQgZnJhZ21lbnQgZnJvbSAnLi9nbGl0Y2gyLm1qcyc7XG5pbXBvcnQgc291cmNlIGZyb20gJy4vZ2xpdGNoLm1qcyc7XG5cbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbmNvbnN0IF9HbGl0Y2hGaWx0ZXIgPSBjbGFzcyBfR2xpdGNoRmlsdGVyIGV4dGVuZHMgRmlsdGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgdGhlIEdsaXRjaEZpbHRlciBjb25zdHJ1Y3Rvci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0geyAuLi5fR2xpdGNoRmlsdGVyLmRlZmF1bHRzLCAuLi5vcHRpb25zIH07XG4gICAgY29uc3QgZ3B1UHJvZ3JhbSA9IEdwdVByb2dyYW0uZnJvbSh7XG4gICAgICB2ZXJ0ZXg6IHtcbiAgICAgICAgc291cmNlOiB3Z3NsVmVydGV4LFxuICAgICAgICBlbnRyeVBvaW50OiBcIm1haW5WZXJ0ZXhcIlxuICAgICAgfSxcbiAgICAgIGZyYWdtZW50OiB7XG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgZW50cnlQb2ludDogXCJtYWluRnJhZ21lbnRcIlxuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGdsUHJvZ3JhbSA9IEdsUHJvZ3JhbS5mcm9tKHtcbiAgICAgIHZlcnRleCxcbiAgICAgIGZyYWdtZW50LFxuICAgICAgbmFtZTogXCJnbGl0Y2gtZmlsdGVyXCJcbiAgICB9KTtcbiAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIGNhbnZhcy53aWR0aCA9IDQ7XG4gICAgY2FudmFzLmhlaWdodCA9IG9wdGlvbnMuc2FtcGxlU2l6ZSA/PyA1MTI7XG4gICAgY29uc3QgdGV4dHVyZSA9IG5ldyBUZXh0dXJlKHtcbiAgICAgIHNvdXJjZTogbmV3IEltYWdlU291cmNlKHsgcmVzb3VyY2U6IGNhbnZhcyB9KVxuICAgIH0pO1xuICAgIHN1cGVyKHtcbiAgICAgIGdwdVByb2dyYW0sXG4gICAgICBnbFByb2dyYW0sXG4gICAgICByZXNvdXJjZXM6IHtcbiAgICAgICAgZ2xpdGNoVW5pZm9ybXM6IHtcbiAgICAgICAgICB1U2VlZDogeyB2YWx1ZTogb3B0aW9ucz8uc2VlZCA/PyAwLCB0eXBlOiBcImYzMlwiIH0sXG4gICAgICAgICAgdURpbWVuc2lvbnM6IHsgdmFsdWU6IG5ldyBGbG9hdDMyQXJyYXkoMiksIHR5cGU6IFwidmVjMjxmMzI+XCIgfSxcbiAgICAgICAgICB1QXNwZWN0OiB7IHZhbHVlOiAxLCB0eXBlOiBcImYzMlwiIH0sXG4gICAgICAgICAgdUZpbGxNb2RlOiB7IHZhbHVlOiBvcHRpb25zPy5maWxsTW9kZSA/PyAwLCB0eXBlOiBcImYzMlwiIH0sXG4gICAgICAgICAgdU9mZnNldDogeyB2YWx1ZTogb3B0aW9ucz8ub2Zmc2V0ID8/IDEwMCwgdHlwZTogXCJmMzJcIiB9LFxuICAgICAgICAgIHVEaXJlY3Rpb246IHsgdmFsdWU6IG9wdGlvbnM/LmRpcmVjdGlvbiA/PyAwLCB0eXBlOiBcImYzMlwiIH0sXG4gICAgICAgICAgdVJlZDogeyB2YWx1ZTogb3B0aW9ucy5yZWQsIHR5cGU6IFwidmVjMjxmMzI+XCIgfSxcbiAgICAgICAgICB1R3JlZW46IHsgdmFsdWU6IG9wdGlvbnMuZ3JlZW4sIHR5cGU6IFwidmVjMjxmMzI+XCIgfSxcbiAgICAgICAgICB1Qmx1ZTogeyB2YWx1ZTogb3B0aW9ucy5ibHVlLCB0eXBlOiBcInZlYzI8ZjMyPlwiIH1cbiAgICAgICAgfSxcbiAgICAgICAgdURpc3BsYWNlbWVudE1hcDogdGV4dHVyZS5zb3VyY2UsXG4gICAgICAgIHVEaXNwbGFjZW1lbnRTYW1wbGVyOiB0ZXh0dXJlLnNvdXJjZS5zdHlsZVxuICAgICAgfVxuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ1bmlmb3Jtc1wiKTtcbiAgICAvKipcbiAgICAgKiBgdHJ1ZWAgd2lsbCBkaXZpZGUgdGhlIGJhbmRzIHJvdWdobHkgYmFzZWQgb24gZXF1YWwgYW1vdW50c1xuICAgICAqIHdoZXJlIGFzIHNldHRpbmcgdG8gYGZhbHNlYCB3aWxsIHZhcnkgdGhlIGJhbmQgc2l6ZXMgZHJhbWF0aWNhbGx5IChtb3JlIHJhbmRvbSBsb29raW5nKS5cbiAgICAgKi9cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiYXZlcmFnZVwiLCBmYWxzZSk7XG4gICAgLyoqIE1pbmltdW0gc2l6ZSBvZiBzbGljZXMgYXMgYSBwb3J0aW9uIG9mIHRoZSBgc2FtcGxlU2l6ZWAgKi9cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibWluU2l6ZVwiLCA4KTtcbiAgICAvKiogSGVpZ2h0IG9mIHRoZSBkaXNwbGFjZW1lbnQgbWFwIGNhbnZhcy4gKi9cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic2FtcGxlU2l6ZVwiLCA1MTIpO1xuICAgIC8qKiBJbnRlcm5hbGx5IGdlbmVyYXRlZCBjYW52YXMuICovXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9jYW52YXNcIik7XG4gICAgLyoqXG4gICAgICogVGhlIGRpc3BsYWNlbWVudCBtYXAgaXMgdXNlZCB0byBnZW5lcmF0ZSB0aGUgYmFuZHMuXG4gICAgICogSWYgdXNpbmcgeW91ciBvd24gdGV4dHVyZSwgYHNsaWNlc2Agd2lsbCBiZSBpZ25vcmVkLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7VGV4dHVyZX1cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidGV4dHVyZVwiKTtcbiAgICAvKiogSW50ZXJuYWwgbnVtYmVyIG9mIHNsaWNlcyAqL1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfc2xpY2VzXCIsIDApO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfc2l6ZXNcIiwgbmV3IEZsb2F0MzJBcnJheSgxKSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9vZmZzZXRzXCIsIG5ldyBGbG9hdDMyQXJyYXkoMSkpO1xuICAgIHRoaXMudW5pZm9ybXMgPSB0aGlzLnJlc291cmNlcy5nbGl0Y2hVbmlmb3Jtcy51bmlmb3JtcztcbiAgICB0aGlzLl9jYW52YXMgPSBjYW52YXM7XG4gICAgdGhpcy50ZXh0dXJlID0gdGV4dHVyZTtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBPdmVycmlkZSBleGlzdGluZyBhcHBseSBtZXRob2QgaW4gRmlsdGVyXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhcHBseShmaWx0ZXJNYW5hZ2VyLCBpbnB1dCwgb3V0cHV0LCBjbGVhck1vZGUpIHtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGlucHV0LmZyYW1lO1xuICAgIHRoaXMudW5pZm9ybXMudURpbWVuc2lvbnNbMF0gPSB3aWR0aDtcbiAgICB0aGlzLnVuaWZvcm1zLnVEaW1lbnNpb25zWzFdID0gaGVpZ2h0O1xuICAgIHRoaXMudW5pZm9ybXMudUFzcGVjdCA9IGhlaWdodCAvIHdpZHRoO1xuICAgIGZpbHRlck1hbmFnZXIuYXBwbHlGaWx0ZXIodGhpcywgaW5wdXQsIG91dHB1dCwgY2xlYXJNb2RlKTtcbiAgfVxuICAvKipcbiAgICogUmFuZG9taXplIHRoZSBzbGljZXMgc2l6ZSAoaGVpZ2h0cykuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmFuZG9taXplU2l6ZXMoKSB7XG4gICAgY29uc3QgYXJyID0gdGhpcy5fc2l6ZXM7XG4gICAgY29uc3QgbGFzdCA9IHRoaXMuX3NsaWNlcyAtIDE7XG4gICAgY29uc3Qgc2l6ZSA9IHRoaXMuc2FtcGxlU2l6ZTtcbiAgICBjb25zdCBtaW4gPSBNYXRoLm1pbih0aGlzLm1pblNpemUgLyBzaXplLCAwLjkgLyB0aGlzLl9zbGljZXMpO1xuICAgIGlmICh0aGlzLmF2ZXJhZ2UpIHtcbiAgICAgIGNvbnN0IGNvdW50ID0gdGhpcy5fc2xpY2VzO1xuICAgICAgbGV0IHJlc3QgPSAxO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsYXN0OyBpKyspIHtcbiAgICAgICAgY29uc3QgYXZlcmFnZVdpZHRoID0gcmVzdCAvIChjb3VudCAtIGkpO1xuICAgICAgICBjb25zdCB3ID0gTWF0aC5tYXgoYXZlcmFnZVdpZHRoICogKDEgLSBNYXRoLnJhbmRvbSgpICogMC42KSwgbWluKTtcbiAgICAgICAgYXJyW2ldID0gdztcbiAgICAgICAgcmVzdCAtPSB3O1xuICAgICAgfVxuICAgICAgYXJyW2xhc3RdID0gcmVzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHJlc3QgPSAxO1xuICAgICAgY29uc3QgcmF0aW8gPSBNYXRoLnNxcnQoMSAvIHRoaXMuX3NsaWNlcyk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxhc3Q7IGkrKykge1xuICAgICAgICBjb25zdCB3ID0gTWF0aC5tYXgocmF0aW8gKiByZXN0ICogTWF0aC5yYW5kb20oKSwgbWluKTtcbiAgICAgICAgYXJyW2ldID0gdztcbiAgICAgICAgcmVzdCAtPSB3O1xuICAgICAgfVxuICAgICAgYXJyW2xhc3RdID0gcmVzdDtcbiAgICB9XG4gICAgdGhpcy5zaHVmZmxlKCk7XG4gIH1cbiAgLyoqXG4gICAqIFNodWZmbGUgdGhlIHNpemVzIG9mIHRoZSBzbGljZXMsIGFkdmFuY2VkIHVzYWdlLlxuICAgKi9cbiAgc2h1ZmZsZSgpIHtcbiAgICBjb25zdCBhcnIgPSB0aGlzLl9zaXplcztcbiAgICBjb25zdCBsYXN0ID0gdGhpcy5fc2xpY2VzIC0gMTtcbiAgICBmb3IgKGxldCBpID0gbGFzdDsgaSA+IDA7IGktLSkge1xuICAgICAgY29uc3QgcmFuZCA9IE1hdGgucmFuZG9tKCkgKiBpID4+IDA7XG4gICAgICBjb25zdCB0ZW1wID0gYXJyW2ldO1xuICAgICAgYXJyW2ldID0gYXJyW3JhbmRdO1xuICAgICAgYXJyW3JhbmRdID0gdGVtcDtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJhbmRvbWl6ZSB0aGUgdmFsdWVzIGZvciBvZmZzZXQgZnJvbSAtMSB0byAxXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmFuZG9taXplT2Zmc2V0cygpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3NsaWNlczsgaSsrKSB7XG4gICAgICB0aGlzLl9vZmZzZXRzW2ldID0gTWF0aC5yYW5kb20oKSAqIChNYXRoLnJhbmRvbSgpIDwgMC41ID8gLTEgOiAxKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlZ2VuZXJhdGluZyByYW5kb20gc2l6ZSwgb2Zmc2V0cyBmb3Igc2xpY2VzLlxuICAgKi9cbiAgcmVmcmVzaCgpIHtcbiAgICB0aGlzLl9yYW5kb21pemVTaXplcygpO1xuICAgIHRoaXMuX3JhbmRvbWl6ZU9mZnNldHMoKTtcbiAgICB0aGlzLnJlZHJhdygpO1xuICB9XG4gIC8qKlxuICAgKiBSZWRyYXcgZGlzcGxhY2VtZW50IGJpdG1hcCB0ZXh0dXJlLCBhZHZhbmNlZCB1c2FnZS5cbiAgICovXG4gIHJlZHJhdygpIHtcbiAgICBjb25zdCBzaXplID0gdGhpcy5zYW1wbGVTaXplO1xuICAgIGNvbnN0IHRleHR1cmUgPSB0aGlzLnRleHR1cmU7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5fY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICBjdHguY2xlYXJSZWN0KDAsIDAsIDgsIHNpemUpO1xuICAgIGxldCBvZmZzZXQ7XG4gICAgbGV0IHkgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fc2xpY2VzOyBpKyspIHtcbiAgICAgIG9mZnNldCA9IE1hdGguZmxvb3IodGhpcy5fb2Zmc2V0c1tpXSAqIDI1Nik7XG4gICAgICBjb25zdCBoZWlnaHQgPSB0aGlzLl9zaXplc1tpXSAqIHNpemU7XG4gICAgICBjb25zdCByZWQgPSBvZmZzZXQgPiAwID8gb2Zmc2V0IDogMDtcbiAgICAgIGNvbnN0IGdyZWVuID0gb2Zmc2V0IDwgMCA/IC1vZmZzZXQgOiAwO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGByZ2JhKCR7cmVkfSwgJHtncmVlbn0sIDAsIDEpYDtcbiAgICAgIGN0eC5maWxsUmVjdCgwLCB5ID4+IDAsIHNpemUsIGhlaWdodCArIDEgPj4gMCk7XG4gICAgICB5ICs9IGhlaWdodDtcbiAgICB9XG4gICAgdGV4dHVyZS5zb3VyY2UudXBkYXRlKCk7XG4gIH1cbiAgLyoqXG4gICAqIE1hbnVhbGx5IGN1c3RvbSBzbGljZXMgc2l6ZSAoaGVpZ2h0KSBvZiBkaXNwbGFjZW1lbnQgYml0bWFwXG4gICAqXG4gICAqIEBtZW1iZXIge251bWJlcltdfEZsb2F0MzJBcnJheX1cbiAgICovXG4gIHNldCBzaXplcyhzaXplcykge1xuICAgIGNvbnN0IGxlbiA9IE1hdGgubWluKHRoaXMuX3NsaWNlcywgc2l6ZXMubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB0aGlzLl9zaXplc1tpXSA9IHNpemVzW2ldO1xuICAgIH1cbiAgfVxuICBnZXQgc2l6ZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NpemVzO1xuICB9XG4gIC8qKlxuICAgKiBNYW51YWxseSBzZXQgY3VzdG9tIHNsaWNlcyBvZmZzZXQgb2YgZGlzcGxhY2VtZW50IGJpdG1hcCwgdGhpcyBpc1xuICAgKiBhIGNvbGxlY3Rpb24gb2YgdmFsdWVzIGZyb20gLTEgdG8gMS4gVG8gY2hhbmdlIHRoZSBtYXggb2Zmc2V0IHZhbHVlXG4gICAqIHNldCBgb2Zmc2V0YC5cbiAgICpcbiAgICogQG1lbWJlciB7bnVtYmVyW118RmxvYXQzMkFycmF5fVxuICAgKi9cbiAgc2V0IG9mZnNldHMob2Zmc2V0cykge1xuICAgIGNvbnN0IGxlbiA9IE1hdGgubWluKHRoaXMuX3NsaWNlcywgb2Zmc2V0cy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHRoaXMuX29mZnNldHNbaV0gPSBvZmZzZXRzW2ldO1xuICAgIH1cbiAgfVxuICBnZXQgb2Zmc2V0cygpIHtcbiAgICByZXR1cm4gdGhpcy5fb2Zmc2V0cztcbiAgfVxuICAvKipcbiAgICogVGhlIGNvdW50IG9mIHNsaWNlcy5cbiAgICogQGRlZmF1bHQgNVxuICAgKi9cbiAgZ2V0IHNsaWNlcygpIHtcbiAgICByZXR1cm4gdGhpcy5fc2xpY2VzO1xuICB9XG4gIHNldCBzbGljZXModmFsdWUpIHtcbiAgICBpZiAodGhpcy5fc2xpY2VzID09PSB2YWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9zbGljZXMgPSB2YWx1ZTtcbiAgICB0aGlzLl9zaXplcyA9IG5ldyBGbG9hdDMyQXJyYXkodmFsdWUpO1xuICAgIHRoaXMuX29mZnNldHMgPSBuZXcgRmxvYXQzMkFycmF5KHZhbHVlKTtcbiAgICB0aGlzLnJlZnJlc2goKTtcbiAgfVxuICAvKipcbiAgICogVGhlIG1heGltdW0gb2Zmc2V0IGFtb3VudCBvZiBzbGljZXMuXG4gICAqIEBkZWZhdWx0IDEwMFxuICAgKi9cbiAgZ2V0IG9mZnNldCgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy51T2Zmc2V0O1xuICB9XG4gIHNldCBvZmZzZXQodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnVPZmZzZXQgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogQSBzZWVkIHZhbHVlIGZvciByYW5kb21pemluZyBnbGl0Y2ggZWZmZWN0LlxuICAgKiBAZGVmYXVsdCAwXG4gICAqL1xuICBnZXQgc2VlZCgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy51U2VlZDtcbiAgfVxuICBzZXQgc2VlZCh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMudVNlZWQgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGZpbGwgbW9kZSBvZiB0aGUgc3BhY2UgYWZ0ZXIgdGhlIG9mZnNldC5cbiAgICogQGRlZmF1bHQgRklMTF9NT0RFUy5UUkFOU1BBUkVOVFxuICAgKi9cbiAgZ2V0IGZpbGxNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnVGaWxsTW9kZTtcbiAgfVxuICBzZXQgZmlsbE1vZGUodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnVGaWxsTW9kZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYW5nbGUgaW4gZGVncmVlIG9mIHRoZSBvZmZzZXQgb2Ygc2xpY2VzLlxuICAgKiBAZGVmYXVsdCAwXG4gICAqL1xuICBnZXQgZGlyZWN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnVEaXJlY3Rpb24gLyBERUdfVE9fUkFEO1xuICB9XG4gIHNldCBkaXJlY3Rpb24odmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnVEaXJlY3Rpb24gPSB2YWx1ZSAqIERFR19UT19SQUQ7XG4gIH1cbiAgLyoqXG4gICAqIFJlZCBjaGFubmVsIG9mZnNldC5cbiAgICogQGRlZmF1bHQge3g6MCx5OjB9XG4gICAqL1xuICBnZXQgcmVkKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnVSZWQ7XG4gIH1cbiAgc2V0IHJlZCh2YWx1ZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgdmFsdWUgPSB7IHg6IHZhbHVlWzBdLCB5OiB2YWx1ZVsxXSB9O1xuICAgIH1cbiAgICB0aGlzLnVuaWZvcm1zLnVSZWQgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogR3JlZW4gY2hhbm5lbCBvZmZzZXQuXG4gICAqIEBkZWZhdWx0IHt4OjAseTowfVxuICAgKi9cbiAgZ2V0IGdyZWVuKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnVHcmVlbjtcbiAgfVxuICBzZXQgZ3JlZW4odmFsdWUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHZhbHVlID0geyB4OiB2YWx1ZVswXSwgeTogdmFsdWVbMV0gfTtcbiAgICB9XG4gICAgdGhpcy51bmlmb3Jtcy51R3JlZW4gPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogQmx1ZSBvZmZzZXQuXG4gICAqIEBkZWZhdWx0IHt4OjAseTowfVxuICAgKi9cbiAgZ2V0IGJsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMudUJsdWU7XG4gIH1cbiAgc2V0IGJsdWUodmFsdWUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHZhbHVlID0geyB4OiB2YWx1ZVswXSwgeTogdmFsdWVbMV0gfTtcbiAgICB9XG4gICAgdGhpcy51bmlmb3Jtcy51Qmx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIGFsbCByZWZlcmVuY2VzXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMudGV4dHVyZT8uZGVzdHJveSh0cnVlKTtcbiAgICB0aGlzLnRleHR1cmUgPSB0aGlzLl9jYW52YXMgPSB0aGlzLnJlZCA9IHRoaXMuZ3JlZW4gPSB0aGlzLmJsdWUgPSB0aGlzLl9zaXplcyA9IHRoaXMuX29mZnNldHMgPSBudWxsO1xuICB9XG59O1xuLyoqIERlZmF1bHQgY29uc3RydWN0b3Igb3B0aW9ucy4gKi9cbl9fcHVibGljRmllbGQoX0dsaXRjaEZpbHRlciwgXCJkZWZhdWx0c1wiLCB7XG4gIHNsaWNlczogNSxcbiAgb2Zmc2V0OiAxMDAsXG4gIGRpcmVjdGlvbjogMCxcbiAgZmlsbE1vZGU6IDAsXG4gIGF2ZXJhZ2U6IGZhbHNlLFxuICBzZWVkOiAwLFxuICByZWQ6IHsgeDogMCwgeTogMCB9LFxuICBncmVlbjogeyB4OiAwLCB5OiAwIH0sXG4gIGJsdWU6IHsgeDogMCwgeTogMCB9LFxuICBtaW5TaXplOiA4LFxuICBzYW1wbGVTaXplOiA1MTJcbn0pO1xubGV0IEdsaXRjaEZpbHRlciA9IF9HbGl0Y2hGaWx0ZXI7XG5cbmV4cG9ydCB7IEdsaXRjaEZpbHRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R2xpdGNoRmlsdGVyLm1qcy5tYXBcbiIsInZhciBzb3VyY2UgPSBcInN0cnVjdCBHbGl0Y2hVbmlmb3JtcyB7XFxuICB1U2VlZDogZjMyLFxcbiAgdURpbWVuc2lvbnM6IHZlYzI8ZjMyPixcXG4gIHVBc3BlY3Q6IGYzMixcXG4gIHVGaWxsTW9kZTogZjMyLFxcbiAgdU9mZnNldDogZjMyLFxcbiAgdURpcmVjdGlvbjogZjMyLFxcbiAgdVJlZDogdmVjMjxmMzI+LFxcbiAgdUdyZWVuOiB2ZWMyPGYzMj4sXFxuICB1Qmx1ZTogdmVjMjxmMzI+LFxcbn07XFxuXFxuc3RydWN0IEdsb2JhbEZpbHRlclVuaWZvcm1zIHtcXG4gIHVJbnB1dFNpemU6dmVjNDxmMzI+LFxcbiAgdUlucHV0UGl4ZWw6dmVjNDxmMzI+LFxcbiAgdUlucHV0Q2xhbXA6dmVjNDxmMzI+LFxcbiAgdU91dHB1dEZyYW1lOnZlYzQ8ZjMyPixcXG4gIHVHbG9iYWxGcmFtZTp2ZWM0PGYzMj4sXFxuICB1T3V0cHV0VGV4dHVyZTp2ZWM0PGYzMj4sXFxufTtcXG5cXG5AZ3JvdXAoMCkgQGJpbmRpbmcoMCkgdmFyPHVuaWZvcm0+IGdmdTogR2xvYmFsRmlsdGVyVW5pZm9ybXM7XFxuXFxuQGdyb3VwKDApIEBiaW5kaW5nKDEpIHZhciB1VGV4dHVyZTogdGV4dHVyZV8yZDxmMzI+OyBcXG5AZ3JvdXAoMCkgQGJpbmRpbmcoMikgdmFyIHVTYW1wbGVyOiBzYW1wbGVyO1xcbkBncm91cCgxKSBAYmluZGluZygwKSB2YXI8dW5pZm9ybT4gZ2xpdGNoVW5pZm9ybXMgOiBHbGl0Y2hVbmlmb3JtcztcXG5AZ3JvdXAoMSkgQGJpbmRpbmcoMSkgdmFyIHVEaXNwbGFjZW1lbnRNYXA6IHRleHR1cmVfMmQ8ZjMyPjsgXFxuQGdyb3VwKDEpIEBiaW5kaW5nKDIpIHZhciB1RGlzcGxhY2VtZW50U2FtcGxlcjogc2FtcGxlcjsgXFxuXFxuQGZyYWdtZW50XFxuZm4gbWFpbkZyYWdtZW50KFxcbiAgQGJ1aWx0aW4ocG9zaXRpb24pIHBvc2l0aW9uOiB2ZWM0PGYzMj4sXFxuICBAbG9jYXRpb24oMCkgdXYgOiB2ZWMyPGYzMj5cXG4pIC0+IEBsb2NhdGlvbigwKSB2ZWM0PGYzMj4ge1xcbiAgbGV0IHVTZWVkOiBmMzIgPSBnbGl0Y2hVbmlmb3Jtcy51U2VlZDtcXG4gIGxldCB1RGltZW5zaW9uczogdmVjMjxmMzI+ID0gZ2xpdGNoVW5pZm9ybXMudURpbWVuc2lvbnM7XFxuICBsZXQgdUFzcGVjdDogZjMyID0gZ2xpdGNoVW5pZm9ybXMudUFzcGVjdDtcXG4gIGxldCB1T2Zmc2V0OiBmMzIgPSBnbGl0Y2hVbmlmb3Jtcy51T2Zmc2V0O1xcbiAgbGV0IHVEaXJlY3Rpb246IGYzMiA9IGdsaXRjaFVuaWZvcm1zLnVEaXJlY3Rpb247XFxuICBsZXQgdVJlZDogdmVjMjxmMzI+ID0gZ2xpdGNoVW5pZm9ybXMudVJlZDtcXG4gIGxldCB1R3JlZW46IHZlYzI8ZjMyPiA9IGdsaXRjaFVuaWZvcm1zLnVHcmVlbjtcXG4gIGxldCB1Qmx1ZTogdmVjMjxmMzI+ID0gZ2xpdGNoVW5pZm9ybXMudUJsdWU7XFxuXFxuICBsZXQgdUlucHV0U2l6ZTogdmVjNDxmMzI+ID0gZ2Z1LnVJbnB1dFNpemU7XFxuICBsZXQgdUlucHV0Q2xhbXA6IHZlYzQ8ZjMyPiA9IGdmdS51SW5wdXRDbGFtcDtcXG5cXG4gIHZhciBkaXNjYXJkZWQ6IGJvb2wgPSBmYWxzZTtcXG4gIHZhciBjb29yZDogdmVjMjxmMzI+ID0gKHV2ICogdUlucHV0U2l6ZS54eSkgLyB1RGltZW5zaW9ucztcXG5cXG4gICAgaWYgKGNvb3JkLnggPiAxLjAgfHwgY29vcmQueSA+IDEuMCkge1xcbiAgICAgIGRpc2NhcmRlZCA9IHRydWU7XFxuICAgIH1cXG5cXG4gICAgbGV0IHNpbkRpcjogZjMyID0gc2luKHVEaXJlY3Rpb24pO1xcbiAgICBsZXQgY29zRGlyOiBmMzIgPSBjb3ModURpcmVjdGlvbik7XFxuXFxuICAgIGxldCBjeDogZjMyID0gY29vcmQueCAtIDAuNTtcXG4gICAgbGV0IGN5OiBmMzIgPSAoY29vcmQueSAtIDAuNSkgKiB1QXNwZWN0O1xcbiAgICB2YXIgbnk6IGYzMiA9ICgtc2luRGlyICogY3ggKyBjb3NEaXIgKiBjeSkgLyB1QXNwZWN0ICsgMC41O1xcblxcbiAgICBueSA9IHNlbGVjdChzZWxlY3QobnksIC1ueSwgbnkgPCAwLjApLCAyLjAgLSBueSwgbnkgPiAxLjApO1xcblxcbiAgICBsZXQgZGM6IHZlYzQ8ZjMyPiA9IHRleHR1cmVTYW1wbGUodURpc3BsYWNlbWVudE1hcCwgdURpc3BsYWNlbWVudFNhbXBsZXIsIHZlYzI8ZjMyPigwLjUsIG55KSk7XFxuXFxuICAgIGxldCBkaXNwbGFjZW1lbnQ6IGYzMiA9IChkYy5yIC0gZGMuZykgKiAodU9mZnNldCAvIHVJbnB1dFNpemUueCk7XFxuXFxuICAgIGNvb3JkID0gdXYgKyB2ZWMyPGYzMj4oY29zRGlyICogZGlzcGxhY2VtZW50LCBzaW5EaXIgKiBkaXNwbGFjZW1lbnQgKiB1QXNwZWN0KTtcXG5cXG4gICAgbGV0IGZpbGxNb2RlOiBpMzIgPSBpMzIoZ2xpdGNoVW5pZm9ybXMudUZpbGxNb2RlKTtcXG5cXG4gICAgaWYgKGZpbGxNb2RlID09IENMQU1QKSB7XFxuICAgICAgY29vcmQgPSBjbGFtcChjb29yZCwgdUlucHV0Q2xhbXAueHksIHVJbnB1dENsYW1wLnp3KTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBpZiAoY29vcmQueCA+IHVJbnB1dENsYW1wLnopIHtcXG4gICAgICAgIGlmIChmaWxsTW9kZSA9PSBUUkFOU1BBUkVOVCkge1xcbiAgICAgICAgICBkaXNjYXJkZWQgPSB0cnVlO1xcbiAgICAgICAgfSBlbHNlIGlmIChmaWxsTW9kZSA9PSBMT09QKSB7XFxuICAgICAgICAgIGNvb3JkLnggPSBjb29yZC54IC0gdUlucHV0Q2xhbXAuejtcXG4gICAgICAgIH0gZWxzZSBpZiAoZmlsbE1vZGUgPT0gTUlSUk9SKSB7XFxuICAgICAgICAgIGNvb3JkLnggPSB1SW5wdXRDbGFtcC56ICogMi4wIC0gY29vcmQueDtcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2UgaWYgKGNvb3JkLnggPCB1SW5wdXRDbGFtcC54KSB7XFxuICAgICAgICBpZiAoZmlsbE1vZGUgPT0gVFJBTlNQQVJFTlQpIHtcXG4gICAgICAgICAgZGlzY2FyZGVkID0gdHJ1ZTtcXG4gICAgICAgIH0gZWxzZSBpZiAoZmlsbE1vZGUgPT0gTE9PUCkge1xcbiAgICAgICAgICBjb29yZC54ID0gY29vcmQueCArIHVJbnB1dENsYW1wLno7XFxuICAgICAgICB9IGVsc2UgaWYgKGZpbGxNb2RlID09IE1JUlJPUikge1xcbiAgICAgICAgICBjb29yZC54ID0gY29vcmQueCAqIC11SW5wdXRDbGFtcC56O1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoY29vcmQueSA+IHVJbnB1dENsYW1wLncpIHtcXG4gICAgICAgIGlmIChmaWxsTW9kZSA9PSBUUkFOU1BBUkVOVCkge1xcbiAgICAgICAgICBkaXNjYXJkZWQgPSB0cnVlO1xcbiAgICAgICAgfSBlbHNlIGlmIChmaWxsTW9kZSA9PSBMT09QKSB7XFxuICAgICAgICAgIGNvb3JkLnkgPSBjb29yZC55IC0gdUlucHV0Q2xhbXAudztcXG4gICAgICAgIH0gZWxzZSBpZiAoZmlsbE1vZGUgPT0gTUlSUk9SKSB7XFxuICAgICAgICAgIGNvb3JkLnkgPSB1SW5wdXRDbGFtcC53ICogMi4wIC0gY29vcmQueTtcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2UgaWYgKGNvb3JkLnkgPCB1SW5wdXRDbGFtcC55KSB7XFxuICAgICAgICBpZiAoZmlsbE1vZGUgPT0gVFJBTlNQQVJFTlQpIHtcXG4gICAgICAgICAgZGlzY2FyZGVkID0gdHJ1ZTtcXG4gICAgICAgIH0gZWxzZSBpZiAoZmlsbE1vZGUgPT0gTE9PUCkge1xcbiAgICAgICAgICBjb29yZC55ID0gY29vcmQueSArIHVJbnB1dENsYW1wLnc7XFxuICAgICAgICB9IGVsc2UgaWYgKGZpbGxNb2RlID09IE1JUlJPUikge1xcbiAgICAgICAgICBjb29yZC55ID0gY29vcmQueSAqIC11SW5wdXRDbGFtcC53O1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBsZXQgc2VlZFI6IGYzMiA9IDEuMCAtIHVTZWVkICogMC40O1xcbiAgICBsZXQgc2VlZEc6IGYzMiA9IDEuMCAtIHVTZWVkICogMC4zO1xcbiAgICBsZXQgc2VlZEI6IGYzMiA9IDEuMCAtIHVTZWVkICogMC4yO1xcblxcbiAgICBsZXQgb2Zmc2V0UjogdmVjMjxmMzI+ID0gdmVjMih1UmVkLnggKiBzZWVkUiAvIHVJbnB1dFNpemUueCwgdVJlZC55ICogc2VlZFIgLyB1SW5wdXRTaXplLnkpO1xcbiAgICBsZXQgb2Zmc2V0RzogdmVjMjxmMzI+ID0gdmVjMih1R3JlZW4ueCAqIHNlZWRHIC8gdUlucHV0U2l6ZS54LCB1R3JlZW4ueSAqIHNlZWRHIC8gdUlucHV0U2l6ZS55KTtcXG4gICAgbGV0IG9mZnNldEI6IHZlYzI8ZjMyPiA9IHZlYzIodUJsdWUueCAqIHNlZWRCIC8gdUlucHV0U2l6ZS54LCB1Qmx1ZS55ICogc2VlZEIgLyB1SW5wdXRTaXplLnkpO1xcblxcbiAgICBsZXQgciA9IHRleHR1cmVTYW1wbGUodVRleHR1cmUsIHVTYW1wbGVyLCBjb29yZCArIG9mZnNldFIpLnI7XFxuICAgIGxldCBnID0gdGV4dHVyZVNhbXBsZSh1VGV4dHVyZSwgdVNhbXBsZXIsIGNvb3JkICsgb2Zmc2V0RykuZztcXG4gICAgbGV0IGIgPSB0ZXh0dXJlU2FtcGxlKHVUZXh0dXJlLCB1U2FtcGxlciwgY29vcmQgKyBvZmZzZXRCKS5iO1xcbiAgICBsZXQgYSA9IHRleHR1cmVTYW1wbGUodVRleHR1cmUsIHVTYW1wbGVyLCBjb29yZCkuYTtcXG5cXG4gICAgcmV0dXJuIHNlbGVjdCh2ZWM0PGYzMj4ociwgZywgYiwgYSksIHZlYzQ8ZjMyPigwLjAsMC4wLDAuMCwwLjApLCBkaXNjYXJkZWQpO1xcbn1cXG5cXG5jb25zdCBUUkFOU1BBUkVOVDogaTMyID0gMDtcXG5jb25zdCBPUklHSU5BTDogaTMyID0gMTtcXG5jb25zdCBMT09QOiBpMzIgPSAyO1xcbmNvbnN0IENMQU1QOiBpMzIgPSAzO1xcbmNvbnN0IE1JUlJPUjogaTMyID0gNDtcIjtcblxuZXhwb3J0IHsgc291cmNlIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdsaXRjaC5tanMubWFwXG4iLCJ2YXIgZnJhZ21lbnQgPSBcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5pbiB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxub3V0IHZlYzQgZmluYWxDb2xvcjtcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG51bmlmb3JtIHNhbXBsZXIyRCB1RGlzcGxhY2VtZW50TWFwO1xcbnVuaWZvcm0gZmxvYXQgdVNlZWQ7XFxudW5pZm9ybSB2ZWMyIHVEaW1lbnNpb25zO1xcbnVuaWZvcm0gZmxvYXQgdUFzcGVjdDtcXG51bmlmb3JtIGZsb2F0IHVGaWxsTW9kZTtcXG51bmlmb3JtIGZsb2F0IHVPZmZzZXQ7XFxudW5pZm9ybSBmbG9hdCB1RGlyZWN0aW9uO1xcbnVuaWZvcm0gdmVjMiB1UmVkO1xcbnVuaWZvcm0gdmVjMiB1R3JlZW47XFxudW5pZm9ybSB2ZWMyIHVCbHVlO1xcblxcbnVuaWZvcm0gdmVjNCB1SW5wdXRTaXplO1xcbnVuaWZvcm0gdmVjNCB1SW5wdXRDbGFtcDtcXG5cXG5jb25zdCBpbnQgVFJBTlNQQVJFTlQgPSAwO1xcbmNvbnN0IGludCBPUklHSU5BTCA9IDE7XFxuY29uc3QgaW50IExPT1AgPSAyO1xcbmNvbnN0IGludCBDTEFNUCA9IDM7XFxuY29uc3QgaW50IE1JUlJPUiA9IDQ7XFxuXFxudm9pZCBtYWluKHZvaWQpXFxue1xcbiAgICB2ZWMyIGNvb3JkID0gKHZUZXh0dXJlQ29vcmQgKiB1SW5wdXRTaXplLnh5KSAvIHVEaW1lbnNpb25zO1xcblxcbiAgICBpZiAoY29vcmQueCA+IDEuMCB8fCBjb29yZC55ID4gMS4wKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgZmxvYXQgc2luRGlyID0gc2luKHVEaXJlY3Rpb24pO1xcbiAgICBmbG9hdCBjb3NEaXIgPSBjb3ModURpcmVjdGlvbik7XFxuXFxuICAgIGZsb2F0IGN4ID0gY29vcmQueCAtIDAuNTtcXG4gICAgZmxvYXQgY3kgPSAoY29vcmQueSAtIDAuNSkgKiB1QXNwZWN0O1xcbiAgICBmbG9hdCBueSA9ICgtc2luRGlyICogY3ggKyBjb3NEaXIgKiBjeSkgLyB1QXNwZWN0ICsgMC41O1xcblxcbiAgICAvLyBkaXNwbGFjZW1lbnRNYXA6IHJlcGVhdFxcbiAgICAvLyBueSA9IG55ID4gMS4wID8gbnkgLSAxLjAgOiAobnkgPCAwLjAgPyAxLjAgKyBueSA6IG55KTtcXG5cXG4gICAgLy8gZGlzcGxhY2VtZW50TWFwOiBtaXJyb3JcXG4gICAgbnkgPSBueSA+IDEuMCA/IDIuMCAtIG55IDogKG55IDwgMC4wID8gLW55IDogbnkpO1xcblxcbiAgICB2ZWM0IGRjID0gdGV4dHVyZSh1RGlzcGxhY2VtZW50TWFwLCB2ZWMyKDAuNSwgbnkpKTtcXG5cXG4gICAgZmxvYXQgZGlzcGxhY2VtZW50ID0gKGRjLnIgLSBkYy5nKSAqICh1T2Zmc2V0IC8gdUlucHV0U2l6ZS54KTtcXG5cXG4gICAgY29vcmQgPSB2VGV4dHVyZUNvb3JkICsgdmVjMihjb3NEaXIgKiBkaXNwbGFjZW1lbnQsIHNpbkRpciAqIGRpc3BsYWNlbWVudCAqIHVBc3BlY3QpO1xcblxcbiAgICBpbnQgZmlsbE1vZGUgPSBpbnQodUZpbGxNb2RlKTtcXG5cXG4gICAgaWYgKGZpbGxNb2RlID09IENMQU1QKSB7XFxuICAgICAgICBjb29yZCA9IGNsYW1wKGNvb3JkLCB1SW5wdXRDbGFtcC54eSwgdUlucHV0Q2xhbXAuencpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgaWYoIGNvb3JkLnggPiB1SW5wdXRDbGFtcC56ICkge1xcbiAgICAgICAgICAgIGlmIChmaWxsTW9kZSA9PSBUUkFOU1BBUkVOVCkge1xcbiAgICAgICAgICAgICAgICBkaXNjYXJkO1xcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZmlsbE1vZGUgPT0gTE9PUCkge1xcbiAgICAgICAgICAgICAgICBjb29yZC54IC09IHVJbnB1dENsYW1wLno7XFxuICAgICAgICAgICAgfSBlbHNlIGlmIChmaWxsTW9kZSA9PSBNSVJST1IpIHtcXG4gICAgICAgICAgICAgICAgY29vcmQueCA9IHVJbnB1dENsYW1wLnogKiAyLjAgLSBjb29yZC54O1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0gZWxzZSBpZiggY29vcmQueCA8IHVJbnB1dENsYW1wLnggKSB7XFxuICAgICAgICAgICAgaWYgKGZpbGxNb2RlID09IFRSQU5TUEFSRU5UKSB7XFxuICAgICAgICAgICAgICAgIGRpc2NhcmQ7XFxuICAgICAgICAgICAgfSBlbHNlIGlmIChmaWxsTW9kZSA9PSBMT09QKSB7XFxuICAgICAgICAgICAgICAgIGNvb3JkLnggKz0gdUlucHV0Q2xhbXAuejtcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZpbGxNb2RlID09IE1JUlJPUikge1xcbiAgICAgICAgICAgICAgICBjb29yZC54ICo9IC11SW5wdXRDbGFtcC56O1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmKCBjb29yZC55ID4gdUlucHV0Q2xhbXAudyApIHtcXG4gICAgICAgICAgICBpZiAoZmlsbE1vZGUgPT0gVFJBTlNQQVJFTlQpIHtcXG4gICAgICAgICAgICAgICAgZGlzY2FyZDtcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZpbGxNb2RlID09IExPT1ApIHtcXG4gICAgICAgICAgICAgICAgY29vcmQueSAtPSB1SW5wdXRDbGFtcC53O1xcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZmlsbE1vZGUgPT0gTUlSUk9SKSB7XFxuICAgICAgICAgICAgICAgIGNvb3JkLnkgPSB1SW5wdXRDbGFtcC53ICogMi4wIC0gY29vcmQueTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2UgaWYoIGNvb3JkLnkgPCB1SW5wdXRDbGFtcC55ICkge1xcbiAgICAgICAgICAgIGlmIChmaWxsTW9kZSA9PSBUUkFOU1BBUkVOVCkge1xcbiAgICAgICAgICAgICAgICBkaXNjYXJkO1xcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZmlsbE1vZGUgPT0gTE9PUCkge1xcbiAgICAgICAgICAgICAgICBjb29yZC55ICs9IHVJbnB1dENsYW1wLnc7XFxuICAgICAgICAgICAgfSBlbHNlIGlmIChmaWxsTW9kZSA9PSBNSVJST1IpIHtcXG4gICAgICAgICAgICAgICAgY29vcmQueSAqPSAtdUlucHV0Q2xhbXAudztcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgIH1cXG5cXG4gICAgZmluYWxDb2xvci5yID0gdGV4dHVyZSh1VGV4dHVyZSwgY29vcmQgKyB1UmVkICogKDEuMCAtIHVTZWVkICogMC40KSAvIHVJbnB1dFNpemUueHkpLnI7XFxuICAgIGZpbmFsQ29sb3IuZyA9IHRleHR1cmUodVRleHR1cmUsIGNvb3JkICsgdUdyZWVuICogKDEuMCAtIHVTZWVkICogMC4zKSAvIHVJbnB1dFNpemUueHkpLmc7XFxuICAgIGZpbmFsQ29sb3IuYiA9IHRleHR1cmUodVRleHR1cmUsIGNvb3JkICsgdUJsdWUgKiAoMS4wIC0gdVNlZWQgKiAwLjIpIC8gdUlucHV0U2l6ZS54eSkuYjtcXG4gICAgZmluYWxDb2xvci5hID0gdGV4dHVyZSh1VGV4dHVyZSwgY29vcmQpLmE7XFxufVxcblwiO1xuXG5leHBvcnQgeyBmcmFnbWVudCBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nbGl0Y2gyLm1qcy5tYXBcbiIsImltcG9ydCB7IEZpbHRlciwgR3B1UHJvZ3JhbSwgR2xQcm9ncmFtLCBDb2xvciB9IGZyb20gJ3BpeGkuanMnO1xuaW1wb3J0IHZlcnRleCBmcm9tICcuLi9kZWZhdWx0cy9kZWZhdWx0Mi5tanMnO1xuaW1wb3J0IHdnc2xWZXJ0ZXggZnJvbSAnLi4vZGVmYXVsdHMvZGVmYXVsdC5tanMnO1xuaW1wb3J0IGZyYWdtZW50IGZyb20gJy4vZ2xvdy5tanMnO1xuaW1wb3J0IHNvdXJjZSBmcm9tICcuL2dsb3cyLm1qcyc7XG5cbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbmNvbnN0IF9HbG93RmlsdGVyID0gY2xhc3MgX0dsb3dGaWx0ZXIgZXh0ZW5kcyBGaWx0ZXIge1xuICAvKipcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGZvciB0aGUgR2xvd0ZpbHRlciBjb25zdHJ1Y3Rvci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0geyAuLi5fR2xvd0ZpbHRlci5ERUZBVUxUX09QVElPTlMsIC4uLm9wdGlvbnMgfTtcbiAgICBjb25zdCBkaXN0YW5jZSA9IG9wdGlvbnMuZGlzdGFuY2UgPz8gMTA7XG4gICAgY29uc3QgcXVhbGl0eSA9IG9wdGlvbnMucXVhbGl0eSA/PyAwLjE7XG4gICAgY29uc3QgZ3B1UHJvZ3JhbSA9IEdwdVByb2dyYW0uZnJvbSh7XG4gICAgICB2ZXJ0ZXg6IHtcbiAgICAgICAgc291cmNlOiB3Z3NsVmVydGV4LFxuICAgICAgICBlbnRyeVBvaW50OiBcIm1haW5WZXJ0ZXhcIlxuICAgICAgfSxcbiAgICAgIGZyYWdtZW50OiB7XG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgZW50cnlQb2ludDogXCJtYWluRnJhZ21lbnRcIlxuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGdsUHJvZ3JhbSA9IEdsUHJvZ3JhbS5mcm9tKHtcbiAgICAgIHZlcnRleCxcbiAgICAgIGZyYWdtZW50OiBmcmFnbWVudC5yZXBsYWNlKC9fX0FOR0xFX1NURVBfU0laRV9fL2dpLCBgJHsoMSAvIHF1YWxpdHkgLyBkaXN0YW5jZSkudG9GaXhlZCg3KX1gKS5yZXBsYWNlKC9fX0RJU1RfXy9naSwgYCR7ZGlzdGFuY2UudG9GaXhlZCgwKX0uMGApLFxuICAgICAgbmFtZTogXCJnbG93LWZpbHRlclwiXG4gICAgfSk7XG4gICAgc3VwZXIoe1xuICAgICAgZ3B1UHJvZ3JhbSxcbiAgICAgIGdsUHJvZ3JhbSxcbiAgICAgIHJlc291cmNlczoge1xuICAgICAgICBnbG93VW5pZm9ybXM6IHtcbiAgICAgICAgICB1RGlzdGFuY2U6IHsgdmFsdWU6IGRpc3RhbmNlLCB0eXBlOiBcImYzMlwiIH0sXG4gICAgICAgICAgdVN0cmVuZ3RoOiB7IHZhbHVlOiBbb3B0aW9ucy5pbm5lclN0cmVuZ3RoLCBvcHRpb25zLm91dGVyU3RyZW5ndGhdLCB0eXBlOiBcInZlYzI8ZjMyPlwiIH0sXG4gICAgICAgICAgdUNvbG9yOiB7IHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KDMpLCB0eXBlOiBcInZlYzM8ZjMyPlwiIH0sXG4gICAgICAgICAgdUFscGhhOiB7IHZhbHVlOiBvcHRpb25zLmFscGhhLCB0eXBlOiBcImYzMlwiIH0sXG4gICAgICAgICAgdVF1YWxpdHk6IHsgdmFsdWU6IHF1YWxpdHksIHR5cGU6IFwiZjMyXCIgfSxcbiAgICAgICAgICB1S25vY2tvdXQ6IHsgdmFsdWU6IG9wdGlvbnM/Lmtub2Nrb3V0ID8/IGZhbHNlID8gMSA6IDAsIHR5cGU6IFwiZjMyXCIgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcGFkZGluZzogZGlzdGFuY2VcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidW5pZm9ybXNcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9jb2xvclwiKTtcbiAgICB0aGlzLnVuaWZvcm1zID0gdGhpcy5yZXNvdXJjZXMuZ2xvd1VuaWZvcm1zLnVuaWZvcm1zO1xuICAgIHRoaXMuX2NvbG9yID0gbmV3IENvbG9yKCk7XG4gICAgdGhpcy5jb2xvciA9IG9wdGlvbnMuY29sb3IgPz8gMTY3NzcyMTU7XG4gIH1cbiAgLyoqXG4gICAqIE9ubHkgZHJhdyB0aGUgZ2xvdywgbm90IHRoZSB0ZXh0dXJlIGl0c2VsZlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgZ2V0IGRpc3RhbmNlKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnVEaXN0YW5jZTtcbiAgfVxuICBzZXQgZGlzdGFuY2UodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnVEaXN0YW5jZSA9IHRoaXMucGFkZGluZyA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAqIFRoZSBzdHJlbmd0aCBvZiB0aGUgZ2xvdyBpbndhcmQgZnJvbSB0aGUgZWRnZSBvZiB0aGUgc3ByaXRlLlxuICAqIEBkZWZhdWx0IDBcbiAgKi9cbiAgZ2V0IGlubmVyU3RyZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMudVN0cmVuZ3RoWzBdO1xuICB9XG4gIHNldCBpbm5lclN0cmVuZ3RoKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy51U3RyZW5ndGhbMF0gPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgKiBUaGUgc3RyZW5ndGggb2YgdGhlIGdsb3cgb3V0d2FyZCBmcm9tIHRoZSBlZGdlIG9mIHRoZSBzcHJpdGUuXG4gICogQGRlZmF1bHQgNFxuICAqL1xuICBnZXQgb3V0ZXJTdHJlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy51U3RyZW5ndGhbMV07XG4gIH1cbiAgc2V0IG91dGVyU3RyZW5ndGgodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnVTdHJlbmd0aFsxXSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAqIFRoZSBjb2xvciBvZiB0aGUgZ2xvdy5cbiAgKiBAZGVmYXVsdCAweEZGRkZGRlxuICAqL1xuICBnZXQgY29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbG9yLnZhbHVlO1xuICB9XG4gIHNldCBjb2xvcih2YWx1ZSkge1xuICAgIHRoaXMuX2NvbG9yLnNldFZhbHVlKHZhbHVlKTtcbiAgICBjb25zdCBbciwgZywgYl0gPSB0aGlzLl9jb2xvci50b0FycmF5KCk7XG4gICAgdGhpcy51bmlmb3Jtcy51Q29sb3JbMF0gPSByO1xuICAgIHRoaXMudW5pZm9ybXMudUNvbG9yWzFdID0gZztcbiAgICB0aGlzLnVuaWZvcm1zLnVDb2xvclsyXSA9IGI7XG4gIH1cbiAgLyoqXG4gICogVGhlIGFscGhhIG9mIHRoZSBnbG93XG4gICogQGRlZmF1bHQgMVxuICAqL1xuICBnZXQgYWxwaGEoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMudUFscGhhO1xuICB9XG4gIHNldCBhbHBoYSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMudUFscGhhID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICogQSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxIHRoYXQgZGVzY3JpYmVzIHRoZSBxdWFsaXR5IG9mIHRoZSBnbG93LiBUaGUgaGlnaGVyIHRoZSBudW1iZXIgdGhlIGxlc3MgcGVyZm9ybWFudFxuICAqIEBkZWZhdWx0IDAuMVxuICAqL1xuICBnZXQgcXVhbGl0eSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy51UXVhbGl0eTtcbiAgfVxuICBzZXQgcXVhbGl0eSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMudVF1YWxpdHkgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgKiBPbmx5IGRyYXcgdGhlIGdsb3csIG5vdCB0aGUgdGV4dHVyZSBpdHNlbGZcbiAgKiBAZGVmYXVsdCBmYWxzZVxuICAqL1xuICBnZXQga25vY2tvdXQoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMudUtub2Nrb3V0ID09PSAxO1xuICB9XG4gIHNldCBrbm9ja291dCh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMudUtub2Nrb3V0ID0gdmFsdWUgPyAxIDogMDtcbiAgfVxufTtcbi8qKiBEZWZhdWx0IHZhbHVlcyBmb3Igb3B0aW9ucy4gKi9cbl9fcHVibGljRmllbGQoX0dsb3dGaWx0ZXIsIFwiREVGQVVMVF9PUFRJT05TXCIsIHtcbiAgZGlzdGFuY2U6IDEwLFxuICBvdXRlclN0cmVuZ3RoOiA0LFxuICBpbm5lclN0cmVuZ3RoOiAwLFxuICBjb2xvcjogMTY3NzcyMTUsXG4gIGFscGhhOiAxLFxuICBxdWFsaXR5OiAwLjEsXG4gIGtub2Nrb3V0OiBmYWxzZVxufSk7XG5sZXQgR2xvd0ZpbHRlciA9IF9HbG93RmlsdGVyO1xuXG5leHBvcnQgeyBHbG93RmlsdGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HbG93RmlsdGVyLm1qcy5tYXBcbiIsInZhciBzb3VyY2UgPSBcInN0cnVjdCBHbG93VW5pZm9ybXMge1xcbiAgdURpc3RhbmNlOiBmMzIsXFxuICB1U3RyZW5ndGg6IHZlYzI8ZjMyPixcXG4gIHVDb2xvcjogdmVjMzxmMzI+LFxcbiAgdUFscGhhOiBmMzIsXFxuICB1UXVhbGl0eTogZjMyLFxcbiAgdUtub2Nrb3V0OiBmMzIsXFxufTtcXG5cXG5zdHJ1Y3QgR2xvYmFsRmlsdGVyVW5pZm9ybXMge1xcbiAgdUlucHV0U2l6ZTp2ZWM0PGYzMj4sXFxuICB1SW5wdXRQaXhlbDp2ZWM0PGYzMj4sXFxuICB1SW5wdXRDbGFtcDp2ZWM0PGYzMj4sXFxuICB1T3V0cHV0RnJhbWU6dmVjNDxmMzI+LFxcbiAgdUdsb2JhbEZyYW1lOnZlYzQ8ZjMyPixcXG4gIHVPdXRwdXRUZXh0dXJlOnZlYzQ8ZjMyPixcXG59O1xcblxcbkBncm91cCgwKSBAYmluZGluZygwKSB2YXI8dW5pZm9ybT4gZ2Z1OiBHbG9iYWxGaWx0ZXJVbmlmb3JtcztcXG5cXG5AZ3JvdXAoMCkgQGJpbmRpbmcoMSkgdmFyIHVUZXh0dXJlOiB0ZXh0dXJlXzJkPGYzMj47IFxcbkBncm91cCgwKSBAYmluZGluZygyKSB2YXIgdVNhbXBsZXI6IHNhbXBsZXI7XFxuQGdyb3VwKDEpIEBiaW5kaW5nKDApIHZhcjx1bmlmb3JtPiBnbG93VW5pZm9ybXMgOiBHbG93VW5pZm9ybXM7XFxuXFxuQGZyYWdtZW50XFxuZm4gbWFpbkZyYWdtZW50KFxcbiAgQGJ1aWx0aW4ocG9zaXRpb24pIHBvc2l0aW9uOiB2ZWM0PGYzMj4sXFxuICBAbG9jYXRpb24oMCkgdXYgOiB2ZWMyPGYzMj5cXG4pIC0+IEBsb2NhdGlvbigwKSB2ZWM0PGYzMj4ge1xcbiAgbGV0IHF1YWxpdHkgPSBnbG93VW5pZm9ybXMudVF1YWxpdHk7XFxuICBsZXQgZGlzdGFuY2UgPSBnbG93VW5pZm9ybXMudURpc3RhbmNlO1xcblxcbiAgbGV0IGRpc3Q6IGYzMiA9IGdsb3dVbmlmb3Jtcy51RGlzdGFuY2U7XFxuICBsZXQgYW5nbGVTdGVwU2l6ZTogZjMyID0gbWluKDEuIC8gcXVhbGl0eSAvIGRpc3RhbmNlLCBQSSAqIDIuMCk7XFxuICBsZXQgYW5nbGVTdGVwTnVtOiBmMzIgPSBjZWlsKFBJICogMi4wIC8gYW5nbGVTdGVwU2l6ZSk7XFxuXFxuICBsZXQgcHg6IHZlYzI8ZjMyPiA9IHZlYzI8ZjMyPigxLjAgLyBnZnUudUlucHV0U2l6ZS54eSk7XFxuXFxuICB2YXIgdG90YWxBbHBoYTogZjMyID0gMC4wO1xcblxcbiAgdmFyIGRpcmVjdGlvbjogdmVjMjxmMzI+O1xcbiAgdmFyIGRpc3BsYWNlZDogdmVjMjxmMzI+O1xcbiAgdmFyIGN1ckNvbG9yOiB2ZWM0PGYzMj47XFxuXFxuICBmb3IgKHZhciBhbmdsZSA9IDAuMDsgYW5nbGUgPCBQSSAqIDIuMDsgYW5nbGUgKz0gYW5nbGVTdGVwU2l6ZSkge1xcbiAgICBkaXJlY3Rpb24gPSB2ZWMyPGYzMj4oY29zKGFuZ2xlKSwgc2luKGFuZ2xlKSkgKiBweDtcXG4gICAgZm9yICh2YXIgY3VyRGlzdGFuY2UgPSAwLjA7IGN1ckRpc3RhbmNlIDwgZGlzdDsgY3VyRGlzdGFuY2UrPTEpIHtcXG4gICAgICBkaXNwbGFjZWQgPSB2ZWMyPGYzMj4oY2xhbXAodXYgKyBkaXJlY3Rpb24gKiAoY3VyRGlzdGFuY2UgKyAxLjApLCBnZnUudUlucHV0Q2xhbXAueHksIGdmdS51SW5wdXRDbGFtcC56dykpO1xcbiAgICAgIGN1ckNvbG9yID0gdGV4dHVyZVNhbXBsZSh1VGV4dHVyZSwgdVNhbXBsZXIsIGRpc3BsYWNlZCk7XFxuICAgICAgdG90YWxBbHBoYSArPSAoZGlzdCAtIGN1ckRpc3RhbmNlKSAqIGN1ckNvbG9yLmE7XFxuICAgIH1cXG4gIH1cXG4gICAgXFxuICBjdXJDb2xvciA9IHRleHR1cmVTYW1wbGUodVRleHR1cmUsIHVTYW1wbGVyLCB1dik7XFxuXFxuICBsZXQgZ2xvd0NvbG9yUkdCID0gZ2xvd1VuaWZvcm1zLnVDb2xvcjtcXG4gIGxldCBnbG93QWxwaGEgPSBnbG93VW5pZm9ybXMudUFscGhhO1xcbiAgbGV0IGdsb3dDb2xvciA9IHZlYzQ8ZjMyPihnbG93Q29sb3JSR0IsIGdsb3dBbHBoYSk7XFxuICBsZXQga25vY2tvdXQ6IGJvb2wgPSBnbG93VW5pZm9ybXMudUtub2Nrb3V0ID4gMC41O1xcbiAgbGV0IGlubmVyU3RyZW5ndGggPSBnbG93VW5pZm9ybXMudVN0cmVuZ3RoWzBdO1xcbiAgbGV0IG91dGVyU3RyZW5ndGggPSBnbG93VW5pZm9ybXMudVN0cmVuZ3RoWzFdO1xcblxcbiAgbGV0IGFscGhhUmF0aW86IGYzMiA9ICh0b3RhbEFscGhhIC8gKGFuZ2xlU3RlcE51bSAqIGRpc3QgKiAoZGlzdCArIDEuMCkgLyAyLjApKTtcXG4gIGxldCBpbm5lckdsb3dBbHBoYTogZjMyID0gKDEuMCAtIGFscGhhUmF0aW8pICogaW5uZXJTdHJlbmd0aCAqIGN1ckNvbG9yLmEgKiBnbG93QWxwaGE7XFxuICBsZXQgaW5uZXJHbG93U3RyZW5ndGg6IGYzMiA9IG1pbigxLjAsIGlubmVyR2xvd0FscGhhKTtcXG4gIFxcbiAgbGV0IGlubmVyQ29sb3I6IHZlYzQ8ZjMyPiA9IG1peChjdXJDb2xvciwgZ2xvd0NvbG9yLCBpbm5lckdsb3dTdHJlbmd0aCk7XFxuICBsZXQgb3V0ZXJHbG93QWxwaGE6IGYzMiA9IGFscGhhUmF0aW8gKiBvdXRlclN0cmVuZ3RoICogKDEuIC0gY3VyQ29sb3IuYSkgKiBnbG93QWxwaGE7XFxuICBsZXQgb3V0ZXJHbG93U3RyZW5ndGg6IGYzMiA9IG1pbigxLjAgLSBpbm5lckNvbG9yLmEsIG91dGVyR2xvd0FscGhhKTtcXG4gIGxldCBvdXRlckdsb3dDb2xvcjogdmVjNDxmMzI+ID0gb3V0ZXJHbG93U3RyZW5ndGggKiBnbG93Q29sb3IucmdiYTtcXG4gIFxcbiAgaWYgKGtub2Nrb3V0KSB7XFxuICAgIGxldCByZXN1bHRBbHBoYTogZjMyID0gb3V0ZXJHbG93QWxwaGEgKyBpbm5lckdsb3dBbHBoYTtcXG4gICAgcmV0dXJuIHZlYzQ8ZjMyPihnbG93Q29sb3IucmdiICogcmVzdWx0QWxwaGEsIHJlc3VsdEFscGhhKTtcXG4gIH1cXG4gIGVsc2Uge1xcbiAgICByZXR1cm4gaW5uZXJDb2xvciArIG91dGVyR2xvd0NvbG9yO1xcbiAgfVxcbn1cXG5cXG5jb25zdCBQSTogZjMyID0gMy4xNDE1OTI2NTM1ODk3OTMyMzg0NjI2NDtcIjtcblxuZXhwb3J0IHsgc291cmNlIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdsb3cyLm1qcy5tYXBcbiIsInZhciBmcmFnbWVudCA9IFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbmluIHZlYzIgdlRleHR1cmVDb29yZDtcXG5vdXQgdmVjNCBmaW5hbENvbG9yO1xcblxcbnVuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbnVuaWZvcm0gdmVjMiB1U3RyZW5ndGg7XFxudW5pZm9ybSB2ZWMzIHVDb2xvcjtcXG51bmlmb3JtIGZsb2F0IHVLbm9ja291dDtcXG51bmlmb3JtIGZsb2F0IHVBbHBoYTtcXG5cXG51bmlmb3JtIHZlYzQgdUlucHV0U2l6ZTtcXG51bmlmb3JtIHZlYzQgdUlucHV0Q2xhbXA7XFxuXFxuY29uc3QgZmxvYXQgUEkgPSAzLjE0MTU5MjY1MzU4OTc5MzIzODQ2MjY0O1xcblxcbi8vIEhhcmQtYXNzaWdubWVudCBvZiBESVNUIGFuZCBBTkdMRV9TVEVQX1NJWkUgaW5zdGVhZCBvZiB1c2luZyB1RGlzdGFuY2UgYW5kIHVRdWFsaXR5IHRvIGFsbG93IHRoZW0gdG8gYmUgdXNlIG9uIEdMU0wgbG9vcCBjb25kaXRpb25zXFxuY29uc3QgZmxvYXQgRElTVCA9IF9fRElTVF9fO1xcbmNvbnN0IGZsb2F0IEFOR0xFX1NURVBfU0laRSA9IG1pbihfX0FOR0xFX1NURVBfU0laRV9fLCBQSSAqIDIuKTtcXG5jb25zdCBmbG9hdCBBTkdMRV9TVEVQX05VTSA9IGNlaWwoUEkgKiAyLiAvIEFOR0xFX1NURVBfU0laRSk7XFxuY29uc3QgZmxvYXQgTUFYX1RPVEFMX0FMUEhBID0gQU5HTEVfU1RFUF9OVU0gKiBESVNUICogKERJU1QgKyAxLikgLyAyLjtcXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgICB2ZWMyIHB4ID0gdmVjMigxLikgLyB1SW5wdXRTaXplLnh5O1xcblxcbiAgICBmbG9hdCB0b3RhbEFscGhhID0gMC47XFxuXFxuICAgIHZlYzIgZGlyZWN0aW9uO1xcbiAgICB2ZWMyIGRpc3BsYWNlZDtcXG4gICAgdmVjNCBjdXJDb2xvcjtcXG5cXG4gICAgZm9yIChmbG9hdCBhbmdsZSA9IDAuOyBhbmdsZSA8IFBJICogMi47IGFuZ2xlICs9IEFOR0xFX1NURVBfU0laRSkge1xcbiAgICAgIGRpcmVjdGlvbiA9IHZlYzIoY29zKGFuZ2xlKSwgc2luKGFuZ2xlKSkgKiBweDtcXG5cXG4gICAgICBmb3IgKGZsb2F0IGN1ckRpc3RhbmNlID0gMC47IGN1ckRpc3RhbmNlIDwgRElTVDsgY3VyRGlzdGFuY2UrKykge1xcbiAgICAgICAgICBkaXNwbGFjZWQgPSBjbGFtcCh2VGV4dHVyZUNvb3JkICsgZGlyZWN0aW9uICogKGN1ckRpc3RhbmNlICsgMS4pLCB1SW5wdXRDbGFtcC54eSwgdUlucHV0Q2xhbXAuencpO1xcbiAgICAgICAgICBjdXJDb2xvciA9IHRleHR1cmUodVRleHR1cmUsIGRpc3BsYWNlZCk7XFxuICAgICAgICAgIHRvdGFsQWxwaGEgKz0gKERJU1QgLSBjdXJEaXN0YW5jZSkgKiBjdXJDb2xvci5hO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICBcXG4gICAgY3VyQ29sb3IgPSB0ZXh0dXJlKHVUZXh0dXJlLCB2VGV4dHVyZUNvb3JkKTtcXG5cXG4gICAgdmVjNCBnbG93Q29sb3IgPSB2ZWM0KHVDb2xvciwgdUFscGhhKTtcXG4gICAgYm9vbCBrbm9ja291dCA9IHVLbm9ja291dCA+IC41O1xcbiAgICBmbG9hdCBpbm5lclN0cmVuZ3RoID0gdVN0cmVuZ3RoWzBdO1xcbiAgICBmbG9hdCBvdXRlclN0cmVuZ3RoID0gdVN0cmVuZ3RoWzFdO1xcblxcbiAgICBmbG9hdCBhbHBoYVJhdGlvID0gdG90YWxBbHBoYSAvIE1BWF9UT1RBTF9BTFBIQTtcXG4gICAgZmxvYXQgaW5uZXJHbG93QWxwaGEgPSAoMS4gLSBhbHBoYVJhdGlvKSAqIGlubmVyU3RyZW5ndGggKiBjdXJDb2xvci5hICogdUFscGhhO1xcbiAgICBmbG9hdCBpbm5lckdsb3dTdHJlbmd0aCA9IG1pbigxLiwgaW5uZXJHbG93QWxwaGEpO1xcbiAgICBcXG4gICAgdmVjNCBpbm5lckNvbG9yID0gbWl4KGN1ckNvbG9yLCBnbG93Q29sb3IsIGlubmVyR2xvd1N0cmVuZ3RoKTtcXG4gICAgZmxvYXQgb3V0ZXJHbG93QWxwaGEgPSBhbHBoYVJhdGlvICogb3V0ZXJTdHJlbmd0aCAqICgxLiAtIGN1ckNvbG9yLmEpICogdUFscGhhO1xcbiAgICBmbG9hdCBvdXRlckdsb3dTdHJlbmd0aCA9IG1pbigxLiAtIGlubmVyQ29sb3IuYSwgb3V0ZXJHbG93QWxwaGEpO1xcbiAgICB2ZWM0IG91dGVyR2xvd0NvbG9yID0gb3V0ZXJHbG93U3RyZW5ndGggKiBnbG93Q29sb3IucmdiYTtcXG5cXG4gICAgaWYgKGtub2Nrb3V0KSB7XFxuICAgICAgZmxvYXQgcmVzdWx0QWxwaGEgPSBvdXRlckdsb3dBbHBoYSArIGlubmVyR2xvd0FscGhhO1xcbiAgICAgIGZpbmFsQ29sb3IgPSB2ZWM0KGdsb3dDb2xvci5yZ2IgKiByZXN1bHRBbHBoYSwgcmVzdWx0QWxwaGEpO1xcbiAgICB9XFxuICAgIGVsc2Uge1xcbiAgICAgIGZpbmFsQ29sb3IgPSBpbm5lckNvbG9yICsgb3V0ZXJHbG93Q29sb3I7XFxuICAgIH1cXG59XFxuXCI7XG5cbmV4cG9ydCB7IGZyYWdtZW50IGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdsb3cubWpzLm1hcFxuIiwiaW1wb3J0IHsgRmlsdGVyLCBHcHVQcm9ncmFtLCBHbFByb2dyYW0sIERFR19UT19SQUQgfSBmcm9tICdwaXhpLmpzJztcbmltcG9ydCB2ZXJ0ZXggZnJvbSAnLi4vZGVmYXVsdHMvZGVmYXVsdDIubWpzJztcbmltcG9ydCB3Z3NsVmVydGV4IGZyb20gJy4uL2RlZmF1bHRzL2RlZmF1bHQubWpzJztcbmltcG9ydCBmcmFnbWVudCBmcm9tICcuL2dvZC1yYXkyLm1qcyc7XG5pbXBvcnQgc291cmNlIGZyb20gJy4vZ29kLXJheS5tanMnO1xuaW1wb3J0IHBlcmxpbiBmcm9tICcuL3Blcmxpbi5tanMnO1xuaW1wb3J0IHNvdXJjZVBlcmxpbiBmcm9tICcuL3BlcmxpbjIubWpzJztcblxudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuY29uc3QgX0dvZHJheUZpbHRlciA9IGNsYXNzIF9Hb2RyYXlGaWx0ZXIgZXh0ZW5kcyBGaWx0ZXIge1xuICAvKipcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGZvciB0aGUgR29kcmF5RmlsdGVyIGNvbnN0cnVjdG9yLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7IC4uLl9Hb2RyYXlGaWx0ZXIuREVGQVVMVF9PUFRJT05TLCAuLi5vcHRpb25zIH07XG4gICAgY29uc3QgZ3B1UHJvZ3JhbSA9IEdwdVByb2dyYW0uZnJvbSh7XG4gICAgICB2ZXJ0ZXg6IHtcbiAgICAgICAgc291cmNlOiB3Z3NsVmVydGV4LFxuICAgICAgICBlbnRyeVBvaW50OiBcIm1haW5WZXJ0ZXhcIlxuICAgICAgfSxcbiAgICAgIGZyYWdtZW50OiB7XG4gICAgICAgIHNvdXJjZTogc291cmNlLnJlcGxhY2UoXCIke1BFUkxJTn1cIiwgc291cmNlUGVybGluKSxcbiAgICAgICAgZW50cnlQb2ludDogXCJtYWluRnJhZ21lbnRcIlxuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGdsUHJvZ3JhbSA9IEdsUHJvZ3JhbS5mcm9tKHtcbiAgICAgIHZlcnRleCxcbiAgICAgIGZyYWdtZW50OiBmcmFnbWVudC5yZXBsYWNlKFwiJHtQRVJMSU59XCIsIHBlcmxpbiksXG4gICAgICBuYW1lOiBcImdvZC1yYXktZmlsdGVyXCJcbiAgICB9KTtcbiAgICBzdXBlcih7XG4gICAgICBncHVQcm9ncmFtLFxuICAgICAgZ2xQcm9ncmFtLFxuICAgICAgcmVzb3VyY2VzOiB7XG4gICAgICAgIGdvZHJheVVuaWZvcm1zOiB7XG4gICAgICAgICAgdUxpZ2h0OiB7IHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KDIpLCB0eXBlOiBcInZlYzI8ZjMyPlwiIH0sXG4gICAgICAgICAgdVBhcmFsbGVsOiB7IHZhbHVlOiAwLCB0eXBlOiBcImYzMlwiIH0sXG4gICAgICAgICAgdUFzcGVjdDogeyB2YWx1ZTogMCwgdHlwZTogXCJmMzJcIiB9LFxuICAgICAgICAgIHVUaW1lOiB7IHZhbHVlOiBvcHRpb25zLnRpbWUsIHR5cGU6IFwiZjMyXCIgfSxcbiAgICAgICAgICB1UmF5OiB7IHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KDMpLCB0eXBlOiBcInZlYzM8ZjMyPlwiIH0sXG4gICAgICAgICAgdURpbWVuc2lvbnM6IHsgdmFsdWU6IG5ldyBGbG9hdDMyQXJyYXkoMiksIHR5cGU6IFwidmVjMjxmMzI+XCIgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInVuaWZvcm1zXCIpO1xuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IHRpbWUgcG9zaXRpb25cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInRpbWVcIiwgMCk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9hbmdsZUxpZ2h0XCIsIFswLCAwXSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9hbmdsZVwiLCAwKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX2NlbnRlclwiKTtcbiAgICB0aGlzLnVuaWZvcm1zID0gdGhpcy5yZXNvdXJjZXMuZ29kcmF5VW5pZm9ybXMudW5pZm9ybXM7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogT3ZlcnJpZGUgZXhpc3RpbmcgYXBwbHkgbWV0aG9kIGluIEZpbHRlclxuICAgKiBAb3ZlcnJpZGVcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgYXBwbHkoZmlsdGVyTWFuYWdlciwgaW5wdXQsIG91dHB1dCwgY2xlYXJNb2RlKSB7XG4gICAgY29uc3Qgd2lkdGggPSBpbnB1dC5mcmFtZS53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSBpbnB1dC5mcmFtZS5oZWlnaHQ7XG4gICAgdGhpcy51bmlmb3Jtcy51TGlnaHRbMF0gPSB0aGlzLnBhcmFsbGVsID8gdGhpcy5fYW5nbGVMaWdodFswXSA6IHRoaXMuX2NlbnRlci54O1xuICAgIHRoaXMudW5pZm9ybXMudUxpZ2h0WzFdID0gdGhpcy5wYXJhbGxlbCA/IHRoaXMuX2FuZ2xlTGlnaHRbMV0gOiB0aGlzLl9jZW50ZXIueTtcbiAgICB0aGlzLnVuaWZvcm1zLnVEaW1lbnNpb25zWzBdID0gd2lkdGg7XG4gICAgdGhpcy51bmlmb3Jtcy51RGltZW5zaW9uc1sxXSA9IGhlaWdodDtcbiAgICB0aGlzLnVuaWZvcm1zLnVBc3BlY3QgPSBoZWlnaHQgLyB3aWR0aDtcbiAgICB0aGlzLnVuaWZvcm1zLnVUaW1lID0gdGhpcy50aW1lO1xuICAgIGZpbHRlck1hbmFnZXIuYXBwbHlGaWx0ZXIodGhpcywgaW5wdXQsIG91dHB1dCwgY2xlYXJNb2RlKTtcbiAgfVxuICAvKipcbiAgICogVGhlIGFuZ2xlL2xpZ2h0LXNvdXJjZSBvZiB0aGUgcmF5cyBpbiBkZWdyZWVzLiBGb3IgaW5zdGFuY2UsXG4gICAqIGEgdmFsdWUgb2YgMCBpcyB2ZXJ0aWNhbCByYXlzLCB2YWx1ZXMgb2YgOTAgb3IgLTkwIHByb2R1Y2UgaG9yaXpvbnRhbCByYXlzXG4gICAqIEBkZWZhdWx0IDMwXG4gICAqL1xuICBnZXQgYW5nbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FuZ2xlO1xuICB9XG4gIHNldCBhbmdsZSh2YWx1ZSkge1xuICAgIHRoaXMuX2FuZ2xlID0gdmFsdWU7XG4gICAgY29uc3QgcmFkaWFucyA9IHZhbHVlICogREVHX1RPX1JBRDtcbiAgICB0aGlzLl9hbmdsZUxpZ2h0WzBdID0gTWF0aC5jb3MocmFkaWFucyk7XG4gICAgdGhpcy5fYW5nbGVMaWdodFsxXSA9IE1hdGguc2luKHJhZGlhbnMpO1xuICB9XG4gIC8qKlxuICAgKiBgdHJ1ZWAgaWYgbGlnaHQgcmF5cyBhcmUgcGFyYWxsZWwgKHVzZXMgYW5nbGUpLCBgZmFsc2VgIHRvIHVzZSB0aGUgZm9jYWwgYGNlbnRlcmAgcG9pbnRcbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgZ2V0IHBhcmFsbGVsKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnVQYXJhbGxlbCA+IDAuNTtcbiAgfVxuICBzZXQgcGFyYWxsZWwodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnVQYXJhbGxlbCA9IHZhbHVlID8gMSA6IDA7XG4gIH1cbiAgLyoqXG4gICAqIEZvY2FsIHBvaW50IGZvciBub24tcGFyYWxsZWwgcmF5cywgdG8gdXNlIHRoaXMgYHBhcmFsbGVsYCBtdXN0IGJlIHNldCB0byBgZmFsc2VgLlxuICAgKiBAZGVmYXVsdCB7eDowLHk6MH1cbiAgICovXG4gIGdldCBjZW50ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NlbnRlcjtcbiAgfVxuICBzZXQgY2VudGVyKHZhbHVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB2YWx1ZSA9IHsgeDogdmFsdWVbMF0sIHk6IHZhbHVlWzFdIH07XG4gICAgfVxuICAgIHRoaXMuX2NlbnRlciA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBGb2NhbCBwb2ludCBmb3Igbm9uLXBhcmFsbGVsIHJheXMgb24gdGhlIGB4YCBheGlzLCB0byB1c2UgdGhpcyBgcGFyYWxsZWxgIG11c3QgYmUgc2V0IHRvIGBmYWxzZWAuXG4gICAqIEBkZWZhdWx0IDBcbiAgICovXG4gIGdldCBjZW50ZXJYKCkge1xuICAgIHJldHVybiB0aGlzLmNlbnRlci54O1xuICB9XG4gIHNldCBjZW50ZXJYKHZhbHVlKSB7XG4gICAgdGhpcy5jZW50ZXIueCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBGb2NhbCBwb2ludCBmb3Igbm9uLXBhcmFsbGVsIHJheXMgb24gdGhlIGB5YCBheGlzLCB0byB1c2UgdGhpcyBgcGFyYWxsZWxgIG11c3QgYmUgc2V0IHRvIGBmYWxzZWAuXG4gICAqIEBkZWZhdWx0IDBcbiAgICovXG4gIGdldCBjZW50ZXJZKCkge1xuICAgIHJldHVybiB0aGlzLmNlbnRlci55O1xuICB9XG4gIHNldCBjZW50ZXJZKHZhbHVlKSB7XG4gICAgdGhpcy5jZW50ZXIueSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmFsIGludGVuc2l0eSBvZiB0aGUgZWZmZWN0LiBBIHZhbHVlIGNsb3NlciB0byAxIHdpbGwgcHJvZHVjZSBhIG1vcmUgaW50ZW5zZSBlZmZlY3QsXG4gICAqIHdoZXJlIGEgdmFsdWUgY2xvc2VyIHRvIDAgd2lsbCBwcm9kdWNlIGEgc3VidGxlciBlZmZlY3RcbiAgICogQGRlZmF1bHQgMC41XG4gICAqL1xuICBnZXQgZ2FpbigpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy51UmF5WzBdO1xuICB9XG4gIHNldCBnYWluKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy51UmF5WzBdID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBkZW5zaXR5IG9mIHRoZSBmcmFjdGFsIG5vaXNlLlxuICAgKiBBIGhpZ2hlciBhbW91bnQgcHJvZHVjZXMgbW9yZSByYXlzIGFuZCBhIHNtYWxsZXIgYW1vdW50IHByb2R1Y2VzIGZld2VyIHdhdmVzXG4gICAqIEBkZWZhdWx0IDIuNVxuICAgKi9cbiAgZ2V0IGxhY3VuYXJpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMudVJheVsxXTtcbiAgfVxuICBzZXQgbGFjdW5hcml0eSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMudVJheVsxXSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYWxwaGEgKG9wYWNpdHkpIG9mIHRoZSByYXlzLiAgMCBpcyBmdWxseSB0cmFuc3BhcmVudCwgMSBpcyBmdWxseSBvcGFxdWUuXG4gICAqIEBkZWZhdWx0IDFcbiAgICovXG4gIGdldCBhbHBoYSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy51UmF5WzJdO1xuICB9XG4gIHNldCBhbHBoYSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMudVJheVsyXSA9IHZhbHVlO1xuICB9XG59O1xuLyoqIERlZmF1bHQgdmFsdWVzIGZvciBvcHRpb25zLiAqL1xuX19wdWJsaWNGaWVsZChfR29kcmF5RmlsdGVyLCBcIkRFRkFVTFRfT1BUSU9OU1wiLCB7XG4gIGFuZ2xlOiAzMCxcbiAgZ2FpbjogMC41LFxuICBsYWN1bmFyaXR5OiAyLjUsXG4gIHBhcmFsbGVsOiB0cnVlLFxuICB0aW1lOiAwLFxuICBjZW50ZXI6IHsgeDogMCwgeTogMCB9LFxuICBhbHBoYTogMVxufSk7XG5sZXQgR29kcmF5RmlsdGVyID0gX0dvZHJheUZpbHRlcjtcblxuZXhwb3J0IHsgR29kcmF5RmlsdGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Hb2RyYXlGaWx0ZXIubWpzLm1hcFxuIiwidmFyIHNvdXJjZSA9IFwic3RydWN0IEdvZHJheVVuaWZvcm1zIHtcXG4gIHVMaWdodDogdmVjMjxmMzI+LFxcbiAgdVBhcmFsbGVsOiBmMzIsXFxuICB1QXNwZWN0OiBmMzIsXFxuICB1VGltZTogZjMyLFxcbiAgdVJheTogdmVjMzxmMzI+LFxcbiAgdURpbWVuc2lvbnM6IHZlYzI8ZjMyPixcXG59O1xcblxcbnN0cnVjdCBHbG9iYWxGaWx0ZXJVbmlmb3JtcyB7XFxuICB1SW5wdXRTaXplOnZlYzQ8ZjMyPixcXG4gIHVJbnB1dFBpeGVsOnZlYzQ8ZjMyPixcXG4gIHVJbnB1dENsYW1wOnZlYzQ8ZjMyPixcXG4gIHVPdXRwdXRGcmFtZTp2ZWM0PGYzMj4sXFxuICB1R2xvYmFsRnJhbWU6dmVjNDxmMzI+LFxcbiAgdU91dHB1dFRleHR1cmU6dmVjNDxmMzI+LFxcbn07XFxuXFxuQGdyb3VwKDApIEBiaW5kaW5nKDApIHZhcjx1bmlmb3JtPiBnZnU6IEdsb2JhbEZpbHRlclVuaWZvcm1zO1xcblxcbkBncm91cCgwKSBAYmluZGluZygxKSB2YXIgdVRleHR1cmU6IHRleHR1cmVfMmQ8ZjMyPjsgXFxuQGdyb3VwKDApIEBiaW5kaW5nKDIpIHZhciB1U2FtcGxlcjogc2FtcGxlcjtcXG5AZ3JvdXAoMSkgQGJpbmRpbmcoMCkgdmFyPHVuaWZvcm0+IGdvZHJheVVuaWZvcm1zIDogR29kcmF5VW5pZm9ybXM7XFxuXFxuQGZyYWdtZW50XFxuZm4gbWFpbkZyYWdtZW50KFxcbiAgQGJ1aWx0aW4ocG9zaXRpb24pIHBvc2l0aW9uOiB2ZWM0PGYzMj4sXFxuICBAbG9jYXRpb24oMCkgdXYgOiB2ZWMyPGYzMj5cXG4pIC0+IEBsb2NhdGlvbigwKSB2ZWM0PGYzMj4ge1xcbiAgbGV0IHVEaW1lbnNpb25zOiB2ZWMyPGYzMj4gPSBnb2RyYXlVbmlmb3Jtcy51RGltZW5zaW9ucztcXG4gIGxldCB1UGFyYWxsZWw6IGJvb2wgPSBnb2RyYXlVbmlmb3Jtcy51UGFyYWxsZWwgPiAwLjU7XFxuICBsZXQgdUxpZ2h0OiB2ZWMyPGYzMj4gPSBnb2RyYXlVbmlmb3Jtcy51TGlnaHQ7XFxuICBsZXQgdUFzcGVjdDogZjMyID0gZ29kcmF5VW5pZm9ybXMudUFzcGVjdDtcXG5cXG4gIGxldCBjb29yZDogdmVjMjxmMzI+ID0gdXYgKiBnZnUudUlucHV0U2l6ZS54eSAvIHVEaW1lbnNpb25zO1xcblxcbiAgdmFyIGQ6IGYzMjtcXG5cXG4gIGlmICh1UGFyYWxsZWwpIHtcXG4gICAgbGV0IF9jb3M6IGYzMiA9IHVMaWdodC54O1xcbiAgICBsZXQgX3NpbjogZjMyID0gdUxpZ2h0Lnk7XFxuICAgIGQgPSAoX2NvcyAqIGNvb3JkLngpICsgKF9zaW4gKiBjb29yZC55ICogdUFzcGVjdCk7XFxuICB9IGVsc2Uge1xcbiAgICBsZXQgZHg6IGYzMiA9IGNvb3JkLnggLSB1TGlnaHQueCAvIHVEaW1lbnNpb25zLng7XFxuICAgIGxldCBkeTogZjMyID0gKGNvb3JkLnkgLSB1TGlnaHQueSAvIHVEaW1lbnNpb25zLnkpICogdUFzcGVjdDtcXG4gICAgbGV0IGRpczogZjMyID0gc3FydChkeCAqIGR4ICsgZHkgKiBkeSkgKyAwLjAwMDAxO1xcbiAgICBkID0gZHkgLyBkaXM7XFxuICB9XFxuXFxuICBsZXQgdVRpbWU6IGYzMiA9IGdvZHJheVVuaWZvcm1zLnVUaW1lO1xcbiAgbGV0IHVSYXk6IHZlYzM8ZjMyPiA9IGdvZHJheVVuaWZvcm1zLnVSYXk7XFxuICBcXG4gIGxldCBnYWluID0gdVJheVswXTtcXG4gIGxldCBsYWN1bmFyaXR5ID0gdVJheVsxXTtcXG4gIGxldCBhbHBoYSA9IHVSYXlbMl07XFxuXFxuICBsZXQgZGlyOiB2ZWMzPGYzMj4gPSB2ZWMzPGYzMj4oZCwgZCwgMC4wKTtcXG4gIHZhciBub2lzZTogZjMyID0gdHVyYihkaXIgKyB2ZWMzPGYzMj4odVRpbWUsIDAuMCwgNjIuMSArIHVUaW1lKSAqIDAuMDUsIHZlYzM8ZjMyPig0ODAuMCwgMzIwLjAsIDQ4MC4wKSwgbGFjdW5hcml0eSwgZ2Fpbik7XFxuICBub2lzZSA9IG1peChub2lzZSwgMC4wLCAwLjMpO1xcbiAgLy9mYWRlIHZlcnRpY2FsbHkuXFxuICB2YXIgbWlzdDogdmVjNDxmMzI+ID0gdmVjNDxmMzI+KHZlYzM8ZjMyPihub2lzZSksIDEuMCkgKiAoMS4wIC0gY29vcmQueSk7XFxuICBtaXN0LmEgPSAxLjA7XFxuICAvLyBhcHBseSB1c2VyIGFscGhhXFxuICBtaXN0ICo9IGFscGhhO1xcbiAgcmV0dXJuIHRleHR1cmVTYW1wbGUodVRleHR1cmUsIHVTYW1wbGVyLCB1dikgKyBtaXN0O1xcbn1cXG5cXG4ke1BFUkxJTn1cIjtcblxuZXhwb3J0IHsgc291cmNlIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdvZC1yYXkubWpzLm1hcFxuIiwidmFyIHNvdXJjZVBlcmxpbiA9IFwiLy8gVGFrZW4gZnJvbSBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9tdW5yb2NrZXQvMjM2ZWQ1YmE3ZTQwOWI4YmRmMWZmNmVjYTVkY2RjMzlcXG5cXG5mbiBtb2R1bG9WZWMzKHg6IHZlYzM8ZjMyPiwgeTogdmVjMzxmMzI+KSAtPiB2ZWMzPGYzMj5cXG57XFxuICByZXR1cm4geCAtIHkgKiBmbG9vcih4L3kpO1xcbn1cXG5mbiBtb2QyODlWZWMzKHg6IHZlYzM8ZjMyPikgLT4gdmVjMzxmMzI+XFxue1xcbiAgICByZXR1cm4geCAtIGZsb29yKHggKiAoMS4wIC8gMjg5LjApKSAqIDI4OS4wO1xcbn1cXG5mbiBtb2QyODlWZWM0KHg6IHZlYzQ8ZjMyPikgLT4gdmVjNDxmMzI+XFxue1xcbiAgICByZXR1cm4geCAtIGZsb29yKHggKiAoMS4wIC8gMjg5LjApKSAqIDI4OS4wO1xcbn1cXG5mbiBwZXJtdXRlNCh4OiB2ZWM0PGYzMj4pIC0+IHZlYzQ8ZjMyPlxcbntcXG4gICAgcmV0dXJuIG1vZDI4OVZlYzQoKCh4ICogMzQuMCkgKyAxLjApICogeCk7XFxufVxcbmZuIHRheWxvckludlNxcnQocjogdmVjNDxmMzI+KSAtPiB2ZWM0PGYzMj5cXG57XFxuICAgIHJldHVybiAxLjc5Mjg0MjkxNDAwMTU5IC0gMC44NTM3MzQ3MjA5NTMxNCAqIHI7XFxufVxcbmZuIGZhZGUzKHQ6IHZlYzM8ZjMyPikgLT4gdmVjMzxmMzI+XFxue1xcbiAgICByZXR1cm4gdCAqIHQgKiB0ICogKHQgKiAodCAqIDYuMCAtIDE1LjApICsgMTAuMCk7XFxufVxcbmZuIGZhZGUyKHQ6IHZlYzI8ZjMyPikgLT4gdmVjMjxmMzI+IHsgcmV0dXJuIHQgKiB0ICogdCAqICh0ICogKHQgKiA2LiAtIDE1LikgKyAxMC4pOyB9XFxuXFxuZm4gcGVybGluTm9pc2UyKFA6IHZlYzI8ZjMyPikgLT4gZjMyIHtcXG4gIHZhciBQaTogdmVjNDxmMzI+ID0gZmxvb3IoUC54eXh5KSArIHZlYzQ8ZjMyPigwLiwgMC4sIDEuLCAxLik7XFxuICBsZXQgUGYgPSBmcmFjdChQLnh5eHkpIC0gdmVjNDxmMzI+KDAuLCAwLiwgMS4sIDEuKTtcXG4gIFBpID0gUGkgJSB2ZWM0PGYzMj4oMjg5Lik7IC8vIFRvIGF2b2lkIHRydW5jYXRpb24gZWZmZWN0cyBpbiBwZXJtdXRhdGlvblxcbiAgbGV0IGl4ID0gUGkueHp4ejtcXG4gIGxldCBpeSA9IFBpLnl5d3c7XFxuICBsZXQgZnggPSBQZi54enh6O1xcbiAgbGV0IGZ5ID0gUGYueXl3dztcXG4gIGxldCBpID0gcGVybXV0ZTQocGVybXV0ZTQoaXgpICsgaXkpO1xcbiAgdmFyIGd4OiB2ZWM0PGYzMj4gPSAyLiAqIGZyYWN0KGkgKiAwLjAyNDM5MDI0MzkpIC0gMS47IC8vIDEvNDEgPSAwLjAyNC4uLlxcbiAgbGV0IGd5ID0gYWJzKGd4KSAtIDAuNTtcXG4gIGxldCB0eCA9IGZsb29yKGd4ICsgMC41KTtcXG4gIGd4ID0gZ3ggLSB0eDtcXG4gIHZhciBnMDA6IHZlYzI8ZjMyPiA9IHZlYzI8ZjMyPihneC54LCBneS54KTtcXG4gIHZhciBnMTA6IHZlYzI8ZjMyPiA9IHZlYzI8ZjMyPihneC55LCBneS55KTtcXG4gIHZhciBnMDE6IHZlYzI8ZjMyPiA9IHZlYzI8ZjMyPihneC56LCBneS56KTtcXG4gIHZhciBnMTE6IHZlYzI8ZjMyPiA9IHZlYzI8ZjMyPihneC53LCBneS53KTtcXG4gIGxldCBub3JtID0gMS43OTI4NDI5MTQwMDE1OSAtIDAuODUzNzM0NzIwOTUzMTQgKlxcbiAgICAgIHZlYzQ8ZjMyPihkb3QoZzAwLCBnMDApLCBkb3QoZzAxLCBnMDEpLCBkb3QoZzEwLCBnMTApLCBkb3QoZzExLCBnMTEpKTtcXG4gIGcwMCA9IGcwMCAqIG5vcm0ueDtcXG4gIGcwMSA9IGcwMSAqIG5vcm0ueTtcXG4gIGcxMCA9IGcxMCAqIG5vcm0uejtcXG4gIGcxMSA9IGcxMSAqIG5vcm0udztcXG4gIGxldCBuMDAgPSBkb3QoZzAwLCB2ZWMyPGYzMj4oZngueCwgZnkueCkpO1xcbiAgbGV0IG4xMCA9IGRvdChnMTAsIHZlYzI8ZjMyPihmeC55LCBmeS55KSk7XFxuICBsZXQgbjAxID0gZG90KGcwMSwgdmVjMjxmMzI+KGZ4LnosIGZ5LnopKTtcXG4gIGxldCBuMTEgPSBkb3QoZzExLCB2ZWMyPGYzMj4oZngudywgZnkudykpO1xcbiAgbGV0IGZhZGVfeHkgPSBmYWRlMihQZi54eSk7XFxuICBsZXQgbl94ID0gbWl4KHZlYzI8ZjMyPihuMDAsIG4wMSksIHZlYzI8ZjMyPihuMTAsIG4xMSksIHZlYzI8ZjMyPihmYWRlX3h5LngpKTtcXG4gIGxldCBuX3h5ID0gbWl4KG5feC54LCBuX3gueSwgZmFkZV94eS55KTtcXG4gIHJldHVybiAyLjMgKiBuX3h5O1xcbn1cXG5cXG4vLyBDbGFzc2ljIFBlcmxpbiBub2lzZSwgcGVyaW9kaWMgdmFyaWFudFxcbmZuIHBlcmxpbk5vaXNlMyhQOiB2ZWMzPGYzMj4sIHJlcDogdmVjMzxmMzI+KSAtPiBmMzJcXG57XFxuICAgIHZhciBQaTA6IHZlYzM8ZjMyPiA9IG1vZHVsb1ZlYzMoZmxvb3IoUCksIHJlcCk7IC8vIEludGVnZXIgcGFydCwgbW9kdWxvIHBlcmlvZFxcbiAgICB2YXIgUGkxOiB2ZWMzPGYzMj4gPSBtb2R1bG9WZWMzKFBpMCArIHZlYzM8ZjMyPigxLjApLCByZXApOyAvLyBJbnRlZ2VyIHBhcnQgKyAxLCBtb2QgcGVyaW9kXFxuICAgIFBpMCA9IG1vZDI4OVZlYzMoUGkwKTtcXG4gICAgUGkxID0gbW9kMjg5VmVjMyhQaTEpO1xcbiAgICBsZXQgUGYwOiB2ZWMzPGYzMj4gPSBmcmFjdChQKTsgLy8gRnJhY3Rpb25hbCBwYXJ0IGZvciBpbnRlcnBvbGF0aW9uXFxuICAgIGxldCBQZjE6IHZlYzM8ZjMyPiA9IFBmMCAtIHZlYzM8ZjMyPigxLjApOyAvLyBGcmFjdGlvbmFsIHBhcnQgLSAxLjBcXG4gICAgbGV0IGl4OiB2ZWM0PGYzMj4gPSB2ZWM0PGYzMj4oUGkwLngsIFBpMS54LCBQaTAueCwgUGkxLngpO1xcbiAgICBsZXQgaXk6IHZlYzQ8ZjMyPiA9IHZlYzQ8ZjMyPihQaTAueXksIFBpMS55eSk7XFxuICAgIGxldCBpejA6IHZlYzQ8ZjMyPiA9IFBpMC56enp6O1xcbiAgICBsZXQgaXoxOiB2ZWM0PGYzMj4gPSBQaTEuenp6ejtcXG4gICAgbGV0IGl4eTogdmVjNDxmMzI+ID0gcGVybXV0ZTQocGVybXV0ZTQoaXgpICsgaXkpO1xcbiAgICBsZXQgaXh5MDogdmVjNDxmMzI+ID0gcGVybXV0ZTQoaXh5ICsgaXowKTtcXG4gICAgbGV0IGl4eTE6IHZlYzQ8ZjMyPiA9IHBlcm11dGU0KGl4eSArIGl6MSk7XFxuICAgIHZhciBneDA6IHZlYzQ8ZjMyPiA9IGl4eTAgKiAoMS4wIC8gNy4wKTtcXG4gICAgdmFyIGd5MDogdmVjNDxmMzI+ID0gZnJhY3QoZmxvb3IoZ3gwKSAqICgxLjAgLyA3LjApKSAtIDAuNTtcXG4gICAgZ3gwID0gZnJhY3QoZ3gwKTtcXG4gICAgbGV0IGd6MDogdmVjNDxmMzI+ID0gdmVjNDxmMzI+KDAuNSkgLSBhYnMoZ3gwKSAtIGFicyhneTApO1xcbiAgICBsZXQgc3owOiB2ZWM0PGYzMj4gPSBzdGVwKGd6MCwgdmVjNDxmMzI+KDAuMCkpO1xcbiAgICBneDAgLT0gc3owICogKHN0ZXAodmVjNDxmMzI+KDAuMCksIGd4MCkgLSAwLjUpO1xcbiAgICBneTAgLT0gc3owICogKHN0ZXAodmVjNDxmMzI+KDAuMCksIGd5MCkgLSAwLjUpO1xcbiAgICB2YXIgZ3gxOiB2ZWM0PGYzMj4gPSBpeHkxICogKDEuMCAvIDcuMCk7XFxuICAgIHZhciBneTE6IHZlYzQ8ZjMyPiA9IGZyYWN0KGZsb29yKGd4MSkgKiAoMS4wIC8gNy4wKSkgLSAwLjU7XFxuICAgIGd4MSA9IGZyYWN0KGd4MSk7XFxuICAgIGxldCBnejE6IHZlYzQ8ZjMyPiA9IHZlYzQ8ZjMyPigwLjUpIC0gYWJzKGd4MSkgLSBhYnMoZ3kxKTtcXG4gICAgbGV0IHN6MTogdmVjNDxmMzI+ID0gc3RlcChnejEsIHZlYzQ8ZjMyPigwLjApKTtcXG4gICAgZ3gxIC09IHN6MSAqIChzdGVwKHZlYzQ8ZjMyPigwLjApLCBneDEpIC0gMC41KTtcXG4gICAgZ3kxIC09IHN6MSAqIChzdGVwKHZlYzQ8ZjMyPigwLjApLCBneTEpIC0gMC41KTtcXG4gICAgdmFyIGcwMDA6IHZlYzM8ZjMyPiA9IHZlYzM8ZjMyPihneDAueCwgZ3kwLngsIGd6MC54KTtcXG4gICAgdmFyIGcxMDA6IHZlYzM8ZjMyPiA9IHZlYzM8ZjMyPihneDAueSwgZ3kwLnksIGd6MC55KTtcXG4gICAgdmFyIGcwMTA6IHZlYzM8ZjMyPiA9IHZlYzM8ZjMyPihneDAueiwgZ3kwLnosIGd6MC56KTtcXG4gICAgdmFyIGcxMTA6IHZlYzM8ZjMyPiA9IHZlYzM8ZjMyPihneDAudywgZ3kwLncsIGd6MC53KTtcXG4gICAgdmFyIGcwMDE6IHZlYzM8ZjMyPiA9IHZlYzM8ZjMyPihneDEueCwgZ3kxLngsIGd6MS54KTtcXG4gICAgdmFyIGcxMDE6IHZlYzM8ZjMyPiA9IHZlYzM8ZjMyPihneDEueSwgZ3kxLnksIGd6MS55KTtcXG4gICAgdmFyIGcwMTE6IHZlYzM8ZjMyPiA9IHZlYzM8ZjMyPihneDEueiwgZ3kxLnosIGd6MS56KTtcXG4gICAgdmFyIGcxMTE6IHZlYzM8ZjMyPiA9IHZlYzM8ZjMyPihneDEudywgZ3kxLncsIGd6MS53KTtcXG4gICAgbGV0IG5vcm0wOiB2ZWM0PGYzMj4gPSB0YXlsb3JJbnZTcXJ0KHZlYzQ8ZjMyPihkb3QoZzAwMCwgZzAwMCksIGRvdChnMDEwLCBnMDEwKSwgZG90KGcxMDAsIGcxMDApLCBkb3QoZzExMCwgZzExMCkpKTtcXG4gICAgZzAwMCAqPSBub3JtMC54O1xcbiAgICBnMDEwICo9IG5vcm0wLnk7XFxuICAgIGcxMDAgKj0gbm9ybTAuejtcXG4gICAgZzExMCAqPSBub3JtMC53O1xcbiAgICBsZXQgbm9ybTE6IHZlYzQ8ZjMyPiA9IHRheWxvckludlNxcnQodmVjNDxmMzI+KGRvdChnMDAxLCBnMDAxKSwgZG90KGcwMTEsIGcwMTEpLCBkb3QoZzEwMSwgZzEwMSksIGRvdChnMTExLCBnMTExKSkpO1xcbiAgICBnMDAxICo9IG5vcm0xLng7XFxuICAgIGcwMTEgKj0gbm9ybTEueTtcXG4gICAgZzEwMSAqPSBub3JtMS56O1xcbiAgICBnMTExICo9IG5vcm0xLnc7XFxuICAgIGxldCBuMDAwOiBmMzIgPSBkb3QoZzAwMCwgUGYwKTtcXG4gICAgbGV0IG4xMDA6IGYzMiA9IGRvdChnMTAwLCB2ZWMzPGYzMj4oUGYxLngsIFBmMC55eikpO1xcbiAgICBsZXQgbjAxMDogZjMyID0gZG90KGcwMTAsIHZlYzM8ZjMyPihQZjAueCwgUGYxLnksIFBmMC56KSk7XFxuICAgIGxldCBuMTEwOiBmMzIgPSBkb3QoZzExMCwgdmVjMzxmMzI+KFBmMS54eSwgUGYwLnopKTtcXG4gICAgbGV0IG4wMDE6IGYzMiA9IGRvdChnMDAxLCB2ZWMzPGYzMj4oUGYwLnh5LCBQZjEueikpO1xcbiAgICBsZXQgbjEwMTogZjMyID0gZG90KGcxMDEsIHZlYzM8ZjMyPihQZjEueCwgUGYwLnksIFBmMS56KSk7XFxuICAgIGxldCBuMDExOiBmMzIgPSBkb3QoZzAxMSwgdmVjMzxmMzI+KFBmMC54LCBQZjEueXopKTtcXG4gICAgbGV0IG4xMTE6IGYzMiA9IGRvdChnMTExLCBQZjEpO1xcbiAgICBsZXQgZmFkZV94eXo6IHZlYzM8ZjMyPiA9IGZhZGUzKFBmMCk7XFxuICAgIGxldCBuX3o6IHZlYzQ8ZjMyPiA9IG1peCh2ZWM0PGYzMj4objAwMCwgbjEwMCwgbjAxMCwgbjExMCksIHZlYzQ8ZjMyPihuMDAxLCBuMTAxLCBuMDExLCBuMTExKSwgZmFkZV94eXoueik7XFxuICAgIGxldCBuX3l6OiB2ZWMyPGYzMj4gPSBtaXgobl96Lnh5LCBuX3ouencsIGZhZGVfeHl6LnkpO1xcbiAgICBsZXQgbl94eXo6IGYzMiA9IG1peChuX3l6LngsIG5feXoueSwgZmFkZV94eXoueCk7XFxuICAgIHJldHVybiAyLjIgKiBuX3h5ejtcXG59XFxuZm4gdHVyYihQOiB2ZWMzPGYzMj4sIHJlcDogdmVjMzxmMzI+LCBsYWN1bmFyaXR5OiBmMzIsIGdhaW46IGYzMikgLT4gZjMyXFxue1xcbiAgICB2YXIgc3VtOiBmMzIgPSAwLjA7XFxuICAgIHZhciBzYzogZjMyID0gMS4wO1xcbiAgICB2YXIgdG90YWxnYWluOiBmMzIgPSAxLjA7XFxuICAgIGZvciAodmFyIGkgPSAwLjA7IGkgPCA2LjA7IGkgKz0gMSlcXG4gICAge1xcbiAgICAgICAgc3VtICs9IHRvdGFsZ2FpbiAqIHBlcmxpbk5vaXNlMyhQICogc2MsIHJlcCk7XFxuICAgICAgICBzYyAqPSBsYWN1bmFyaXR5O1xcbiAgICAgICAgdG90YWxnYWluICo9IGdhaW47XFxuICAgIH1cXG4gICAgcmV0dXJuIGFicyhzdW0pO1xcbn1cIjtcblxuZXhwb3J0IHsgc291cmNlUGVybGluIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBlcmxpbjIubWpzLm1hcFxuIiwidmFyIGZyYWdtZW50ID0gXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuaW4gdmVjMiB2VGV4dHVyZUNvb3JkO1xcbm91dCB2ZWM0IGZpbmFsQ29sb3I7XFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxudW5pZm9ybSB2ZWMyIHVEaW1lbnNpb25zO1xcbnVuaWZvcm0gZmxvYXQgdVBhcmFsbGVsO1xcbnVuaWZvcm0gdmVjMiB1TGlnaHQ7XFxudW5pZm9ybSBmbG9hdCB1QXNwZWN0O1xcbnVuaWZvcm0gZmxvYXQgdVRpbWU7XFxudW5pZm9ybSB2ZWMzIHVSYXk7XFxuXFxudW5pZm9ybSB2ZWM0IHVJbnB1dFNpemU7XFxuXFxuJHtQRVJMSU59XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gICAgdmVjMiB1RGltZW5zaW9ucyA9IHVEaW1lbnNpb25zO1xcbiAgICBib29sIHVQYXJhbGxlbCA9IHVQYXJhbGxlbCA+IDAuNTtcXG4gICAgdmVjMiB1TGlnaHQgPSB1TGlnaHQ7XFxuICAgIGZsb2F0IHVBc3BlY3QgPSB1QXNwZWN0O1xcblxcbiAgICB2ZWMyIGNvb3JkID0gdlRleHR1cmVDb29yZCAqIHVJbnB1dFNpemUueHkgLyB1RGltZW5zaW9ucztcXG5cXG4gICAgZmxvYXQgZDtcXG5cXG4gICAgaWYgKHVQYXJhbGxlbCkge1xcbiAgICAgICAgZmxvYXQgX2NvcyA9IHVMaWdodC54O1xcbiAgICAgICAgZmxvYXQgX3NpbiA9IHVMaWdodC55O1xcbiAgICAgICAgZCA9IChfY29zICogY29vcmQueCkgKyAoX3NpbiAqIGNvb3JkLnkgKiB1QXNwZWN0KTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIGZsb2F0IGR4ID0gY29vcmQueCAtIHVMaWdodC54IC8gdURpbWVuc2lvbnMueDtcXG4gICAgICAgIGZsb2F0IGR5ID0gKGNvb3JkLnkgLSB1TGlnaHQueSAvIHVEaW1lbnNpb25zLnkpICogdUFzcGVjdDtcXG4gICAgICAgIGZsb2F0IGRpcyA9IHNxcnQoZHggKiBkeCArIGR5ICogZHkpICsgMC4wMDAwMTtcXG4gICAgICAgIGQgPSBkeSAvIGRpcztcXG4gICAgfVxcblxcbiAgICBmbG9hdCB1VGltZSA9IHVUaW1lO1xcbiAgICB2ZWMzIHVSYXkgPSB1UmF5O1xcblxcbiAgICBmbG9hdCBnYWluID0gdVJheVswXTtcXG4gICAgZmxvYXQgbGFjdW5hcml0eSA9IHVSYXlbMV07XFxuICAgIGZsb2F0IGFscGhhID0gdVJheVsyXTtcXG5cXG4gICAgdmVjMyBkaXIgPSB2ZWMzKGQsIGQsIDAuMCk7XFxuICAgIGZsb2F0IG5vaXNlID0gdHVyYihkaXIgKyB2ZWMzKHVUaW1lLCAwLjAsIDYyLjEgKyB1VGltZSkgKiAwLjA1LCB2ZWMzKDQ4MC4wLCAzMjAuMCwgNDgwLjApLCBsYWN1bmFyaXR5LCBnYWluKTtcXG4gICAgbm9pc2UgPSBtaXgobm9pc2UsIDAuMCwgMC4zKTtcXG4gICAgLy9mYWRlIHZlcnRpY2FsbHkuXFxuICAgIHZlYzQgbWlzdCA9IHZlYzQodmVjMyhub2lzZSksIDEuMCkgKiAoMS4wIC0gY29vcmQueSk7XFxuICAgIG1pc3QuYSA9IDEuMDtcXG4gICAgLy8gYXBwbHkgdXNlciBhbHBoYVxcbiAgICBtaXN0ICo9IGFscGhhO1xcblxcbiAgICBmaW5hbENvbG9yID0gdGV4dHVyZSh1VGV4dHVyZSwgdlRleHR1cmVDb29yZCkgKyBtaXN0O1xcbn1cXG5cIjtcblxuZXhwb3J0IHsgZnJhZ21lbnQgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z29kLXJheTIubWpzLm1hcFxuIiwidmFyIHBlcmxpbiA9IFwidmVjMyBtb2QyODkodmVjMyB4KVxcbntcXG4gICAgcmV0dXJuIHggLSBmbG9vcih4ICogKDEuMCAvIDI4OS4wKSkgKiAyODkuMDtcXG59XFxudmVjNCBtb2QyODkodmVjNCB4KVxcbntcXG4gICAgcmV0dXJuIHggLSBmbG9vcih4ICogKDEuMCAvIDI4OS4wKSkgKiAyODkuMDtcXG59XFxudmVjNCBwZXJtdXRlKHZlYzQgeClcXG57XFxuICAgIHJldHVybiBtb2QyODkoKCh4ICogMzQuMCkgKyAxLjApICogeCk7XFxufVxcbnZlYzQgdGF5bG9ySW52U3FydCh2ZWM0IHIpXFxue1xcbiAgICByZXR1cm4gMS43OTI4NDI5MTQwMDE1OSAtIDAuODUzNzM0NzIwOTUzMTQgKiByO1xcbn1cXG52ZWMzIGZhZGUodmVjMyB0KVxcbntcXG4gICAgcmV0dXJuIHQgKiB0ICogdCAqICh0ICogKHQgKiA2LjAgLSAxNS4wKSArIDEwLjApO1xcbn1cXG4vLyBDbGFzc2ljIFBlcmxpbiBub2lzZSwgcGVyaW9kaWMgdmFyaWFudFxcbmZsb2F0IHBub2lzZSh2ZWMzIFAsIHZlYzMgcmVwKVxcbntcXG4gICAgdmVjMyBQaTAgPSBtb2QoZmxvb3IoUCksIHJlcCk7IC8vIEludGVnZXIgcGFydCwgbW9kdWxvIHBlcmlvZFxcbiAgICB2ZWMzIFBpMSA9IG1vZChQaTAgKyB2ZWMzKDEuMCksIHJlcCk7IC8vIEludGVnZXIgcGFydCArIDEsIG1vZCBwZXJpb2RcXG4gICAgUGkwID0gbW9kMjg5KFBpMCk7XFxuICAgIFBpMSA9IG1vZDI4OShQaTEpO1xcbiAgICB2ZWMzIFBmMCA9IGZyYWN0KFApOyAvLyBGcmFjdGlvbmFsIHBhcnQgZm9yIGludGVycG9sYXRpb25cXG4gICAgdmVjMyBQZjEgPSBQZjAgLSB2ZWMzKDEuMCk7IC8vIEZyYWN0aW9uYWwgcGFydCAtIDEuMFxcbiAgICB2ZWM0IGl4ID0gdmVjNChQaTAueCwgUGkxLngsIFBpMC54LCBQaTEueCk7XFxuICAgIHZlYzQgaXkgPSB2ZWM0KFBpMC55eSwgUGkxLnl5KTtcXG4gICAgdmVjNCBpejAgPSBQaTAuenp6ejtcXG4gICAgdmVjNCBpejEgPSBQaTEuenp6ejtcXG4gICAgdmVjNCBpeHkgPSBwZXJtdXRlKHBlcm11dGUoaXgpICsgaXkpO1xcbiAgICB2ZWM0IGl4eTAgPSBwZXJtdXRlKGl4eSArIGl6MCk7XFxuICAgIHZlYzQgaXh5MSA9IHBlcm11dGUoaXh5ICsgaXoxKTtcXG4gICAgdmVjNCBneDAgPSBpeHkwICogKDEuMCAvIDcuMCk7XFxuICAgIHZlYzQgZ3kwID0gZnJhY3QoZmxvb3IoZ3gwKSAqICgxLjAgLyA3LjApKSAtIDAuNTtcXG4gICAgZ3gwID0gZnJhY3QoZ3gwKTtcXG4gICAgdmVjNCBnejAgPSB2ZWM0KDAuNSkgLSBhYnMoZ3gwKSAtIGFicyhneTApO1xcbiAgICB2ZWM0IHN6MCA9IHN0ZXAoZ3owLCB2ZWM0KDAuMCkpO1xcbiAgICBneDAgLT0gc3owICogKHN0ZXAoMC4wLCBneDApIC0gMC41KTtcXG4gICAgZ3kwIC09IHN6MCAqIChzdGVwKDAuMCwgZ3kwKSAtIDAuNSk7XFxuICAgIHZlYzQgZ3gxID0gaXh5MSAqICgxLjAgLyA3LjApO1xcbiAgICB2ZWM0IGd5MSA9IGZyYWN0KGZsb29yKGd4MSkgKiAoMS4wIC8gNy4wKSkgLSAwLjU7XFxuICAgIGd4MSA9IGZyYWN0KGd4MSk7XFxuICAgIHZlYzQgZ3oxID0gdmVjNCgwLjUpIC0gYWJzKGd4MSkgLSBhYnMoZ3kxKTtcXG4gICAgdmVjNCBzejEgPSBzdGVwKGd6MSwgdmVjNCgwLjApKTtcXG4gICAgZ3gxIC09IHN6MSAqIChzdGVwKDAuMCwgZ3gxKSAtIDAuNSk7XFxuICAgIGd5MSAtPSBzejEgKiAoc3RlcCgwLjAsIGd5MSkgLSAwLjUpO1xcbiAgICB2ZWMzIGcwMDAgPSB2ZWMzKGd4MC54LCBneTAueCwgZ3owLngpO1xcbiAgICB2ZWMzIGcxMDAgPSB2ZWMzKGd4MC55LCBneTAueSwgZ3owLnkpO1xcbiAgICB2ZWMzIGcwMTAgPSB2ZWMzKGd4MC56LCBneTAueiwgZ3owLnopO1xcbiAgICB2ZWMzIGcxMTAgPSB2ZWMzKGd4MC53LCBneTAudywgZ3owLncpO1xcbiAgICB2ZWMzIGcwMDEgPSB2ZWMzKGd4MS54LCBneTEueCwgZ3oxLngpO1xcbiAgICB2ZWMzIGcxMDEgPSB2ZWMzKGd4MS55LCBneTEueSwgZ3oxLnkpO1xcbiAgICB2ZWMzIGcwMTEgPSB2ZWMzKGd4MS56LCBneTEueiwgZ3oxLnopO1xcbiAgICB2ZWMzIGcxMTEgPSB2ZWMzKGd4MS53LCBneTEudywgZ3oxLncpO1xcbiAgICB2ZWM0IG5vcm0wID0gdGF5bG9ySW52U3FydCh2ZWM0KGRvdChnMDAwLCBnMDAwKSwgZG90KGcwMTAsIGcwMTApLCBkb3QoZzEwMCwgZzEwMCksIGRvdChnMTEwLCBnMTEwKSkpO1xcbiAgICBnMDAwICo9IG5vcm0wLng7XFxuICAgIGcwMTAgKj0gbm9ybTAueTtcXG4gICAgZzEwMCAqPSBub3JtMC56O1xcbiAgICBnMTEwICo9IG5vcm0wLnc7XFxuICAgIHZlYzQgbm9ybTEgPSB0YXlsb3JJbnZTcXJ0KHZlYzQoZG90KGcwMDEsIGcwMDEpLCBkb3QoZzAxMSwgZzAxMSksIGRvdChnMTAxLCBnMTAxKSwgZG90KGcxMTEsIGcxMTEpKSk7XFxuICAgIGcwMDEgKj0gbm9ybTEueDtcXG4gICAgZzAxMSAqPSBub3JtMS55O1xcbiAgICBnMTAxICo9IG5vcm0xLno7XFxuICAgIGcxMTEgKj0gbm9ybTEudztcXG4gICAgZmxvYXQgbjAwMCA9IGRvdChnMDAwLCBQZjApO1xcbiAgICBmbG9hdCBuMTAwID0gZG90KGcxMDAsIHZlYzMoUGYxLngsIFBmMC55eikpO1xcbiAgICBmbG9hdCBuMDEwID0gZG90KGcwMTAsIHZlYzMoUGYwLngsIFBmMS55LCBQZjAueikpO1xcbiAgICBmbG9hdCBuMTEwID0gZG90KGcxMTAsIHZlYzMoUGYxLnh5LCBQZjAueikpO1xcbiAgICBmbG9hdCBuMDAxID0gZG90KGcwMDEsIHZlYzMoUGYwLnh5LCBQZjEueikpO1xcbiAgICBmbG9hdCBuMTAxID0gZG90KGcxMDEsIHZlYzMoUGYxLngsIFBmMC55LCBQZjEueikpO1xcbiAgICBmbG9hdCBuMDExID0gZG90KGcwMTEsIHZlYzMoUGYwLngsIFBmMS55eikpO1xcbiAgICBmbG9hdCBuMTExID0gZG90KGcxMTEsIFBmMSk7XFxuICAgIHZlYzMgZmFkZV94eXogPSBmYWRlKFBmMCk7XFxuICAgIHZlYzQgbl96ID0gbWl4KHZlYzQobjAwMCwgbjEwMCwgbjAxMCwgbjExMCksIHZlYzQobjAwMSwgbjEwMSwgbjAxMSwgbjExMSksIGZhZGVfeHl6LnopO1xcbiAgICB2ZWMyIG5feXogPSBtaXgobl96Lnh5LCBuX3ouencsIGZhZGVfeHl6LnkpO1xcbiAgICBmbG9hdCBuX3h5eiA9IG1peChuX3l6LngsIG5feXoueSwgZmFkZV94eXoueCk7XFxuICAgIHJldHVybiAyLjIgKiBuX3h5ejtcXG59XFxuZmxvYXQgdHVyYih2ZWMzIFAsIHZlYzMgcmVwLCBmbG9hdCBsYWN1bmFyaXR5LCBmbG9hdCBnYWluKVxcbntcXG4gICAgZmxvYXQgc3VtID0gMC4wO1xcbiAgICBmbG9hdCBzYyA9IDEuMDtcXG4gICAgZmxvYXQgdG90YWxnYWluID0gMS4wO1xcbiAgICBmb3IgKGZsb2F0IGkgPSAwLjA7IGkgPCA2LjA7IGkrKylcXG4gICAge1xcbiAgICAgICAgc3VtICs9IHRvdGFsZ2FpbiAqIHBub2lzZShQICogc2MsIHJlcCk7XFxuICAgICAgICBzYyAqPSBsYWN1bmFyaXR5O1xcbiAgICAgICAgdG90YWxnYWluICo9IGdhaW47XFxuICAgIH1cXG4gICAgcmV0dXJuIGFicyhzdW0pO1xcbn1cXG5cIjtcblxuZXhwb3J0IHsgcGVybGluIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBlcmxpbi5tanMubWFwXG4iLCJpbXBvcnQgeyBGaWx0ZXIsIEdwdVByb2dyYW0sIEdsUHJvZ3JhbSB9IGZyb20gJ3BpeGkuanMnO1xuaW1wb3J0IHZlcnRleCBmcm9tICcuLi9kZWZhdWx0cy9kZWZhdWx0Mi5tanMnO1xuaW1wb3J0IHdnc2xWZXJ0ZXggZnJvbSAnLi4vZGVmYXVsdHMvZGVmYXVsdC5tanMnO1xuaW1wb3J0IGZyYWdtZW50IGZyb20gJy4vZ3JheXNjYWxlLm1qcyc7XG5pbXBvcnQgc291cmNlIGZyb20gJy4vZ3JheXNjYWxlMi5tanMnO1xuXG5jbGFzcyBHcmF5c2NhbGVGaWx0ZXIgZXh0ZW5kcyBGaWx0ZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBjb25zdCBncHVQcm9ncmFtID0gR3B1UHJvZ3JhbS5mcm9tKHtcbiAgICAgIHZlcnRleDoge1xuICAgICAgICBzb3VyY2U6IHdnc2xWZXJ0ZXgsXG4gICAgICAgIGVudHJ5UG9pbnQ6IFwibWFpblZlcnRleFwiXG4gICAgICB9LFxuICAgICAgZnJhZ21lbnQ6IHtcbiAgICAgICAgc291cmNlLFxuICAgICAgICBlbnRyeVBvaW50OiBcIm1haW5GcmFnbWVudFwiXG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgZ2xQcm9ncmFtID0gR2xQcm9ncmFtLmZyb20oe1xuICAgICAgdmVydGV4LFxuICAgICAgZnJhZ21lbnQsXG4gICAgICBuYW1lOiBcImdyYXlzY2FsZS1maWx0ZXJcIlxuICAgIH0pO1xuICAgIHN1cGVyKHtcbiAgICAgIGdwdVByb2dyYW0sXG4gICAgICBnbFByb2dyYW0sXG4gICAgICByZXNvdXJjZXM6IHt9XG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IHsgR3JheXNjYWxlRmlsdGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HcmF5c2NhbGVGaWx0ZXIubWpzLm1hcFxuIiwiaW1wb3J0IHsgRmlsdGVyLCBHcHVQcm9ncmFtLCBHbFByb2dyYW0gfSBmcm9tICdwaXhpLmpzJztcbmltcG9ydCB2ZXJ0ZXggZnJvbSAnLi4vZGVmYXVsdHMvZGVmYXVsdDIubWpzJztcbmltcG9ydCB3Z3NsVmVydGV4IGZyb20gJy4uL2RlZmF1bHRzL2RlZmF1bHQubWpzJztcbmltcG9ydCBmcmFnbWVudCBmcm9tICcuL2hzbGFkanVzdG1lbnQyLm1qcyc7XG5pbXBvcnQgc291cmNlIGZyb20gJy4vaHNsYWRqdXN0bWVudC5tanMnO1xuXG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiB7XG4gIF9fZGVmTm9ybWFsUHJvcChvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5jb25zdCBfSHNsQWRqdXN0bWVudEZpbHRlciA9IGNsYXNzIF9Ic2xBZGp1c3RtZW50RmlsdGVyIGV4dGVuZHMgRmlsdGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgdGhlIEhzbEFkanVzdG1lbnRGaWx0ZXIgY29uc3RydWN0b3IuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHsgLi4uX0hzbEFkanVzdG1lbnRGaWx0ZXIuREVGQVVMVF9PUFRJT05TLCAuLi5vcHRpb25zIH07XG4gICAgY29uc3QgZ3B1UHJvZ3JhbSA9IEdwdVByb2dyYW0uZnJvbSh7XG4gICAgICB2ZXJ0ZXg6IHtcbiAgICAgICAgc291cmNlOiB3Z3NsVmVydGV4LFxuICAgICAgICBlbnRyeVBvaW50OiBcIm1haW5WZXJ0ZXhcIlxuICAgICAgfSxcbiAgICAgIGZyYWdtZW50OiB7XG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgZW50cnlQb2ludDogXCJtYWluRnJhZ21lbnRcIlxuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGdsUHJvZ3JhbSA9IEdsUHJvZ3JhbS5mcm9tKHtcbiAgICAgIHZlcnRleCxcbiAgICAgIGZyYWdtZW50LFxuICAgICAgbmFtZTogXCJoc2wtYWRqdXN0bWVudC1maWx0ZXJcIlxuICAgIH0pO1xuICAgIHN1cGVyKHtcbiAgICAgIGdwdVByb2dyYW0sXG4gICAgICBnbFByb2dyYW0sXG4gICAgICByZXNvdXJjZXM6IHtcbiAgICAgICAgaHNsVW5pZm9ybXM6IHtcbiAgICAgICAgICB1SHNsOiB7IHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KDMpLCB0eXBlOiBcInZlYzM8ZjMyPlwiIH0sXG4gICAgICAgICAgdUNvbG9yaXplOiB7IHZhbHVlOiBvcHRpb25zLmNvbG9yaXplID8gMSA6IDAsIHR5cGU6IFwiZjMyXCIgfSxcbiAgICAgICAgICB1QWxwaGE6IHsgdmFsdWU6IG9wdGlvbnMuYWxwaGEsIHR5cGU6IFwiZjMyXCIgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInVuaWZvcm1zXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfaHVlXCIpO1xuICAgIHRoaXMudW5pZm9ybXMgPSB0aGlzLnJlc291cmNlcy5oc2xVbmlmb3Jtcy51bmlmb3JtcztcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYW1vdW50IG9mIGh1ZSBpbiBkZWdyZWVzICgtMTgwIHRvIDE4MClcbiAgICogQGRlZmF1bHQgMFxuICAgKi9cbiAgZ2V0IGh1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5faHVlO1xuICB9XG4gIHNldCBodWUodmFsdWUpIHtcbiAgICB0aGlzLl9odWUgPSB2YWx1ZTtcbiAgICB0aGlzLnVuaWZvcm1zLnVIc2xbMF0gPSB2YWx1ZSAqIChNYXRoLlBJIC8gMTgwKTtcbiAgfVxuICAvKipcbiAgICogVGhlIGFtb3VudCBvZiBsaWdodG5lc3MgKC0xIHRvIDEpXG4gICAqIEBkZWZhdWx0IDBcbiAgICovXG4gIGdldCBzYXR1cmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnVIc2xbMV07XG4gIH1cbiAgc2V0IHNhdHVyYXRpb24odmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnVIc2xbMV0gPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGFtb3VudCBvZiBsaWdodG5lc3MgKC0xIHRvIDEpXG4gICAqIEBkZWZhdWx0IDBcbiAgICovXG4gIGdldCBsaWdodG5lc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMudUhzbFsyXTtcbiAgfVxuICBzZXQgbGlnaHRuZXNzKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy51SHNsWzJdID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gY29sb3JpemUgdGhlIGltYWdlXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBnZXQgY29sb3JpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMudUNvbG9yaXplID09PSAxO1xuICB9XG4gIHNldCBjb2xvcml6ZSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMudUNvbG9yaXplID0gdmFsdWUgPyAxIDogMDtcbiAgfVxuICAvKipcbiAgICogVGhlIGFtb3VudCBvZiBhbHBoYSAoMCB0byAxKVxuICAgKiBAZGVmYXVsdCAxXG4gICAqL1xuICBnZXQgYWxwaGEoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMudUFscGhhO1xuICB9XG4gIHNldCBhbHBoYSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMudUFscGhhID0gdmFsdWU7XG4gIH1cbn07XG4vKiogRGVmYXVsdCB2YWx1ZXMgZm9yIG9wdGlvbnMuICovXG5fX3B1YmxpY0ZpZWxkKF9Ic2xBZGp1c3RtZW50RmlsdGVyLCBcIkRFRkFVTFRfT1BUSU9OU1wiLCB7XG4gIGh1ZTogMCxcbiAgc2F0dXJhdGlvbjogMCxcbiAgbGlnaHRuZXNzOiAwLFxuICBjb2xvcml6ZTogZmFsc2UsXG4gIGFscGhhOiAxXG59KTtcbmxldCBIc2xBZGp1c3RtZW50RmlsdGVyID0gX0hzbEFkanVzdG1lbnRGaWx0ZXI7XG5cbmV4cG9ydCB7IEhzbEFkanVzdG1lbnRGaWx0ZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUhzbEFkanVzdG1lbnRGaWx0ZXIubWpzLm1hcFxuIiwidmFyIHNvdXJjZSA9IFwic3RydWN0IEhzbFVuaWZvcm1zIHtcXG4gIHVIc2w6dmVjMzxmMzI+LFxcbiAgdUNvbG9yaXplOmYzMixcXG4gIHVBbHBoYTpmMzIsXFxufTtcXG5cXG5AZ3JvdXAoMCkgQGJpbmRpbmcoMSkgdmFyIHVUZXh0dXJlOiB0ZXh0dXJlXzJkPGYzMj47IFxcbkBncm91cCgwKSBAYmluZGluZygyKSB2YXIgdVNhbXBsZXI6IHNhbXBsZXI7XFxuQGdyb3VwKDEpIEBiaW5kaW5nKDApIHZhcjx1bmlmb3JtPiBoc2xVbmlmb3JtcyA6IEhzbFVuaWZvcm1zO1xcblxcbkBmcmFnbWVudFxcbmZuIG1haW5GcmFnbWVudChcXG4gIEBsb2NhdGlvbigwKSB1djogdmVjMjxmMzI+LFxcbiAgQGJ1aWx0aW4ocG9zaXRpb24pIHBvc2l0aW9uOiB2ZWM0PGYzMj5cXG4pIC0+IEBsb2NhdGlvbigwKSB2ZWM0PGYzMj4ge1xcbiAgICBsZXQgY29sb3I6IHZlYzQ8ZjMyPiA9IHRleHR1cmVTYW1wbGUodVRleHR1cmUsIHVTYW1wbGVyLCB1dik7XFxuICAgIHZhciByZXN1bHRSR0I6IHZlYzM8ZjMyPiA9IGNvbG9yLnJnYjtcXG5cXG4gICAgbGV0IGh1ZTogZjMyID0gaHNsVW5pZm9ybXMudUhzbFswXTtcXG4gICAgbGV0IHNhdHVyYXRpb246IGYzMiA9IGhzbFVuaWZvcm1zLnVIc2xbMV07XFxuICAgIGxldCBsaWdodG5lc3M6IGYzMiA9IGhzbFVuaWZvcm1zLnVIc2xbMl07XFxuXFxuICAgIC8vIGNvbG9yaXplXFxuICAgIGlmIChoc2xVbmlmb3Jtcy51Q29sb3JpemUgPiAwLjUpIHtcXG4gICAgICAgIHJlc3VsdFJHQiA9IHZlYzM8ZjMyPihkb3QoY29sb3IucmdiLCB2ZWMzPGYzMj4oMC4yOTksIDAuNTg3LCAwLjExNCkpLCAwLiwgMC4pO1xcbiAgICB9XFxuXFxuICAgIC8vIGh1ZVxcbiAgICByZXN1bHRSR0IgPSBodWVTaGlmdChyZXN1bHRSR0IsIGh1ZSk7XFxuXFxuICAgIC8vIHNhdHVyYXRpb25cXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2V2YW53L2dsZnguanMvYmxvYi9tYXN0ZXIvc3JjL2ZpbHRlcnMvYWRqdXN0L2h1ZXNhdHVyYXRpb24uanNcXG4gICAgbGV0IGF2ZXJhZ2U6IGYzMiA9IChyZXN1bHRSR0IuciArIHJlc3VsdFJHQi5nICsgcmVzdWx0UkdCLmIpIC8gMy4wO1xcblxcbiAgICBpZiAoc2F0dXJhdGlvbiA+IDAuKSB7XFxuICAgICAgICByZXN1bHRSR0IgKz0gKGF2ZXJhZ2UgLSByZXN1bHRSR0IpICogKDEuIC0gMS4gLyAoMS4wMDEgLSBzYXR1cmF0aW9uKSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICByZXN1bHRSR0IgLT0gKGF2ZXJhZ2UgLSByZXN1bHRSR0IpICogc2F0dXJhdGlvbjtcXG4gICAgfVxcblxcbiAgICAvLyBsaWdodG5lc3NcXG4gICAgcmVzdWx0UkdCID0gbWl4KHJlc3VsdFJHQiwgdmVjMzxmMzI+KGNlaWwobGlnaHRuZXNzKSkgKiBjb2xvci5hLCBhYnMobGlnaHRuZXNzKSk7XFxuXFxuICAgIC8vIGFscGhhXFxuICAgIHJldHVybiBtaXgoY29sb3IsIHZlYzQ8ZjMyPihyZXN1bHRSR0IsIGNvbG9yLmEpLCBoc2xVbmlmb3Jtcy51QWxwaGEpO1xcbn1cXG5cXG4vLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9tYWlyb2QvYTc1ZTdiNDRmNjgxMTBlMTU3NmQ3NzQxOWQ2MDg3ODY/cGVybWFsaW5rX2NvbW1lbnRfaWQ9MzE5NTI0MyNnaXN0Y29tbWVudC0zMTk1MjQzXFxuY29uc3QgazogdmVjMzxmMzI+ID0gdmVjMygwLjU3NzM1LCAwLjU3NzM1LCAwLjU3NzM1KTtcXG5cXG5mbiBodWVTaGlmdChjb2xvcjogdmVjMzxmMzI+LCBhbmdsZTogZjMyKSAtPiB2ZWMzPGYzMj4gXFxue1xcbiAgICBsZXQgY29zQW5nbGU6IGYzMiA9IGNvcyhhbmdsZSk7XFxuICAgIHJldHVybiB2ZWMzPGYzMj4oXFxuICAgIGNvbG9yICogY29zQW5nbGUgK1xcbiAgICBjcm9zcyhrLCBjb2xvcikgKiBzaW4oYW5nbGUpICtcXG4gICAgayAqIGRvdChrLCBjb2xvcikgKiAoMS4wIC0gY29zQW5nbGUpXFxuICAgICk7XFxufVwiO1xuXG5leHBvcnQgeyBzb3VyY2UgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aHNsYWRqdXN0bWVudC5tanMubWFwXG4iLCJ2YXIgZnJhZ21lbnQgPSBcImluIHZlYzIgdlRleHR1cmVDb29yZDtcXG5vdXQgdmVjNCBmaW5hbENvbG9yO1xcblxcbnVuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbnVuaWZvcm0gdmVjMyB1SHNsO1xcbnVuaWZvcm0gZmxvYXQgdUFscGhhO1xcbnVuaWZvcm0gZmxvYXQgdUNvbG9yaXplO1xcblxcbi8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0x1bWFfKHZpZGVvKVxcbmNvbnN0IHZlYzMgd2VpZ2h0ID0gdmVjMygwLjI5OSwgMC41ODcsIDAuMTE0KTtcXG5cXG5mbG9hdCBnZXRXZWlnaHRlZEF2ZXJhZ2UodmVjMyByZ2IpIHtcXG4gICAgcmV0dXJuIHJnYi5yICogd2VpZ2h0LnIgKyByZ2IuZyAqIHdlaWdodC5nICsgcmdiLmIgKiB3ZWlnaHQuYjtcXG59XFxuXFxuLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vbWFpcm9kL2E3NWU3YjQ0ZjY4MTEwZTE1NzZkNzc0MTlkNjA4Nzg2P3Blcm1hbGlua19jb21tZW50X2lkPTMxOTUyNDMjZ2lzdGNvbW1lbnQtMzE5NTI0M1xcbmNvbnN0IHZlYzMgayA9IHZlYzMoMC41NzczNSwgMC41NzczNSwgMC41NzczNSk7XFxuXFxudmVjMyBodWVTaGlmdCh2ZWMzIGNvbG9yLCBmbG9hdCBhbmdsZSkge1xcbiAgICBmbG9hdCBjb3NBbmdsZSA9IGNvcyhhbmdsZSk7XFxuICAgIHJldHVybiB2ZWMzKFxcbiAgICBjb2xvciAqIGNvc0FuZ2xlICtcXG4gICAgY3Jvc3MoaywgY29sb3IpICogc2luKGFuZ2xlKSArXFxuICAgIGsgKiBkb3QoaywgY29sb3IpICogKDEuMCAtIGNvc0FuZ2xlKVxcbiAgICApO1xcbn1cXG5cXG52b2lkIG1haW4oKVxcbntcXG4gICAgdmVjNCBjb2xvciA9IHRleHR1cmUodVRleHR1cmUsIHZUZXh0dXJlQ29vcmQpO1xcbiAgICB2ZWMzIHJlc3VsdFJHQiA9IGNvbG9yLnJnYjtcXG5cXG4gICAgZmxvYXQgaHVlID0gdUhzbFswXTtcXG4gICAgZmxvYXQgc2F0dXJhdGlvbiA9IHVIc2xbMV07XFxuICAgIGZsb2F0IGxpZ2h0bmVzcyA9IHVIc2xbMl07XFxuXFxuICAgIC8vIGNvbG9yaXplXFxuICAgIGlmICh1Q29sb3JpemUgPiAwLjUpIHtcXG4gICAgICAgIHJlc3VsdFJHQiA9IHZlYzMoZ2V0V2VpZ2h0ZWRBdmVyYWdlKHJlc3VsdFJHQiksIDAuLCAwLik7XFxuICAgIH1cXG5cXG4gICAgLy8gaHVlXFxuICAgIHJlc3VsdFJHQiA9IGh1ZVNoaWZ0KHJlc3VsdFJHQiwgaHVlKTtcXG5cXG4gICAgLy8gc2F0dXJhdGlvblxcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZXZhbncvZ2xmeC5qcy9ibG9iL21hc3Rlci9zcmMvZmlsdGVycy9hZGp1c3QvaHVlc2F0dXJhdGlvbi5qc1xcbiAgICBmbG9hdCBhdmVyYWdlID0gKHJlc3VsdFJHQi5yICsgcmVzdWx0UkdCLmcgKyByZXN1bHRSR0IuYikgLyAzLjA7XFxuXFxuICAgIGlmIChzYXR1cmF0aW9uID4gMC4pIHtcXG4gICAgICAgIHJlc3VsdFJHQiArPSAoYXZlcmFnZSAtIHJlc3VsdFJHQikgKiAoMS4gLSAxLiAvICgxLjAwMSAtIHNhdHVyYXRpb24pKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIHJlc3VsdFJHQiAtPSAoYXZlcmFnZSAtIHJlc3VsdFJHQikgKiBzYXR1cmF0aW9uO1xcbiAgICB9XFxuXFxuICAgIC8vIGxpZ2h0bmVzc1xcbiAgICByZXN1bHRSR0IgPSBtaXgocmVzdWx0UkdCLCB2ZWMzKGNlaWwobGlnaHRuZXNzKSkgKiBjb2xvci5hLCBhYnMobGlnaHRuZXNzKSk7XFxuXFxuICAgIC8vIGFscGhhXFxuICAgIGZpbmFsQ29sb3IgPSBtaXgoY29sb3IsIHZlYzQocmVzdWx0UkdCLCBjb2xvci5hKSwgdUFscGhhKTtcXG59XFxuXCI7XG5cbmV4cG9ydCB7IGZyYWdtZW50IGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhzbGFkanVzdG1lbnQyLm1qcy5tYXBcbiJdLCJuYW1lcyI6WyJhcHBsZUlwaG9uZSIsImFwcGxlSXBvZCIsImFwcGxlVGFibGV0IiwiYXBwbGVVbml2ZXJzYWwiLCJhbmRyb2lkUGhvbmUiLCJhbmRyb2lkVGFibGV0IiwiYW1hem9uUGhvbmUiLCJhbWF6b25UYWJsZXQiLCJ3aW5kb3dzUGhvbmUiLCJ3aW5kb3dzVGFibGV0Iiwib3RoZXJCbGFja0JlcnJ5Iiwib3RoZXJCbGFja0JlcnJ5MTAiLCJvdGhlck9wZXJhIiwib3RoZXJDaHJvbWUiLCJvdGhlckZpcmVmb3giLCJpc0FwcGxlVGFibGV0T25Jb3MxMyIsIm5hdmlnYXRvciIsInBsYXRmb3JtIiwibWF4VG91Y2hQb2ludHMiLCJNU1N0cmVhbSIsImlzTW9iaWxlIiwicGFyYW0iLCJuYXYiLCJ1c2VyQWdlbnQiLCJ0bXAiLCJzcGxpdCIsIm1hdGNoIiwicmVnZXgiLCJ0ZXN0IiwiY3JlYXRlTWF0Y2giLCJyZXN1bHQiLCJhcHBsZSIsInBob25lIiwiaXBvZCIsInRhYmxldCIsInVuaXZlcnNhbCIsImRldmljZSIsImFtYXpvbiIsImFuZHJvaWQiLCJ3aW5kb3dzIiwib3RoZXIiLCJibGFja2JlcnJ5IiwiYmxhY2tiZXJyeTEwIiwib3BlcmEiLCJmaXJlZm94IiwiY2hyb21lIiwiYW55IiwibW9kdWxlIiwiZXhwb3J0cyIsInBhdGgiLCJkYXRhIiwicmVwbGFjZSIsInNlZ21lbnQiLCJfIiwiY29tbWFuZCIsImFyZ3MiLCJ0eXBlIiwidG9Mb3dlckNhc2UiLCJudW1iZXJzIiwibnVtYmVyIiwibWFwIiwiTnVtYmVyIiwicGFyc2VWYWx1ZXMiLCJsZW5ndGgiLCJwdXNoIiwiY29uY2F0Iiwic3BsaWNlIiwidW5zaGlmdCIsIkVycm9yIiwiYSIsImMiLCJoIiwibCIsIm0iLCJxIiwicyIsInQiLCJ2IiwieiIsIl9fZGVmUHJvcCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiX19wdWJsaWNGaWVsZCIsIm9iaiIsImtleSIsInZhbHVlIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX19kZWZOb3JtYWxQcm9wIiwiX0FkanVzdG1lbnRGaWx0ZXIiLCJjb25zdHJ1Y3RvciIsIm9wdGlvbnMiLCJERUZBVUxUX09QVElPTlMiLCJzdXBlciIsImdwdVByb2dyYW0iLCJmcm9tIiwidmVydGV4Iiwic291cmNlIiwiZW50cnlQb2ludCIsImZyYWdtZW50IiwiZ2xQcm9ncmFtIiwibmFtZSIsInJlc291cmNlcyIsImFkanVzdG1lbnRVbmlmb3JtcyIsInVHYW1tYSIsImdhbW1hIiwidUNvbnRyYXN0IiwiY29udHJhc3QiLCJ1U2F0dXJhdGlvbiIsInNhdHVyYXRpb24iLCJ1QnJpZ2h0bmVzcyIsImJyaWdodG5lc3MiLCJ1Q29sb3IiLCJyZWQiLCJncmVlbiIsImJsdWUiLCJhbHBoYSIsInRoaXMiLCJ1bmlmb3JtcyIsIl9FeHRyYWN0QnJpZ2h0bmVzc0ZpbHRlciIsImV4dHJhY3RCcmlnaHRuZXNzVW5pZm9ybXMiLCJ1VGhyZXNob2xkIiwidGhyZXNob2xkIiwiRXh0cmFjdEJyaWdodG5lc3NGaWx0ZXIiLCJfQWR2YW5jZWRCbG9vbUZpbHRlciIsImFkdmFuY2VkQmxvb21Vbmlmb3JtcyIsInVCbG9vbVNjYWxlIiwiYmxvb21TY2FsZSIsInVNYXBUZXh0dXJlIiwiV0hJVEUiLCJfZXh0cmFjdEZpbHRlciIsIl9ibHVyRmlsdGVyIiwiS2F3YXNlQmx1ckZpbHRlciIsInN0cmVuZ3RoIiwia2VybmVscyIsImJsdXIiLCJxdWFsaXR5IiwiYXNzaWduIiwiYXBwbHkiLCJmaWx0ZXJNYW5hZ2VyIiwiaW5wdXQiLCJvdXRwdXQiLCJjbGVhck1vZGUiLCJicmlnaHRUYXJnZXQiLCJnZXRTYW1lU2l6ZVRleHR1cmUiLCJibG9vbVRhcmdldCIsImFwcGx5RmlsdGVyIiwicmV0dXJuVGV4dHVyZSIsInBpeGVsU2l6ZSIsIngiLCJ5IiwiQXJyYXkiLCJpc0FycmF5IiwicGl4ZWxTaXplWCIsInBpeGVsU2l6ZVkiLCJfQXNjaWlGaWx0ZXIiLCJzaXplIiwicmVwbGFjZUNvbG9yIiwiY29sb3IiLCJhc2NpaVVuaWZvcm1zIiwidVNpemUiLCJGbG9hdDMyQXJyYXkiLCJ1UmVwbGFjZUNvbG9yIiwiX2NvbG9yIiwic2V0VmFsdWUiLCJyIiwiZyIsImIiLCJ0b0FycmF5IiwiX0JldmVsRmlsdGVyIiwiYmV2ZWxVbmlmb3JtcyIsInVMaWdodENvbG9yIiwidUxpZ2h0QWxwaGEiLCJsaWdodEFscGhhIiwidVNoYWRvd0NvbG9yIiwidVNoYWRvd0FscGhhIiwic2hhZG93QWxwaGEiLCJ1VHJhbnNmb3JtIiwicGFkZGluZyIsIl9saWdodENvbG9yIiwiX3NoYWRvd0NvbG9yIiwibGlnaHRDb2xvciIsInNoYWRvd0NvbG9yIiwicm90YXRpb24iLCJfcm90YXRpb24iLCJfdXBkYXRlVHJhbnNmb3JtIiwidGhpY2tuZXNzIiwiX3RoaWNrbmVzcyIsIk1hdGgiLCJjb3MiLCJzaW4iLCJfQmxvb21GaWx0ZXIiLCJyZXNvbHV0aW9uIiwia2VybmVsU2l6ZSIsIl9zdHJlbmd0aCIsIl9ibHVyWEZpbHRlciIsImhvcml6b250YWwiLCJzdHJlbmd0aFgiLCJfYmx1cllGaWx0ZXIiLCJzdHJlbmd0aFkiLCJibGVuZE1vZGUiLCJjbGVhciIsInJlbmRlclRhcmdldCIsIl91cGRhdGVTdHJlbmd0aCIsImJsdXJYIiwiYmx1clkiLCJfQnVsZ2VQaW5jaEZpbHRlciIsImJ1bGdlUGluY2hVbmlmb3JtcyIsInVEaW1lbnNpb25zIiwidUNlbnRlciIsImNlbnRlciIsInVSYWRpdXMiLCJyYWRpdXMiLCJ1U3RyZW5ndGgiLCJmcmFtZSIsIndpZHRoIiwiaGVpZ2h0IiwiY2VudGVyWCIsImNlbnRlclkiLCJfQ29sb3JHcmFkaWVudEZpbHRlciIsImNzcyIsImRlZmF1bHRzIiwibWF4Q29sb3JzIiwic3RvcHMiLCJiYXNlVW5pZm9ybXMiLCJ1T3B0aW9ucyIsImFuZ2xlIiwidUNvdW50cyIsInN0b3BzVW5pZm9ybXMiLCJ1Q29sb3JzIiwibWF4U3RvcHMiLCJ1U3RvcHMiLCJfc3RvcHMiLCJzb3J0ZWRTdG9wcyIsInNvcnQiLCJvZmZzZXQiLCJzb3J0Q29sb3JTdG9wcyIsImkiLCJpbmRleFN0YXJ0IiwiTElORUFSIiwidmlzaXRvciIsIkdyYWRpZW50UGFyc2VyIiwic3RyaW5naWZ5Iiwibm9kZSIsInZpc2l0X2dyYWRpZW50Iiwib3JpZW50YXRpb24iLCJ2aXNpdCIsImNvbG9yU3RvcHMiLCJhdCIsInN0eWxlIiwidmlzaXRfY29sb3IiLCJqb2luIiwicmVzdWx0Q29sb3IiLCJlbGVtZW50cyIsImZvckVhY2giLCJlbGVtZW50IiwidmlzaXRfYXJyYXkiLCJub2RlVmlzaXRvciIsInJvb3QiLCJwYXJzZSIsInRva2VucyIsImVycm9yIiwibXNnIiwiZXJyIiwiZ2V0QVNUIiwiYXN0IiwibWF0Y2hMaXN0aW5nIiwibWF0Y2hEZWZpbml0aW9uIiwibWF0Y2hHcmFkaWVudCIsIm1hdGNoTGluZWFyT3JpZW50YXRpb24iLCJtYXRjaExpc3RSYWRpYWxPcmllbnRhdGlvbnMiLCJncmFkaWVudFR5cGUiLCJwYXR0ZXJuIiwib3JpZW50YXRpb25NYXRjaGVyIiwibWF0Y2hDYWxsIiwiY2FwdHVyZXMiLCJzY2FuIiwibWF0Y2hDb2xvclN0b3AiLCJjYWxsYmFjayIsInJhZGlhbE9yaWVudGF0aW9ucyIsImxvb2thaGVhZENhY2hlIiwicmFkaWFsT3JpZW50YXRpb24iLCJtYXRjaFJhZGlhbE9yaWVudGF0aW9uIiwicmFkaWFsVHlwZSIsImNpcmNsZSIsIm1hdGNoTGVuZ3RoIiwibWF0Y2hFeHRlbnRLZXl3b3JkIiwibWF0Y2hDaXJjbGUiLCJlbGxpcHNlIiwibWF0Y2hEaXN0YW5jZSIsIm1hdGNoRWxsaXBzZSIsIm1hdGNoQXRQb3NpdGlvbiIsImV4dGVudCIsInBvc2l0aW9uQXQiLCJkZWZhdWx0UG9zaXRpb24iLCJtYXRjaFBvc2l0aW9uaW5nIiwicG9zaXRpb25pbmciLCJsb2NhdGlvbiIsIm1hdGNoZXIiLCJtYXRjaE51bWJlciIsImNhcHR1cmVJbmRleCIsInJlZ2V4cCIsImJsYW5rQ2FwdHVyZXMiLCJleGVjIiwiY29uc3VtZSIsInN1YnN0ciIsImNvZGUiLCJ0b1N0cmluZyIsInBhcnNlQ3NzR3JhZGllbnQiLCJjc3NHcmFkaWVudCIsImNzc0dyYWRpZW50Tm9kZXMiLCJ2YWx1ZV8iLCJ0cmltIiwidHJpbUNzc0dyYWRpZW50IiwiY3NzR3JhZGllbnROb2RlIiwic3VwcG9ydGVkVHlwZXMiLCJ0eXBlRnJvbUNzc1R5cGUiLCJvZmZzZXRzIiwiZHluYW1pY09mZnNldCIsImNzc1N0b3AiLCJzdG9wT2Zmc2V0IiwicGFyc2VGbG9hdCIsImZpbmROZXh0Rml4ZWRTdG9wIiwiZnJvbUluZGV4IiwiayIsImluZGV4RGVsdGEiLCJwcmV2Rml4ZWRPZmZzZXQiLCJuZXh0Rml4ZWQiLCJzdGVwU2l6ZSIsImZpeEZsb2F0Um91bmRpbmciLCJvZmZzZXRzRnJvbUNzc0NvbG9yU3RvcHMiLCJjb2xvclN0cmluZyIsImNvbG9yQXNTdHJpbmdGcm9tQ3NzU3RvcCIsInJnYmFDb2xvciIsInNsaWNlIiwic3RvcHNGcm9tQ3NzU3RvcHMiLCJzdXBwb3J0ZWRWYWx1ZXMiLCJsZWZ0IiwidG9wIiwiYm90dG9tIiwicmlnaHQiLCJhbmdsZUZyb21EaXJlY3Rpb25hbFZhbHVlIiwiYW5nbGVGcm9tQ3NzT3JpZW50YXRpb24iLCJzdG9wIiwic3Vic3RyaW5nIiwiX0NvbG9yTWFwRmlsdGVyIiwiY29sb3JNYXAiLCJuZWFyZXN0IiwibWl4IiwiY29sb3JNYXBVbmlmb3JtcyIsInVNaXgiLCJ1U2xpY2VTaXplIiwidVNsaWNlUGl4ZWxTaXplIiwidVNsaWNlSW5uZXJTaXplIiwidU1hcFNhbXBsZXIiLCJjb2xvclNpemUiLCJfc2l6ZSIsIl9jb2xvck1hcCIsInNvdXJjZTIiLCJzY2FsZU1vZGUiLCJfc2NhbGVNb2RlIiwiYXV0b0dlbmVyYXRlTWlwbWFwcyIsIl9zbGljZVNpemUiLCJfc2xpY2VQaXhlbFNpemUiLCJfc2xpY2VJbm5lclNpemUiLCJfbmVhcmVzdCIsInRleHR1cmUiLCJ1cGRhdGUiLCJ1cGRhdGVDb2xvck1hcCIsImRlc3Ryb3kiLCJfQ29sb3JPdmVybGF5RmlsdGVyIiwiY29sb3JPdmVybGF5VW5pZm9ybXMiLCJ1QWxwaGEiLCJfQ29sb3JSZXBsYWNlRmlsdGVyIiwib3JpZ2luYWxDb2xvciIsInRhcmdldENvbG9yIiwidG9sZXJhbmNlIiwiY29sb3JSZXBsYWNlVW5pZm9ybXMiLCJ1T3JpZ2luYWxDb2xvciIsInVUYXJnZXRDb2xvciIsInVUb2xlcmFuY2UiLCJfb3JpZ2luYWxDb2xvciIsIl90YXJnZXRDb2xvciIsIm5ld0NvbG9yIiwiZXBzaWxvbiIsIl9Db252b2x1dGlvbkZpbHRlciIsIm1hdHJpeCIsImNvbnZvbHV0aW9uVW5pZm9ybXMiLCJ1TWF0cml4IiwidVRleGVsU2l6ZSIsIl9DUlRGaWx0ZXIiLCJjcnRVbmlmb3JtcyIsInVMaW5lIiwidU5vaXNlIiwidVZpZ25ldHRlIiwidVNlZWQiLCJzZWVkIiwidVRpbWUiLCJ0aW1lIiwiY3VydmF0dXJlIiwibGluZVdpZHRoIiwibGluZUNvbnRyYXN0IiwidmVydGljYWxMaW5lIiwibm9pc2UiLCJub2lzZVNpemUiLCJ2aWduZXR0aW5nIiwidmlnbmV0dGluZ0FscGhhIiwidmlnbmV0dGluZ0JsdXIiLCJ3Z3NsVmVydGV4IiwiX0RvdEZpbHRlciIsInNjYWxlIiwiZ3JheXNjYWxlIiwiZG90VW5pZm9ybXMiLCJ1U2NhbGUiLCJ1QW5nbGUiLCJ1R3JheVNjYWxlIiwiX0Ryb3BTaGFkb3dGaWx0ZXIiLCJkcm9wU2hhZG93VW5pZm9ybXMiLCJ1T2Zmc2V0IiwiX2Jhc2VQYXNzIiwic2hhZG93T25seSIsIl91cGRhdGVQYWRkaW5nIiwib2Zmc2V0WCIsIm9mZnNldFkiLCJvZmZzZXRQYWRkaW5nIiwibWF4IiwiYWJzIiwiRHJvcFNoYWRvd0ZpbHRlciIsIl9HbGl0Y2hGaWx0ZXIiLCJjYW52YXMiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJzYW1wbGVTaXplIiwicmVzb3VyY2UiLCJnbGl0Y2hVbmlmb3JtcyIsInVBc3BlY3QiLCJ1RmlsbE1vZGUiLCJmaWxsTW9kZSIsInVEaXJlY3Rpb24iLCJkaXJlY3Rpb24iLCJ1UmVkIiwidUdyZWVuIiwidUJsdWUiLCJ1RGlzcGxhY2VtZW50TWFwIiwidURpc3BsYWNlbWVudFNhbXBsZXIiLCJfY2FudmFzIiwiX3JhbmRvbWl6ZVNpemVzIiwiYXJyIiwiX3NpemVzIiwibGFzdCIsIl9zbGljZXMiLCJtaW4iLCJtaW5TaXplIiwiYXZlcmFnZSIsImNvdW50IiwicmVzdCIsImF2ZXJhZ2VXaWR0aCIsInciLCJyYW5kb20iLCJyYXRpbyIsInNxcnQiLCJzaHVmZmxlIiwicmFuZCIsInRlbXAiLCJfcmFuZG9taXplT2Zmc2V0cyIsIl9vZmZzZXRzIiwicmVmcmVzaCIsInJlZHJhdyIsImN0eCIsImdldENvbnRleHQiLCJjbGVhclJlY3QiLCJmbG9vciIsImZpbGxTdHlsZSIsImZpbGxSZWN0Iiwic2l6ZXMiLCJsZW4iLCJzbGljZXMiLCJfR2xvd0ZpbHRlciIsImRpc3RhbmNlIiwidG9GaXhlZCIsImdsb3dVbmlmb3JtcyIsInVEaXN0YW5jZSIsImlubmVyU3RyZW5ndGgiLCJvdXRlclN0cmVuZ3RoIiwidVF1YWxpdHkiLCJ1S25vY2tvdXQiLCJrbm9ja291dCIsIl9Hb2RyYXlGaWx0ZXIiLCJnb2RyYXlVbmlmb3JtcyIsInVMaWdodCIsInVQYXJhbGxlbCIsInVSYXkiLCJwYXJhbGxlbCIsIl9hbmdsZUxpZ2h0IiwiX2NlbnRlciIsIl9hbmdsZSIsInJhZGlhbnMiLCJnYWluIiwibGFjdW5hcml0eSIsIl9Ic2xBZGp1c3RtZW50RmlsdGVyIiwiaHNsVW5pZm9ybXMiLCJ1SHNsIiwidUNvbG9yaXplIiwiY29sb3JpemUiLCJodWUiLCJfaHVlIiwiUEkiLCJsaWdodG5lc3MiXSwic291cmNlUm9vdCI6IiJ9